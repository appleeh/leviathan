; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG8588	DB	'%s hashMap key distribution m_nMaxCount[%d]', 0aH, 00H
	ORG $+3
$SG8590	DB	' --- m_pHashData[%d] useCount[%d]', 0aH, 00H
	ORG $+5
$SG8593	DB	' m_nMaxCount[%d] usedKeyCount[%d]', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	_tcsncpy
PUBLIC	_tcscmp
PUBLIC	??0CHash@@QEAA@I@Z				; CHash::CHash
PUBLIC	??1CHash@@QEAA@XZ				; CHash::~CHash
PUBLIC	?clear@CHash@@QEAAXXZ				; CHash::clear
PUBLIC	?getHashNo@CHash@@QEAAIPEAD@Z			; CHash::getHashNo
PUBLIC	?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z	; CHash::hashLookup
PUBLIC	?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z	; CHash::hashLookup
PUBLIC	?getNext@CHash@@QEAAPEAUSThash_next@@I@Z	; CHash::getNext
PUBLIC	?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z	; CHash::getNext
PUBLIC	?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ; CHash::getNode
PUBLIC	?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z ; CHash::setValue
PUBLIC	?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z ; CHash::setValue
PUBLIC	?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::addNode
PUBLIC	?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::uniqueAddNode
PUBLIC	?getString@CHash@@QEAA_KPEAD0I@Z		; CHash::getString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp__mbscmp:PROC
EXTRN	__imp__mbsnbcpy:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tcsncpy DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$_tcsncpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tcscmp DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$_tcscmp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CHash@@QEAA@I@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??0CHash@@QEAA@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CHash@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??1CHash@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@CHash@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$?clear@CHash@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getHashNo@CHash@@QEAAIPEAD@Z DD imagerel $LN7
	DD	imagerel $LN7+156
	DD	imagerel $unwind$?getHashNo@CHash@@QEAAIPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+139
	DD	imagerel $unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+124
	DD	imagerel $unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z DD imagerel $LN7
	DD	imagerel $LN7+168
	DD	imagerel $unwind$?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z DD imagerel $LN7
	DD	imagerel $LN7+126
	DD	imagerel $unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+314
	DD	imagerel $unwind$?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD imagerel $LN10
	DD	imagerel $LN10+346
	DD	imagerel $unwind$?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getString@CHash@@QEAA_KPEAD0I@Z DD imagerel $LN20
	DD	imagerel $LN20+980
	DD	imagerel $unwind$?getString@CHash@@QEAA_KPEAD0I@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getString@CHash@@QEAA_KPEAD0I@Z DD 023319H
	DD	025b0121H
	DD	imagerel __GSHandlerCheck
	DD	012c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getHashNo@CHash@@QEAAIPEAD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@CHash@@QEAAXXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CHash@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CHash@@QEAA@I@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tcscmp DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tcsncpy DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getString@CHash@@QEAA_KPEAD0I@Z
_TEXT	SEGMENT
nNextPos$ = 32
tv78 = 36
tv143 = 37
tv166 = 38
nStrSize$ = 40
i$ = 44
j$ = 48
nUseCount$ = 52
tv196 = 56
tv76 = 64
tv189 = 72
tv141 = 80
tv182 = 88
tv164 = 96
tv73 = 104
pNext$ = 112
tv138 = 120
tv161 = 128
tv195 = 136
tv188 = 144
tv181 = 152
tv77 = 160
tv142 = 168
tv165 = 176
szUnit$ = 192
szBuf$ = 704
__$ArrayPad$ = 4800
this$ = 4832
pTitle$ = 4840
pBuf$ = 4848
nBufMax$ = 4856
?getString@CHash@@QEAA_KPEAD0I@Z PROC			; CHash::getString, COMDAT

; 176  : {

$LN20:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	b8 d8 12 00 00	 mov	 eax, 4824		; 000012d8H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 c0
	12 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 177  : 	/*
; 178  : 	TCHAR szBuf[128];
; 179  : 	size_t nSize[5];
; 180  : 	memset(nSize, 0, sizeof(nSize));
; 181  : 	int i, cnt = 0;
; 182  : 	nSize[cnt++] = sizeof(m_pHashData);
; 183  : 	nSize[cnt++] = sizeof(SThash_value);
; 184  : 	_stprintf(szBuf, _T("%s m_pHashData's size:%ul maxCount:%d, unitSize:%d\n"), pTitle, nSize[0], m_nMaxCount, nSize[1]);
; 185  : 	_tcscpy(pBuf, szBuf);
; 186  : 	for (i = 0; i < cnt; i++)
; 187  : 	{
; 188  : 		nSize[4] += nSize[i];
; 189  : 	}
; 190  : 	return nSize[4];
; 191  : 	*/
; 192  : 
; 193  : 	SThash_next *pNext;
; 194  : 	TCHAR szBuf[4096], szUnit[512];
; 195  : 	unsigned int i,j, nNextPos=0, nStrSize, nUseCount=0;

  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nNextPos$[rsp], 0
  0003b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR nUseCount$[rsp], 0

; 196  : 
; 197  : 	_stprintf(szUnit, _T("%s hashMap key distribution m_nMaxCount[%d]\n"), pTitle, m_nMaxCount);

  00043	48 8b 84 24 e0
	12 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0004b	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  0004e	4c 8b 84 24 e8
	12 00 00	 mov	 r8, QWORD PTR pTitle$[rsp]
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8588
  0005d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  00065	e8 00 00 00 00	 call	 sprintf

; 198  : 	nStrSize = (int)_tcslen(szUnit);

  0006a	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR szUnit$[rsp]
  00072	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv195[rsp], rax
  0007a	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR tv196[rsp], -1
$LL19@getString:
  00083	48 ff 44 24 38	 inc	 QWORD PTR tv196[rsp]
  00088	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv195[rsp]
  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv196[rsp]
  00095	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00099	75 e8		 jne	 SHORT $LL19@getString
  0009b	48 8b 44 24 38	 mov	 rax, QWORD PTR tv196[rsp]
  000a0	89 44 24 28	 mov	 DWORD PTR nStrSize$[rsp], eax

; 199  : 	_tcscpy(szBuf + nNextPos, szUnit);

  000a4	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR szUnit$[rsp]
  000ac	48 89 44 24 68	 mov	 QWORD PTR tv73[rsp], rax
  000b1	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]
  000b5	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR szBuf$[rsp+rax]
  000bd	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  000c7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
$LN14@getString:
  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR tv73[rsp]
  000d4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d7	88 44 24 24	 mov	 BYTE PTR tv78[rsp], al
  000db	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  000e0	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR tv78[rsp]
  000e5	88 08		 mov	 BYTE PTR [rax], cl
  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR tv73[rsp]
  000ec	48 ff c0	 inc	 rax
  000ef	48 89 44 24 68	 mov	 QWORD PTR tv73[rsp], rax
  000f4	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  000f9	48 ff c0	 inc	 rax
  000fc	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
  00101	80 7c 24 24 00	 cmp	 BYTE PTR tv78[rsp], 0
  00106	75 c7		 jne	 SHORT $LN14@getString

; 200  : 	nNextPos += nStrSize;

  00108	8b 44 24 28	 mov	 eax, DWORD PTR nStrSize$[rsp]
  0010c	8b 4c 24 20	 mov	 ecx, DWORD PTR nNextPos$[rsp]
  00110	03 c8		 add	 ecx, eax
  00112	8b c1		 mov	 eax, ecx
  00114	89 44 24 20	 mov	 DWORD PTR nNextPos$[rsp], eax

; 201  : 
; 202  : 	for (i = 0; i < m_nMaxCount; i++)

  00118	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00120	eb 0a		 jmp	 SHORT $LN4@getString
$LN2@getString:
  00122	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  00126	ff c0		 inc	 eax
  00128	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN4@getString:
  0012c	48 8b 84 24 e0
	12 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00134	8b 00		 mov	 eax, DWORD PTR [rax]
  00136	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  0013a	0f 83 4f 01 00
	00		 jae	 $LN3@getString

; 203  : 	{
; 204  : 		j = 0;

  00140	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 205  : 		for (pNext = m_pHashData[i].pNext; pNext != NULL; pNext = pNext->next) { j++; }

  00148	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  0014c	48 6b c0 10	 imul	 rax, rax, 16
  00150	48 8b 8c 24 e0
	12 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00158	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0015c	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00161	48 89 44 24 70	 mov	 QWORD PTR pNext$[rsp], rax
  00166	eb 0e		 jmp	 SHORT $LN7@getString
$LN5@getString:
  00168	48 8b 44 24 70	 mov	 rax, QWORD PTR pNext$[rsp]
  0016d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00171	48 89 44 24 70	 mov	 QWORD PTR pNext$[rsp], rax
$LN7@getString:
  00176	48 83 7c 24 70
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  0017c	74 0c		 je	 SHORT $LN6@getString
  0017e	8b 44 24 30	 mov	 eax, DWORD PTR j$[rsp]
  00182	ff c0		 inc	 eax
  00184	89 44 24 30	 mov	 DWORD PTR j$[rsp], eax
  00188	eb de		 jmp	 SHORT $LN5@getString
$LN6@getString:

; 206  : 		if (j) {

  0018a	83 7c 24 30 00	 cmp	 DWORD PTR j$[rsp], 0
  0018f	0f 84 f5 00 00
	00		 je	 $LN8@getString

; 207  : 			_stprintf(szUnit, _T(" --- m_pHashData[%d] useCount[%d]\n"), i, j);

  00195	44 8b 4c 24 30	 mov	 r9d, DWORD PTR j$[rsp]
  0019a	44 8b 44 24 2c	 mov	 r8d, DWORD PTR i$[rsp]
  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8590
  001a6	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  001ae	e8 00 00 00 00	 call	 sprintf

; 208  : 			nStrSize = (int)_tcslen(szUnit);

  001b3	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR szUnit$[rsp]
  001bb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv188[rsp], rax
  001c3	48 c7 44 24 48
	ff ff ff ff	 mov	 QWORD PTR tv189[rsp], -1
$LL18@getString:
  001cc	48 ff 44 24 48	 inc	 QWORD PTR tv189[rsp]
  001d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv188[rsp]
  001d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv189[rsp]
  001de	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  001e2	75 e8		 jne	 SHORT $LL18@getString
  001e4	48 8b 44 24 48	 mov	 rax, QWORD PTR tv189[rsp]
  001e9	89 44 24 28	 mov	 DWORD PTR nStrSize$[rsp], eax

; 209  : 			if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  001ed	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]
  001f1	8b 4c 24 28	 mov	 ecx, DWORD PTR nStrSize$[rsp]
  001f5	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  001f9	39 84 24 f8 12
	00 00		 cmp	 DWORD PTR nBufMax$[rsp], eax
  00200	73 0a		 jae	 SHORT $LN9@getString
  00202	e9 85 01 00 00	 jmp	 $LN10@getString
  00207	e9 80 01 00 00	 jmp	 $ENDPROC$21
$LN9@getString:

; 210  : 			_tcscpy(szBuf+nNextPos, szUnit);

  0020c	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR szUnit$[rsp]
  00214	48 89 44 24 78	 mov	 QWORD PTR tv138[rsp], rax
  00219	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]
  0021d	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR szBuf$[rsp+rax]
  00225	48 89 44 24 50	 mov	 QWORD PTR tv141[rsp], rax
  0022a	48 8b 44 24 50	 mov	 rax, QWORD PTR tv141[rsp]
  0022f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv142[rsp], rax
$LN15@getString:
  00237	48 8b 44 24 78	 mov	 rax, QWORD PTR tv138[rsp]
  0023c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023f	88 44 24 25	 mov	 BYTE PTR tv143[rsp], al
  00243	48 8b 44 24 50	 mov	 rax, QWORD PTR tv141[rsp]
  00248	0f b6 4c 24 25	 movzx	 ecx, BYTE PTR tv143[rsp]
  0024d	88 08		 mov	 BYTE PTR [rax], cl
  0024f	48 8b 44 24 78	 mov	 rax, QWORD PTR tv138[rsp]
  00254	48 ff c0	 inc	 rax
  00257	48 89 44 24 78	 mov	 QWORD PTR tv138[rsp], rax
  0025c	48 8b 44 24 50	 mov	 rax, QWORD PTR tv141[rsp]
  00261	48 ff c0	 inc	 rax
  00264	48 89 44 24 50	 mov	 QWORD PTR tv141[rsp], rax
  00269	80 7c 24 25 00	 cmp	 BYTE PTR tv143[rsp], 0
  0026e	75 c7		 jne	 SHORT $LN15@getString

; 211  : 			nNextPos += nStrSize;

  00270	8b 44 24 28	 mov	 eax, DWORD PTR nStrSize$[rsp]
  00274	8b 4c 24 20	 mov	 ecx, DWORD PTR nNextPos$[rsp]
  00278	03 c8		 add	 ecx, eax
  0027a	8b c1		 mov	 eax, ecx
  0027c	89 44 24 20	 mov	 DWORD PTR nNextPos$[rsp], eax

; 212  : 
; 213  : 			nUseCount++;

  00280	8b 44 24 34	 mov	 eax, DWORD PTR nUseCount$[rsp]
  00284	ff c0		 inc	 eax
  00286	89 44 24 34	 mov	 DWORD PTR nUseCount$[rsp], eax
$LN8@getString:

; 214  : 		}
; 215  : 	}

  0028a	e9 93 fe ff ff	 jmp	 $LN2@getString
$LN3@getString:

; 216  : 	_stprintf(szUnit, _T(" m_nMaxCount[%d] usedKeyCount[%d]\n"), m_nMaxCount, nUseCount);

  0028f	44 8b 4c 24 34	 mov	 r9d, DWORD PTR nUseCount$[rsp]
  00294	48 8b 84 24 e0
	12 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0029c	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8593
  002a6	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  002ae	e8 00 00 00 00	 call	 sprintf

; 217  : 	nStrSize = (int)_tcslen(szUnit);

  002b3	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR szUnit$[rsp]
  002bb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv181[rsp], rax
  002c3	48 c7 44 24 58
	ff ff ff ff	 mov	 QWORD PTR tv182[rsp], -1
$LL17@getString:
  002cc	48 ff 44 24 58	 inc	 QWORD PTR tv182[rsp]
  002d1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv181[rsp]
  002d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv182[rsp]
  002de	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  002e2	75 e8		 jne	 SHORT $LL17@getString
  002e4	48 8b 44 24 58	 mov	 rax, QWORD PTR tv182[rsp]
  002e9	89 44 24 28	 mov	 DWORD PTR nStrSize$[rsp], eax

; 218  : 	if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  002ed	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]
  002f1	8b 4c 24 28	 mov	 ecx, DWORD PTR nStrSize$[rsp]
  002f5	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  002f9	39 84 24 f8 12
	00 00		 cmp	 DWORD PTR nBufMax$[rsp], eax
  00300	73 0a		 jae	 SHORT $LN11@getString
  00302	e9 85 00 00 00	 jmp	 $LN12@getString
  00307	e9 80 00 00 00	 jmp	 $ENDPROC$21
$LN11@getString:

; 219  : 	_tcscpy(szBuf + nNextPos, szUnit);

  0030c	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR szUnit$[rsp]
  00314	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv161[rsp], rax
  0031c	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]
  00320	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR szBuf$[rsp+rax]
  00328	48 89 44 24 60	 mov	 QWORD PTR tv164[rsp], rax
  0032d	48 8b 44 24 60	 mov	 rax, QWORD PTR tv164[rsp]
  00332	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
$LN16@getString:
  0033a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv161[rsp]
  00342	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00345	88 44 24 26	 mov	 BYTE PTR tv166[rsp], al
  00349	48 8b 44 24 60	 mov	 rax, QWORD PTR tv164[rsp]
  0034e	0f b6 4c 24 26	 movzx	 ecx, BYTE PTR tv166[rsp]
  00353	88 08		 mov	 BYTE PTR [rax], cl
  00355	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv161[rsp]
  0035d	48 ff c0	 inc	 rax
  00360	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv161[rsp], rax
  00368	48 8b 44 24 60	 mov	 rax, QWORD PTR tv164[rsp]
  0036d	48 ff c0	 inc	 rax
  00370	48 89 44 24 60	 mov	 QWORD PTR tv164[rsp], rax
  00375	80 7c 24 26 00	 cmp	 BYTE PTR tv166[rsp], 0
  0037a	75 be		 jne	 SHORT $LN16@getString

; 220  : 	nNextPos += nStrSize;

  0037c	8b 44 24 28	 mov	 eax, DWORD PTR nStrSize$[rsp]
  00380	8b 4c 24 20	 mov	 ecx, DWORD PTR nNextPos$[rsp]
  00384	03 c8		 add	 ecx, eax
  00386	8b c1		 mov	 eax, ecx
  00388	89 44 24 20	 mov	 DWORD PTR nNextPos$[rsp], eax
$LN10@getString:
$LN12@getString:
$ENDPROC$21:

; 221  : 
; 222  : ENDPROC:
; 223  : 	_tcsncpy(pBuf, szBuf, nNextPos);

  0038c	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]
  00390	44 8b c0	 mov	 r8d, eax
  00393	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR szBuf$[rsp]
  0039b	48 8b 8c 24 f0
	12 00 00	 mov	 rcx, QWORD PTR pBuf$[rsp]
  003a3	e8 00 00 00 00	 call	 _tcsncpy

; 224  : 	pBuf[nNextPos] = 0;

  003a8	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]
  003ac	48 8b 8c 24 f0
	12 00 00	 mov	 rcx, QWORD PTR pBuf$[rsp]
  003b4	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 225  : 	return nNextPos;

  003b8	8b 44 24 20	 mov	 eax, DWORD PTR nNextPos$[rsp]

; 226  : }

  003bc	48 8b 8c 24 c0
	12 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c4	48 33 cc	 xor	 rcx, rsp
  003c7	e8 00 00 00 00	 call	 __security_check_cookie
  003cc	48 81 c4 d8 12
	00 00		 add	 rsp, 4824		; 000012d8H
  003d3	c3		 ret	 0
?getString@CHash@@QEAA_KPEAD0I@Z ENDP			; CHash::getString
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z
_TEXT	SEGMENT
nHashNo$ = 32
pNextAddr$ = 40
this$ = 64
pNext$ = 72
pKey$ = 80
pData$ = 88
?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z PROC ; CHash::uniqueAddNode, COMDAT

; 151  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 152  : 	SThash_next **pNextAddr;
; 153  : 
; 154  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  00018	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00022	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  00027	89 44 24 20	 mov	 DWORD PTR nHashNo$[rsp], eax

; 155  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00030	8b 00		 mov	 eax, DWORD PTR [rax]
  00032	39 44 24 20	 cmp	 DWORD PTR nHashNo$[rsp], eax
  00036	72 0a		 jb	 SHORT $LN5@uniqueAddN
  00038	b8 fd ff ff ff	 mov	 eax, -3
  0003d	e9 13 01 00 00	 jmp	 $LN1@uniqueAddN
$LN5@uniqueAddN:

; 156  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00042	48 83 7c 24 48
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00048	75 0a		 jne	 SHORT $LN6@uniqueAddN
  0004a	b8 fc ff ff ff	 mov	 eax, -4
  0004f	e9 01 01 00 00	 jmp	 $LN1@uniqueAddN
$LN6@uniqueAddN:

; 157  : 
; 158  : 
; 159  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) 

  00054	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00058	48 6b c0 10	 imul	 rax, rax, 16
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00061	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00065	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0006a	48 89 44 24 28	 mov	 QWORD PTR pNextAddr$[rsp], rax
  0006f	eb 11		 jmp	 SHORT $LN4@uniqueAddN
$LN2@uniqueAddN:
  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  00076	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00079	48 83 c0 10	 add	 rax, 16
  0007d	48 89 44 24 28	 mov	 QWORD PTR pNextAddr$[rsp], rax
$LN4@uniqueAddN:
  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  00087	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008b	74 22		 je	 SHORT $LN3@uniqueAddN

; 160  : 	{
; 161  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0) return eHASH_RESULT_DUPLICATE_KEYS;

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  00092	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  0009a	e8 00 00 00 00	 call	 _tcscmp
  0009f	85 c0		 test	 eax, eax
  000a1	75 0a		 jne	 SHORT $LN7@uniqueAddN
  000a3	b8 ff ff ff ff	 mov	 eax, -1
  000a8	e9 a8 00 00 00	 jmp	 $LN1@uniqueAddN
$LN7@uniqueAddN:

; 162  : 	}

  000ad	eb c2		 jmp	 SHORT $LN2@uniqueAddN
$LN3@uniqueAddN:

; 163  : 
; 164  : 	pNext->pNode.pKey = pKey;

  000af	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  000b9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 165  : 	pNext->pNode.value = pData;

  000bc	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pData$[rsp]
  000c6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 166  : 	pNext->next = NULL;

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000cf	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 167  : 	*pNextAddr = pNext;

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  000dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pNext$[rsp]
  000e1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 168  : 
; 169  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  000e4	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000e8	48 6b c0 10	 imul	 rax, rax, 16
  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000f1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000f5	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  000f9	75 18		 jne	 SHORT $LN8@uniqueAddN
  000fb	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000ff	48 6b c0 10	 imul	 rax, rax, 16
  00103	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00108	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0010c	8b 54 24 20	 mov	 edx, DWORD PTR nHashNo$[rsp]
  00110	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
$LN8@uniqueAddN:

; 170  : 	m_pHashData[nHashNo].nElementCnt++;

  00113	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00117	48 6b c0 10	 imul	 rax, rax, 16
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00120	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00124	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00128	ff c0		 inc	 eax
  0012a	8b 4c 24 20	 mov	 ecx, DWORD PTR nHashNo$[rsp]
  0012e	48 6b c9 10	 imul	 rcx, rcx, 16
  00132	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  00137	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0013b	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 171  : 	m_nElementCount++;

  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00144	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00147	ff c0		 inc	 eax
  00149	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0014e	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 172  : 	return nHashNo;

  00151	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
$LN1@uniqueAddN:

; 173  : }

  00155	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00159	c3		 ret	 0
?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ENDP ; CHash::uniqueAddNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z
_TEXT	SEGMENT
nHashNo$ = 32
pNextAddr$ = 40
this$ = 64
pNext$ = 72
pKey$ = 80
pData$ = 88
?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z PROC	; CHash::addNode, COMDAT

; 129  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 130  : 	SThash_next **pNextAddr;
; 131  : 
; 132  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  00018	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00022	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  00027	89 44 24 20	 mov	 DWORD PTR nHashNo$[rsp], eax

; 133  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00030	8b 00		 mov	 eax, DWORD PTR [rax]
  00032	39 44 24 20	 cmp	 DWORD PTR nHashNo$[rsp], eax
  00036	72 0a		 jb	 SHORT $LN5@addNode
  00038	b8 fd ff ff ff	 mov	 eax, -3
  0003d	e9 f3 00 00 00	 jmp	 $LN1@addNode
$LN5@addNode:

; 134  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00042	48 83 7c 24 48
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00048	75 0a		 jne	 SHORT $LN6@addNode
  0004a	b8 fc ff ff ff	 mov	 eax, -4
  0004f	e9 e1 00 00 00	 jmp	 $LN1@addNode
$LN6@addNode:

; 135  : 
; 136  : 	
; 137  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) {}

  00054	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00058	48 6b c0 10	 imul	 rax, rax, 16
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00061	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00065	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0006a	48 89 44 24 28	 mov	 QWORD PTR pNextAddr$[rsp], rax
  0006f	eb 11		 jmp	 SHORT $LN4@addNode
$LN2@addNode:
  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  00076	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00079	48 83 c0 10	 add	 rax, 16
  0007d	48 89 44 24 28	 mov	 QWORD PTR pNextAddr$[rsp], rax
$LN4@addNode:
  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  00087	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008b	74 02		 je	 SHORT $LN3@addNode
  0008d	eb e2		 jmp	 SHORT $LN2@addNode
$LN3@addNode:

; 138  : 	pNext->pNode.pKey = pKey;

  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  00099	48 89 08	 mov	 QWORD PTR [rax], rcx

; 139  : 	pNext->pNode.value = pData;

  0009c	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pData$[rsp]
  000a6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 140  : 	pNext->next = NULL;

  000aa	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000af	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 141  : 	*pNextAddr = pNext;

  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  000bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pNext$[rsp]
  000c1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  : 
; 143  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  000c4	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000c8	48 6b c0 10	 imul	 rax, rax, 16
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000d1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d5	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  000d9	75 18		 jne	 SHORT $LN7@addNode
  000db	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000df	48 6b c0 10	 imul	 rax, rax, 16
  000e3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e8	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ec	8b 54 24 20	 mov	 edx, DWORD PTR nHashNo$[rsp]
  000f0	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
$LN7@addNode:

; 144  : 	m_pHashData[nHashNo].nElementCnt++;

  000f3	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000f7	48 6b c0 10	 imul	 rax, rax, 16
  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00100	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00104	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00108	ff c0		 inc	 eax
  0010a	8b 4c 24 20	 mov	 ecx, DWORD PTR nHashNo$[rsp]
  0010e	48 6b c9 10	 imul	 rcx, rcx, 16
  00112	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  00117	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0011b	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 145  : 	m_nElementCount++;

  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00124	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00127	ff c0		 inc	 eax
  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0012e	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 146  : 	return nHashNo;

  00131	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
$LN1@addNode:

; 147  : }

  00135	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00139	c3		 ret	 0
?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ENDP	; CHash::addNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z
_TEXT	SEGMENT
pNext$ = 32
this$ = 64
nHashNo$ = 72
pKey$ = 80
pData$ = 88
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z PROC ; CHash::setValue, COMDAT

; 111  : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 112  : 	SThash_next *pNext;
; 113  : 
; 114  : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00017	8b 44 24 48	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0001b	48 6b c0 10	 imul	 rax, rax, 16
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00024	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00028	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0002d	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
  00032	eb 0e		 jmp	 SHORT $LN4@setValue
$LN2@setValue:
  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00039	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003d	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@setValue:
  00042	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00048	74 2a		 je	 SHORT $LN3@setValue

; 115  : 	{
; 116  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  0004f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00052	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  00057	e8 00 00 00 00	 call	 _tcscmp
  0005c	85 c0		 test	 eax, eax
  0005e	75 12		 jne	 SHORT $LN5@setValue

; 117  : 		{
; 118  : 			pNext->pNode.value = pData;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pData$[rsp]
  0006a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 119  : 			return eHASH_RESULT_SUCESS;

  0006e	33 c0		 xor	 eax, eax
  00070	eb 07		 jmp	 SHORT $LN1@setValue
$LN5@setValue:

; 120  : 		}
; 121  : 	}

  00072	eb c0		 jmp	 SHORT $LN2@setValue
$LN3@setValue:

; 122  : 	return eHASH_RESULT_NOT_FOUND;

  00074	b8 fe ff ff ff	 mov	 eax, -2
$LN1@setValue:

; 123  : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z ENDP ; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z
_TEXT	SEGMENT
pNode$ = 32
this$ = 64
pKey$ = 72
pData$ = 80
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z PROC ; CHash::setValue, COMDAT

; 101  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 102  : 	STHash_Node *pNode = hashLookup(pKey);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00022	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 103  : 	if (pNode) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  0002d	74 12		 je	 SHORT $LN2@setValue

; 104  : 		pNode->value = pData;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pData$[rsp]
  00039	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 105  : 		return eHASH_RESULT_SUCESS;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 05		 jmp	 SHORT $LN1@setValue
$LN2@setValue:

; 106  : 	}
; 107  : 	return eHASH_RESULT_NOT_FOUND;

  00041	b8 fe ff ff ff	 mov	 eax, -2
$LN1@setValue:

; 108  : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z ENDP ; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z
_TEXT	SEGMENT
nHashNo$ = 32
pNext$ = 40
this$ = 64
pStr$ = 72
prevNext$ = 80
?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z PROC ; CHash::getNode, COMDAT

; 86   : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 87   : 	SThash_next *pNext;
; 88   : 	HASH_TYPE nHashNo = getHashNo(pStr);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStr$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  00022	89 44 24 20	 mov	 DWORD PTR nHashNo$[rsp], eax

; 89   : 
; 90   : 	prevNext = &m_pHashData[nHashNo].pNext;

  00026	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0002a	48 6b c0 10	 imul	 rax, rax, 16
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00033	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00037	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0003c	48 89 44 24 50	 mov	 QWORD PTR prevNext$[rsp], rax

; 91   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00041	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00045	48 6b c0 10	 imul	 rax, rax, 16
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0004e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00052	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00057	48 89 44 24 28	 mov	 QWORD PTR pNext$[rsp], rax
  0005c	eb 0e		 jmp	 SHORT $LN4@getNode
$LN2@getNode:
  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext$[rsp]
  00063	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00067	48 89 44 24 28	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@getNode:
  0006c	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00072	74 2d		 je	 SHORT $LN3@getNode

; 92   : 	{
; 93   : 		if (_tcscmp(pStr, pNext->pNode.pKey) == 0) return pNext;

  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext$[rsp]
  00079	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0007c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pStr$[rsp]
  00081	e8 00 00 00 00	 call	 _tcscmp
  00086	85 c0		 test	 eax, eax
  00088	75 07		 jne	 SHORT $LN5@getNode
  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext$[rsp]
  0008f	eb 12		 jmp	 SHORT $LN1@getNode
$LN5@getNode:

; 94   : 		prevNext = &(pNext->next);

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext$[rsp]
  00096	48 83 c0 10	 add	 rax, 16
  0009a	48 89 44 24 50	 mov	 QWORD PTR prevNext$[rsp], rax

; 95   : 	}

  0009f	eb bd		 jmp	 SHORT $LN2@getNode
$LN3@getNode:

; 96   : 
; 97   : 	return NULL;

  000a1	33 c0		 xor	 eax, eax
$LN1@getNode:

; 98   : }

  000a3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a7	c3		 ret	 0
?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ENDP ; CHash::getNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z
_TEXT	SEGMENT
nHashNo$ = 32
this$ = 64
pStr$ = 72
?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z PROC	; CHash::getNext, COMDAT

; 80   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 81   : 	HASH_TYPE nHashNo = getHashNo(pStr);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStr$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  0001d	89 44 24 20	 mov	 DWORD PTR nHashNo$[rsp], eax

; 82   : 	return m_pHashData[nHashNo].pNext;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00025	48 6b c0 10	 imul	 rax, rax, 16
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00032	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]

; 83   : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z ENDP	; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getNext@CHash@@QEAAPEAUSThash_next@@I@Z
_TEXT	SEGMENT
this$ = 8
nHashKey$ = 16
?getNext@CHash@@QEAAPEAUSThash_next@@I@Z PROC		; CHash::getNext, COMDAT

; 72   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 73   : 	if (nHashKey >= m_nMaxCount) return NULL;

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	39 44 24 10	 cmp	 DWORD PTR nHashKey$[rsp], eax
  00014	72 04		 jb	 SHORT $LN2@getNext
  00016	33 c0		 xor	 eax, eax
  00018	eb 16		 jmp	 SHORT $LN1@getNext
$LN2@getNext:

; 74   : 
; 75   : 	return m_pHashData[nHashKey].pNext;

  0001a	8b 44 24 10	 mov	 eax, DWORD PTR nHashKey$[rsp]
  0001e	48 6b c0 10	 imul	 rax, rax, 16
  00022	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00027	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002b	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
$LN1@getNext:

; 76   : }

  00030	c3		 ret	 0
?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ENDP		; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z
_TEXT	SEGMENT
pNext$ = 32
this$ = 64
nHashNo$ = 72
pKey$ = 80
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z PROC	; CHash::hashLookup, COMDAT

; 59   : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 60   : 	SThash_next *pNext;
; 61   : 	if(nHashNo >= m_nMaxCount) return NULL;

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00017	8b 00		 mov	 eax, DWORD PTR [rax]
  00019	39 44 24 48	 cmp	 DWORD PTR nHashNo$[rsp], eax
  0001d	72 04		 jb	 SHORT $LN5@hashLookup
  0001f	33 c0		 xor	 eax, eax
  00021	eb 54		 jmp	 SHORT $LN1@hashLookup
$LN5@hashLookup:

; 62   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00023	8b 44 24 48	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00027	48 6b c0 10	 imul	 rax, rax, 16
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00030	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00034	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00039	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
  0003e	eb 0e		 jmp	 SHORT $LN4@hashLookup
$LN2@hashLookup:
  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@hashLookup:
  0004e	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00054	74 1f		 je	 SHORT $LN3@hashLookup

; 63   : 	{
; 64   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  0005b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  00063	e8 00 00 00 00	 call	 _tcscmp
  00068	85 c0		 test	 eax, eax
  0006a	75 07		 jne	 SHORT $LN6@hashLookup

; 65   : 			return &pNext->pNode;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00071	eb 04		 jmp	 SHORT $LN1@hashLookup
$LN6@hashLookup:

; 66   : 	}

  00073	eb cb		 jmp	 SHORT $LN2@hashLookup
$LN3@hashLookup:

; 67   : 
; 68   : 	return NULL;

  00075	33 c0		 xor	 eax, eax
$LN1@hashLookup:

; 69   : 
; 70   : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z
_TEXT	SEGMENT
nHashNo$ = 32
pNext$ = 40
this$ = 64
pKey$ = 72
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z PROC	; CHash::hashLookup, COMDAT

; 43   : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 44   : 	SThash_next *pNext;
; 45   : 	HASH_TYPE nHashNo = getHashNo(pKey);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  0001d	89 44 24 20	 mov	 DWORD PTR nHashNo$[rsp], eax

; 46   : 	if(nHashNo >= m_nMaxCount) return NULL;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00026	8b 00		 mov	 eax, DWORD PTR [rax]
  00028	39 44 24 20	 cmp	 DWORD PTR nHashNo$[rsp], eax
  0002c	72 04		 jb	 SHORT $LN5@hashLookup
  0002e	33 c0		 xor	 eax, eax
  00030	eb 54		 jmp	 SHORT $LN1@hashLookup
$LN5@hashLookup:

; 47   : 
; 48   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00032	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00036	48 6b c0 10	 imul	 rax, rax, 16
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00043	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00048	48 89 44 24 28	 mov	 QWORD PTR pNext$[rsp], rax
  0004d	eb 0e		 jmp	 SHORT $LN4@hashLookup
$LN2@hashLookup:
  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext$[rsp]
  00054	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00058	48 89 44 24 28	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@hashLookup:
  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00063	74 1f		 je	 SHORT $LN3@hashLookup

; 49   : 	{
; 50   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext$[rsp]
  0006a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pKey$[rsp]
  00072	e8 00 00 00 00	 call	 _tcscmp
  00077	85 c0		 test	 eax, eax
  00079	75 07		 jne	 SHORT $LN6@hashLookup

; 51   : 			return &pNext->pNode;

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext$[rsp]
  00080	eb 04		 jmp	 SHORT $LN1@hashLookup
$LN6@hashLookup:

; 52   : 	}

  00082	eb cb		 jmp	 SHORT $LN2@hashLookup
$LN3@hashLookup:

; 53   : 
; 54   : 	return NULL;

  00084	33 c0		 xor	 eax, eax
$LN1@hashLookup:

; 55   : 
; 56   : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getHashNo@CHash@@QEAAIPEAD@Z
_TEXT	SEGMENT
key$ = 0
i$ = 4
nLen$ = 8
tv83 = 16
tv82 = 24
this$ = 48
pStr$ = 56
?getHashNo@CHash@@QEAAIPEAD@Z PROC			; CHash::getHashNo, COMDAT

; 31   : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR pStr$[rsp]
  00013	48 89 44 24 18	 mov	 QWORD PTR tv82[rsp], rax
  00018	48 c7 44 24 10
	ff ff ff ff	 mov	 QWORD PTR tv83[rsp], -1
$LL6@getHashNo:
  00021	48 ff 44 24 10	 inc	 QWORD PTR tv83[rsp]
  00026	48 8b 44 24 18	 mov	 rax, QWORD PTR tv82[rsp]
  0002b	48 8b 4c 24 10	 mov	 rcx, QWORD PTR tv83[rsp]
  00030	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00034	75 eb		 jne	 SHORT $LL6@getHashNo
  00036	48 8b 44 24 10	 mov	 rax, QWORD PTR tv83[rsp]
  0003b	89 44 24 08	 mov	 DWORD PTR nLen$[rsp], eax

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;

  0003f	8b 44 24 08	 mov	 eax, DWORD PTR nLen$[rsp]
  00043	89 04 24	 mov	 DWORD PTR key$[rsp], eax

; 35   : 	for(i=0; i < nLen; i++) {

  00046	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004e	eb 0a		 jmp	 SHORT $LN4@getHashNo
$LN2@getHashNo:
  00050	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00054	ff c0		 inc	 eax
  00056	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@getHashNo:
  0005a	8b 44 24 08	 mov	 eax, DWORD PTR nLen$[rsp]
  0005e	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  00062	73 1f		 jae	 SHORT $LN3@getHashNo

; 36   : 		key += (key << 4) + (int)pStr[i];

  00064	8b 04 24	 mov	 eax, DWORD PTR key$[rsp]
  00067	c1 e0 04	 shl	 eax, 4
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR i$[rsp]
  0006e	48 8b 54 24 38	 mov	 rdx, QWORD PTR pStr$[rsp]
  00073	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00077	03 0c 24	 add	 ecx, DWORD PTR key$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	89 04 24	 mov	 DWORD PTR key$[rsp], eax

; 37   : 	}

  00081	eb cd		 jmp	 SHORT $LN2@getHashNo
$LN3@getHashNo:

; 38   : 	key = key % m_nMaxCount;

  00083	33 d2		 xor	 edx, edx
  00085	8b 04 24	 mov	 eax, DWORD PTR key$[rsp]
  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0008d	f7 31		 div	 DWORD PTR [rcx]
  0008f	8b c2		 mov	 eax, edx
  00091	89 04 24	 mov	 DWORD PTR key$[rsp], eax

; 39   : 	return key;

  00094	8b 04 24	 mov	 eax, DWORD PTR key$[rsp]

; 40   : }

  00097	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009b	c3		 ret	 0
?getHashNo@CHash@@QEAAIPEAD@Z ENDP			; CHash::getHashNo
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?clear@CHash@@QEAAXXZ
_TEXT	SEGMENT
this$ = 16
?clear@CHash@@QEAAXXZ PROC				; CHash::clear, COMDAT

; 26   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 27   : 	memset(m_pHashData, 0, sizeof(m_pHashData));

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000b	48 8b 78 08	 mov	 rdi, QWORD PTR [rax+8]
  0000f	33 c0		 xor	 eax, eax
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	f3 aa		 rep stosb

; 28   : }

  00018	5f		 pop	 rdi
  00019	c3		 ret	 0
?clear@CHash@@QEAAXXZ ENDP				; CHash::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ??1CHash@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CHash@@QEAA@XZ PROC					; CHash::~CHash, COMDAT

; 18   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 19   : 	if(m_pHashData) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00013	74 1c		 je	 SHORT $LN2@CHash

; 20   : 		free(m_pHashData);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 21   : 		m_pHashData = NULL;

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN2@CHash:

; 22   : 	}
; 23   : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
??1CHash@@QEAA@XZ ENDP					; CHash::~CHash
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ??0CHash@@QEAA@I@Z
_TEXT	SEGMENT
this$ = 48
max$ = 56
??0CHash@@QEAA@I@Z PROC					; CHash::CHash, COMDAT

; 10   : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 11   : 	// TODO m_nMaxCount 를 2의 제곱으로 조정한다.
; 12   : 	m_nMaxCount = max;

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 4c 24 38	 mov	 ecx, DWORD PTR max$[rsp]
  00016	89 08		 mov	 DWORD PTR [rax], ecx

; 13   : 	m_nElementCount = 0;

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 14   : 	m_pHashData = (SThash_value *)calloc(m_nMaxCount, sizeof(SThash_value));

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	8b 00		 mov	 eax, DWORD PTR [rax]
  0002b	ba 10 00 00 00	 mov	 edx, 16
  00030	8b c8		 mov	 ecx, eax
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0003d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 15   : }

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
??0CHash@@QEAA@I@Z ENDP					; CHash::CHash
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT _tcscmp
_TEXT	SEGMENT
_s1$ = 48
_s2$ = 56
_tcscmp	PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _s2$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _s1$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mbscmp
  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
_tcscmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT _tcsncpy
_TEXT	SEGMENT
_Dst$ = 48
_Source$ = 56
_Count$ = 64
_tcsncpy PROC						; COMDAT

; 1542 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00013	4c 8b 44 24 40	 mov	 r8, QWORD PTR _Count$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Source$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Dst$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mbsnbcpy

; 1546 : #pragma warning(pop)
; 1547 : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
_tcsncpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
__$ArrayPad$ = 48
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00027	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0002c	48 8d 44 24 60	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00031	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00036	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003b	45 33 c0	 xor	 r8d, r8d
  0003e	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Format$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00048	e8 00 00 00 00	 call	 _vsprintf_l
  0004d	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00051	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0005a	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00063	48 33 cc	 xor	 rcx, rsp
  00066	e8 00 00 00 00	 call	 __security_check_cookie
  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
