; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG44505 DB	'[%p] calloc has Failed', 0aH, 00H
	ORG $+8
$SG44508 DB	'[%p] ################### realloc success m_nLast[%d] m_n'
	DB	'Max[%d] nMaxCount[%d]', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	??1abstract_critical_section@common@@UEAA@XZ	; common::abstract_critical_section::~abstract_critical_section
PUBLIC	??0abstract_critical_section@common@@QEAA@XZ	; common::abstract_critical_section::abstract_critical_section
PUBLIC	??_Gabstract_critical_section@common@@UEAAPEAXI@Z ; common::abstract_critical_section::`scalar deleting destructor'
PUBLIC	??0critical_section@win32@common@@QEAA@XZ	; common::win32::critical_section::critical_section
PUBLIC	??1critical_section@win32@common@@UEAA@XZ	; common::win32::critical_section::~critical_section
PUBLIC	?enter@critical_section@win32@common@@UEAA_N_N@Z ; common::win32::critical_section::enter
PUBLIC	?leave@critical_section@win32@common@@UEAAXXZ	; common::win32::critical_section::leave
PUBLIC	??_Gcritical_section@win32@common@@UEAAPEAXI@Z	; common::win32::critical_section::`scalar deleting destructor'
PUBLIC	??0win_atomic@win32@common@@QEAA@XZ		; common::win32::win_atomic::win_atomic
PUBLIC	??1win_atomic@win32@common@@QEAA@XZ		; common::win32::win_atomic::~win_atomic
PUBLIC	??0win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::win64_atomic
PUBLIC	??1win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::~win64_atomic
PUBLIC	?getCount@win64_atomic@win32@common@@QEAAHXZ	; common::win32::win64_atomic::getCount
PUBLIC	?init@win64_atomic@win32@common@@QEAAXXZ	; common::win32::win64_atomic::init
PUBLIC	?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
PUBLIC	?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z		; ISABLETODELETE
PUBLIC	??0CQueueS@@QEAA@XZ				; CQueueS::CQueueS
PUBLIC	??1CQueueS@@QEAA@XZ				; CQueueS::~CQueueS
PUBLIC	?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z	; CQueueS::alloc
PUBLIC	?realloc@CQueueS@@QEAA_NH_N@Z			; CQueueS::realloc
PUBLIC	?push@CQueueS@@QEAA_NPEAX@Z			; CQueueS::push
PUBLIC	?pop@CQueueS@@QEAAPEAXXZ			; CQueueS::pop
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?delBuf@CMemManager@@QEAAXPEADH@Z		; CMemManager::delBuf
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7abstract_critical_section@common@@6B@	; common::abstract_critical_section::`vftable'
PUBLIC	??_7critical_section@win32@common@@6B@		; common::win32::critical_section::`vftable'
PUBLIC	??_R4abstract_critical_section@common@@6B@	; common::abstract_critical_section::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVabstract_critical_section@common@@@8	; common::abstract_critical_section `RTTI Type Descriptor'
PUBLIC	??_R3abstract_critical_section@common@@8	; common::abstract_critical_section::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2abstract_critical_section@common@@8	; common::abstract_critical_section::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@abstract_critical_section@common@@8 ; common::abstract_critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4critical_section@win32@common@@6B@		; common::win32::critical_section::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcritical_section@win32@common@@@8	; common::win32::critical_section `RTTI Type Descriptor'
PUBLIC	??_R3critical_section@win32@common@@8		; common::win32::critical_section::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2critical_section@win32@common@@8		; common::win32::critical_section::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@critical_section@win32@common@@8	; common::win32::critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	_purecall:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_TryEnterCriticalSection:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	??_Eabstract_critical_section@common@@UEAAPEAXI@Z:PROC ; common::abstract_critical_section::`vector deleting destructor'
EXTRN	??_Ecritical_section@win32@common@@UEAAPEAXI@Z:PROC ; common::win32::critical_section::`vector deleting destructor'
EXTRN	initSpinLock:PROC
EXTRN	acquireSpinLock:PROC
EXTRN	releaseSpinLock:PROC
EXTRN	?delBufByIndex@CMemManager@@QEAAXPEADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PEAVCMemManager@@EA:QWORD		; gs_pMMgr
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gabstract_critical_section@common@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gabstract_critical_section@common@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0critical_section@win32@common@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??0critical_section@win32@common@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1critical_section@win32@common@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??1critical_section@win32@common@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?enter@critical_section@win32@common@@UEAA_N_N@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?enter@critical_section@win32@common@@UEAA_N_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?leave@critical_section@win32@common@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?leave@critical_section@win32@common@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gcritical_section@win32@common@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gcritical_section@win32@common@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CQueueS@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+214
	DD	imagerel $unwind$??0CQueueS@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CQueueS@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+535
	DD	imagerel $unwind$??1CQueueS@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?realloc@CQueueS@@QEAA_NH_N@Z DD imagerel $LN7
	DD	imagerel $LN7+550
	DD	imagerel $unwind$?realloc@CQueueS@@QEAA_NH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push@CQueueS@@QEAA_NPEAX@Z DD imagerel $LN10
	DD	imagerel $LN10+427
	DD	imagerel $unwind$?push@CQueueS@@QEAA_NPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop@CQueueS@@QEAAPEAXXZ DD imagerel $LN10
	DD	imagerel $LN10+297
	DD	imagerel $unwind$?pop@CQueueS@@QEAAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getIndex@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$?getIndex@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBuf@CMemManager@@QEAAXPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?delBuf@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT ??_R1A@?0A@EA@critical_section@win32@common@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@critical_section@win32@common@@8 DD imagerel ??_R0?AVcritical_section@win32@common@@@8 ; common::win32::critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3critical_section@win32@common@@8
rdata$r	ENDS
;	COMDAT ??_R2critical_section@win32@common@@8
rdata$r	SEGMENT
??_R2critical_section@win32@common@@8 DD imagerel ??_R1A@?0A@EA@critical_section@win32@common@@8 ; common::win32::critical_section::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@abstract_critical_section@common@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3critical_section@win32@common@@8
rdata$r	SEGMENT
??_R3critical_section@win32@common@@8 DD 00H		; common::win32::critical_section::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2critical_section@win32@common@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcritical_section@win32@common@@@8
data$r	SEGMENT
??_R0?AVcritical_section@win32@common@@@8 DQ FLAT:??_7type_info@@6B@ ; common::win32::critical_section `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVcritical_section@win32@common@@', 00H
data$r	ENDS
;	COMDAT ??_R4critical_section@win32@common@@6B@
rdata$r	SEGMENT
??_R4critical_section@win32@common@@6B@ DD 01H		; common::win32::critical_section::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVcritical_section@win32@common@@@8
	DD	imagerel ??_R3critical_section@win32@common@@8
	DD	imagerel ??_R4critical_section@win32@common@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@abstract_critical_section@common@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@abstract_critical_section@common@@8 DD imagerel ??_R0?AVabstract_critical_section@common@@@8 ; common::abstract_critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3abstract_critical_section@common@@8
rdata$r	ENDS
;	COMDAT ??_R2abstract_critical_section@common@@8
rdata$r	SEGMENT
??_R2abstract_critical_section@common@@8 DD imagerel ??_R1A@?0A@EA@abstract_critical_section@common@@8 ; common::abstract_critical_section::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3abstract_critical_section@common@@8
rdata$r	SEGMENT
??_R3abstract_critical_section@common@@8 DD 00H		; common::abstract_critical_section::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2abstract_critical_section@common@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVabstract_critical_section@common@@@8
data$r	SEGMENT
??_R0?AVabstract_critical_section@common@@@8 DQ FLAT:??_7type_info@@6B@ ; common::abstract_critical_section `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVabstract_critical_section@common@@', 00H
data$r	ENDS
;	COMDAT ??_R4abstract_critical_section@common@@6B@
rdata$r	SEGMENT
??_R4abstract_critical_section@common@@6B@ DD 01H	; common::abstract_critical_section::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVabstract_critical_section@common@@@8
	DD	imagerel ??_R3abstract_critical_section@common@@8
	DD	imagerel ??_R4abstract_critical_section@common@@6B@
rdata$r	ENDS
;	COMDAT ??_7critical_section@win32@common@@6B@
CONST	SEGMENT
??_7critical_section@win32@common@@6B@ DQ FLAT:??_R4critical_section@win32@common@@6B@ ; common::win32::critical_section::`vftable'
	DQ	FLAT:??_Ecritical_section@win32@common@@UEAAPEAXI@Z
	DQ	FLAT:?enter@critical_section@win32@common@@UEAA_N_N@Z
	DQ	FLAT:?leave@critical_section@win32@common@@UEAAXXZ
CONST	ENDS
;	COMDAT ??_7abstract_critical_section@common@@6B@
CONST	SEGMENT
??_7abstract_critical_section@common@@6B@ DQ FLAT:??_R4abstract_critical_section@common@@6B@ ; common::abstract_critical_section::`vftable'
	DQ	FLAT:??_Eabstract_critical_section@common@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBuf@CMemManager@@QEAAXPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getIndex@@YAHH@Z DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop@CQueueS@@QEAAPEAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push@CQueueS@@QEAA_NPEAX@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?realloc@CQueueS@@QEAA_NH_N@Z DD 031401H
	DD	07010c214H
	DD	0600fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CQueueS@@QEAA@XZ DD imagerel ??1CQueueS@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CQueueS@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CQueueS@@QEAA@XZ
	DD	060H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CQueueS@@QEAA@XZ DD 011219H
	DD	0e209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CQueueS@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0CQueueS@@QEAA@XZ DD imagerel ??0CQueueS@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0CQueueS@@QEAA@XZ+37
	DD	00H
	DD	imagerel ??0CQueueS@@QEAA@XZ+55
	DD	01H
	DD	imagerel ??0CQueueS@@QEAA@XZ+73
	DD	02H
	DD	imagerel ??0CQueueS@@QEAA@XZ+203
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0CQueueS@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0CQueueS@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0CQueueS@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0CQueueS@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CQueueS@@QEAA@XZ DD 021311H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0CQueueS@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gcritical_section@win32@common@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?leave@critical_section@win32@common@@UEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?enter@critical_section@win32@common@@UEAA_N_N@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1critical_section@win32@common@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0critical_section@win32@common@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gabstract_critical_section@common@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
pBuf$ = 72
nSize$ = 80
?delBuf@CMemManager@@QEAAXPEADH@Z PROC			; CMemManager::delBuf, COMDAT

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR nSize$[rsp]
  00017	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0001c	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00020	44 8b 44 24 20	 mov	 r8d, DWORD PTR nIdx$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?delBuf@CMemManager@@QEAAXPEADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = 0
m$ = 4
tv80 = 8
$S1$ = 16
s$ = 48
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	f2 0f 2a 44 24
	30		 cvtsi2sd xmm0, DWORD PTR s$[rsp]
  0000e	f2 0f 11 44 24
	10		 movsd	 QWORD PTR $S1$[rsp], xmm0
  00014	b8 04 00 00 00	 mov	 eax, 4
  00019	48 6b c0 01	 imul	 rax, rax, 1
  0001d	8b 44 04 10	 mov	 eax, DWORD PTR $S1$[rsp+rax]
  00021	c1 f8 14	 sar	 eax, 20
  00024	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  00029	89 44 24 04	 mov	 DWORD PTR m$[rsp], eax
  0002d	8b 44 24 04	 mov	 eax, DWORD PTR m$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	89 4c 24 08	 mov	 DWORD PTR tv80[rsp], ecx
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR tv80[rsp]
  00041	d3 e0		 shl	 eax, cl
  00043	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  0004f	23 c8		 and	 ecx, eax
  00051	8b c1		 mov	 eax, ecx
  00053	85 c0		 test	 eax, eax
  00055	74 09		 je	 SHORT $LN3@getIndex
  00057	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  0005e	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN4@getIndex:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR m$[rsp]
  0006e	03 c8		 add	 ecx, eax
  00070	8b c1		 mov	 eax, ecx
  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comqueue.cpp
;	COMDAT ?pop@CQueueS@@QEAAPEAXXZ
_TEXT	SEGMENT
res$ = 32
this$ = 64
?pop@CQueueS@@QEAAPEAXXZ PROC				; CQueueS::pop, COMDAT

; 129  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 130  : 	void* res;
; 131  : 	SPIN_LOCK_ENTER(&m_cLockPop);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 50	 add	 rax, 80			; 00000050H
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 acquireSpinLock

; 132  : 	res = m_pArray[m_nFront];

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00028	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0002f	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 133  : 	if (res) {

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR res$[rsp], 0
  0003a	74 76		 je	 SHORT $LN2@pop

; 134  : 		m_pArray[m_nFront] = 0;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004d	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 135  : 		//printf("[%p] m_nFront[%d] nMax[%d]\n", m_pArray, m_nFront, nMax);
; 136  : 		m_nFront++;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0005a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0005d	ff c0		 inc	 eax
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00064	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 137  : 		if (m_nOldMax) {

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006c	83 78 54 00	 cmp	 DWORD PTR [rax+84], 0
  00070	74 20		 je	 SHORT $LN4@pop

; 138  : 			if(m_nFront == m_nOldMax) m_nFront = 0;

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	8b 49 54	 mov	 ecx, DWORD PTR [rcx+84]
  0007f	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  00082	75 0c		 jne	 SHORT $LN6@pop
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00089	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
$LN6@pop:

; 139  : 		}

  00090	eb 1e		 jmp	 SHORT $LN5@pop
$LN4@pop:

; 140  : 		else if (m_nFront == m_nMax) m_nFront = 0;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0009c	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0009f	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  000a2	75 0c		 jne	 SHORT $LN7@pop
  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a9	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
$LN7@pop:
$LN5@pop:

; 141  : 	}

  000b0	eb 5c		 jmp	 SHORT $LN3@pop
$LN2@pop:

; 142  : 	else if (m_nOldMax) {

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000b7	83 78 54 00	 cmp	 DWORD PTR [rax+84], 0
  000bb	74 51		 je	 SHORT $LN8@pop

; 143  : 		//nTmp = m_nFront; nTmp2 = m_nOldMax;
; 144  : 		res = m_pArray[m_nOldMax]; 

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c2	48 63 40 54	 movsxd	 rax, DWORD PTR [rax+84]
  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000cb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ce	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000d2	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 145  : 		m_pArray[m_nOldMax] = 0;

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000dc	48 63 40 54	 movsxd	 rax, DWORD PTR [rax+84]
  000e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e8	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 146  : 		//printf("[%p] m_nFront[%d] m_nOldMax[%d]\n", m_pArray, m_nFront, m_nOldMax);
; 147  : 		m_nFront = m_nOldMax+1;

  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000f5	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  000f8	ff c0		 inc	 eax
  000fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000ff	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 148  : 		m_nOldMax = 0;

  00102	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00107	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0
$LN8@pop:
$LN3@pop:

; 149  : 	}
; 150  : 	SPIN_LOCK_LEAVE(&m_cLockPop);

  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00113	48 83 c0 50	 add	 rax, 80			; 00000050H
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 releaseSpinLock

; 151  : 	//if (0 <= nTmp) {
; 152  : 	//	gs_cLogger.DebugLog(LEVEL_INFO, "m_nFront[%d] m_nOldMax[%d]", nTmp, nTmp2);
; 153  : 	//}
; 154  : 	return res;

  0011f	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]

; 155  : }

  00124	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00128	c3		 ret	 0
?pop@CQueueS@@QEAAPEAXXZ ENDP				; CQueueS::pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comqueue.cpp
;	COMDAT ?push@CQueueS@@QEAA_NPEAX@Z
_TEXT	SEGMENT
tv195 = 32
tv194 = 40
tv192 = 48
tv191 = 56
tv190 = 64
this$ = 96
pData$ = 104
?push@CQueueS@@QEAA_NPEAX@Z PROC			; CQueueS::push, COMDAT

; 94   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   : 	if (m_nRealloc.getCount()) {

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 83 c0 58	 add	 rax, 88			; 00000058H
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  0001f	85 c0		 test	 eax, eax
  00021	74 4b		 je	 SHORT $LN2@push

; 96   : 		m_CS.enter();

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 83 c0 20	 add	 rax, 32			; 00000020H
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00031	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00035	48 89 4c 24 20	 mov	 QWORD PTR tv195[rsp], rcx
  0003a	b2 01		 mov	 dl, 1
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR tv195[rsp]
  00044	ff 50 08	 call	 QWORD PTR [rax+8]

; 97   : 		m_CS.leave();

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0004c	48 83 c0 20	 add	 rax, 32			; 00000020H
  00050	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00055	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00059	48 89 4c 24 28	 mov	 QWORD PTR tv194[rsp], rcx
  0005e	48 8b c8	 mov	 rcx, rax
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR tv194[rsp]
  00066	ff 50 10	 call	 QWORD PTR [rax+16]
  00069	e9 ca 00 00 00	 jmp	 $LN3@push
$LN2@push:

; 98   : 	}
; 99   : 	else if(m_pArray[m_nLast]) {

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00073	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00077	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007f	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00084	0f 84 ae 00 00
	00		 je	 $LN4@push

; 100  : 		if (m_nRealloc.atomic_compare_exchange(1, 0)) {

  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0008f	48 83 c0 58	 add	 rax, 88			; 00000058H
  00093	45 33 c0	 xor	 r8d, r8d
  00096	ba 01 00 00 00	 mov	 edx, 1
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
  000a3	48 85 c0	 test	 rax, rax
  000a6	74 48		 je	 SHORT $LN5@push

; 101  : 			m_CS.enter();

  000a8	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000ad	48 83 c0 20	 add	 rax, 32			; 00000020H
  000b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000b6	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ba	48 89 4c 24 30	 mov	 QWORD PTR tv192[rsp], rcx
  000bf	b2 01		 mov	 dl, 1
  000c1	48 8b c8	 mov	 rcx, rax
  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv192[rsp]
  000c9	ff 50 08	 call	 QWORD PTR [rax+8]

; 102  : 			m_CS.leave();

  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000d1	48 83 c0 20	 add	 rax, 32			; 00000020H
  000d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000da	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000de	48 89 4c 24 38	 mov	 QWORD PTR tv191[rsp], rcx
  000e3	48 8b c8	 mov	 rcx, rax
  000e6	48 8b 44 24 38	 mov	 rax, QWORD PTR tv191[rsp]
  000eb	ff 50 10	 call	 QWORD PTR [rax+16]

; 103  : 		}
; 104  : 		else {

  000ee	eb 48		 jmp	 SHORT $LN6@push
$LN5@push:

; 105  : 			m_CS.enter();

  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000f5	48 83 c0 20	 add	 rax, 32			; 00000020H
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000fe	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00102	48 89 4c 24 40	 mov	 QWORD PTR tv190[rsp], rcx
  00107	b2 01		 mov	 dl, 1
  00109	48 8b c8	 mov	 rcx, rax
  0010c	48 8b 44 24 40	 mov	 rax, QWORD PTR tv190[rsp]
  00111	ff 50 08	 call	 QWORD PTR [rax+8]

; 106  : 			if (!realloc(m_nMax << 1)) {

  00114	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00119	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0011c	d1 e0		 shl	 eax, 1
  0011e	45 33 c0	 xor	 r8d, r8d
  00121	8b d0		 mov	 edx, eax
  00123	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00128	e8 00 00 00 00	 call	 ?realloc@CQueueS@@QEAA_NH_N@Z ; CQueueS::realloc
  0012d	0f b6 c0	 movzx	 eax, al
  00130	85 c0		 test	 eax, eax
  00132	75 04		 jne	 SHORT $LN7@push

; 107  : 				return false;

  00134	32 c0		 xor	 al, al
  00136	eb 6e		 jmp	 SHORT $LN1@push
$LN7@push:
$LN6@push:
$LN4@push:
$LN3@push:

; 108  : 			}
; 109  : 		}
; 110  : 	}
; 111  : 
; 112  : 	SPIN_LOCK_ENTER(&m_cLockPush);

  00138	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0013d	48 83 c0 18	 add	 rax, 24
  00141	48 8b c8	 mov	 rcx, rax
  00144	e8 00 00 00 00	 call	 acquireSpinLock

; 113  : 	//if (m_pArray[m_nLast]) {
; 114  : 	//	//nTmp = m_nLast; nTmp2 = m_nMax;
; 115  : 	//	printf("[%p] Already data Set! m_nLast[%d] nMax[%d]\n", m_pArray, m_nLast, m_nMax);
; 116  : 	//}
; 117  : 	m_pArray[m_nLast] = pData;

  00149	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0014e	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00152	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00157	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0015a	48 8b 54 24 68	 mov	 rdx, QWORD PTR pData$[rsp]
  0015f	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 118  : 	m_nLast++;

  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00168	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0016b	ff c0		 inc	 eax
  0016d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00172	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 119  : 	if (m_nLast == m_nMax) m_nLast = 0;

  00175	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0017a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0017f	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00182	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00185	75 0c		 jne	 SHORT $LN8@push
  00187	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0018c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN8@push:

; 120  : 	//printf("[%p] m_nLast[%d] nMax[%d]\n", m_pArray, nTmp, m_nMax);
; 121  : 	SPIN_LOCK_LEAVE(&m_cLockPush);

  00193	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00198	48 83 c0 18	 add	 rax, 24
  0019c	48 8b c8	 mov	 rcx, rax
  0019f	e8 00 00 00 00	 call	 releaseSpinLock

; 122  : 	//if (0 <= nTmp) {
; 123  : 	//	gs_cLogger.DebugLog(LEVEL_ERROR, "Already data Set! m_nLast[%d] nMax[%d]", nTmp, nTmp2);
; 124  : 	//}
; 125  : 	return true;

  001a4	b0 01		 mov	 al, 1
$LN1@push:

; 126  : }

  001a6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001aa	c3		 ret	 0
?push@CQueueS@@QEAA_NPEAX@Z ENDP			; CQueueS::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comqueue.cpp
;	COMDAT ?realloc@CQueueS@@QEAA_NH_N@Z
_TEXT	SEGMENT
newPtr$ = 48
oldPtr$ = 56
tv171 = 64
tv94 = 72
tv170 = 80
this$ = 128
nMaxCount$ = 136
bInit$ = 144
?realloc@CQueueS@@QEAA_NH_N@Z PROC			; CQueueS::realloc, COMDAT

; 63   : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 64   : 	void** newPtr, **oldPtr = m_pArray;

  00014	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0001c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001f	48 89 44 24 38	 mov	 QWORD PTR oldPtr$[rsp], rax

; 65   : 	newPtr = (void **)calloc(nMaxCount, sizeof(void*));

  00024	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0002c	ba 08 00 00 00	 mov	 edx, 8
  00031	48 8b c8	 mov	 rcx, rax
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0003a	48 89 44 24 30	 mov	 QWORD PTR newPtr$[rsp], rax

; 66   : 	if (!newPtr) {

  0003f	48 83 7c 24 30
	00		 cmp	 QWORD PTR newPtr$[rsp], 0
  00045	75 5a		 jne	 SHORT $LN2@realloc

; 67   : 		printf("[%p] calloc has Failed\n", m_pArray);

  00047	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0004f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG44505
  00059	e8 00 00 00 00	 call	 printf

; 68   : 		m_nRealloc.init();

  0005e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 83 c0 58	 add	 rax, 88			; 00000058H
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 69   : 		m_CS.leave();

  00072	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0007a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0007e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00086	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0008a	48 89 4c 24 40	 mov	 QWORD PTR tv171[rsp], rcx
  0008f	48 8b c8	 mov	 rcx, rax
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR tv171[rsp]
  00097	ff 50 10	 call	 QWORD PTR [rax+16]

; 70   : 		return false;

  0009a	32 c0		 xor	 al, al
  0009c	e9 7e 01 00 00	 jmp	 $LN1@realloc
$LN2@realloc:

; 71   : 	}
; 72   : 	if (bInit) {

  000a1	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR bInit$[rsp]
  000a9	85 c0		 test	 eax, eax
  000ab	74 4c		 je	 SHORT $LN3@realloc

; 73   : 		m_pArray = newPtr;

  000ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newPtr$[rsp]
  000ba	48 89 08	 mov	 QWORD PTR [rax], rcx

; 74   : 		m_nMax = nMaxCount;

  000bd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000c5	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  000cc	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 75   : 		memset(m_pArray, 0, nMaxCount * sizeof(void*));

  000cf	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  000d7	48 c1 e0 03	 shl	 rax, 3
  000db	48 89 44 24 48	 mov	 QWORD PTR tv94[rsp], rax
  000e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000e8	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  000eb	33 c0		 xor	 eax, eax
  000ed	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv94[rsp]
  000f2	f3 aa		 rep stosb

; 76   : 	}
; 77   : 	else {

  000f4	e9 d5 00 00 00	 jmp	 $LN4@realloc
$LN3@realloc:

; 78   : 		memcpy(newPtr, m_pArray, m_nMax * sizeof(void*));

  000f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00101	48 63 40 10	 movsxd	 rax, DWORD PTR [rax+16]
  00105	48 c1 e0 03	 shl	 rax, 3
  00109	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00111	48 8b 7c 24 30	 mov	 rdi, QWORD PTR newPtr$[rsp]
  00116	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  00119	48 8b c8	 mov	 rcx, rax
  0011c	f3 a4		 rep movsb

; 79   : 		printf("[%p] ################### realloc success m_nLast[%d] m_nMax[%d] nMaxCount[%d]\n", m_pArray, m_nLast, m_nMax, nMaxCount);

  0011e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR nMaxCount$[rsp]
  00125	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00129	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00131	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  00135	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0013d	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  00141	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00149	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG44508
  00153	e8 00 00 00 00	 call	 printf

; 80   : 		SPIN_LOCK_ENTER(&m_cLockPop);

  00158	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00160	48 83 c0 50	 add	 rax, 80			; 00000050H
  00164	48 8b c8	 mov	 rcx, rax
  00167	e8 00 00 00 00	 call	 acquireSpinLock

; 81   : 		m_pArray = newPtr;

  0016c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newPtr$[rsp]
  00179	48 89 08	 mov	 QWORD PTR [rax], rcx

; 82   : 		m_nLast = m_nMax;

  0017c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00184	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0018c	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0018f	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 83   : 		m_nMax = nMaxCount;

  00192	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0019a	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  001a1	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 84   : 		SPIN_LOCK_LEAVE(&m_cLockPop);

  001a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ac	48 83 c0 50	 add	 rax, 80			; 00000050H
  001b0	48 8b c8	 mov	 rcx, rax
  001b3	e8 00 00 00 00	 call	 releaseSpinLock

; 85   : 		m_nOldMax = m_nLast;

  001b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001c8	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  001cb	89 48 54	 mov	 DWORD PTR [rax+84], ecx
$LN4@realloc:

; 86   : 	}
; 87   : 	m_nRealloc.init();

  001ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001d6	48 83 c0 58	 add	 rax, 88			; 00000058H
  001da	48 8b c8	 mov	 rcx, rax
  001dd	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 88   : 	m_CS.leave();

  001e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ea	48 83 c0 20	 add	 rax, 32			; 00000020H
  001ee	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001f6	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001fa	48 89 4c 24 50	 mov	 QWORD PTR tv170[rsp], rcx
  001ff	48 8b c8	 mov	 rcx, rax
  00202	48 8b 44 24 50	 mov	 rax, QWORD PTR tv170[rsp]
  00207	ff 50 10	 call	 QWORD PTR [rax+16]

; 89   : 	if(oldPtr) free(oldPtr);

  0020a	48 83 7c 24 38
	00		 cmp	 QWORD PTR oldPtr$[rsp], 0
  00210	74 0b		 je	 SHORT $LN5@realloc
  00212	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oldPtr$[rsp]
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@realloc:

; 90   : 	return true;

  0021d	b0 01		 mov	 al, 1
$LN1@realloc:

; 91   : }

  0021f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00223	5f		 pop	 rdi
  00224	5e		 pop	 rsi
  00225	c3		 ret	 0
?realloc@CQueueS@@QEAA_NH_N@Z ENDP			; CQueueS::realloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comqueue.cpp
;	COMDAT ?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
type$ = 64
?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z PROC		; CQueueS::alloc, COMDAT

; 48   : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 49   : 	m_pArray = (void **)calloc(nMaxCount, sizeof(void*));

  00012	48 63 44 24 38	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00017	ba 08 00 00 00	 mov	 edx, 8
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 50   : 	if (m_pArray == 0) {

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00036	75 04		 jne	 SHORT $LN2@alloc

; 51   : 		//gs_cLogger.DebugLog(LEVEL_ERROR, "m_pArray calloc ERROR nMaxCount[%d]", nMaxCount);
; 52   : 		return false;

  00038	32 c0		 xor	 al, al
  0003a	eb 1a		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 53   : 	}
; 54   : 
; 55   : 	m_nMax = nMaxCount;

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00041	8b 4c 24 38	 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  00045	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 56   : 	m_nObjAllocType = type;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004d	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  00051	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 57   : 	//gs_cLogger.PutLogQueue(LEVEL_INFO, _T("CQueue<T>::alloc nMaxCount[%d]"), nMaxCount);
; 58   : 	return true;

  00054	b0 01		 mov	 al, 1
$LN1@alloc:

; 59   : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z ENDP		; CQueueS::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comqueue.cpp
;	COMDAT ??1CQueueS@@QEAA@XZ
_TEXT	SEGMENT
p$ = 32
i$ = 40
tv88 = 44
tv146 = 48
$T1 = 56
$T2 = 64
tv92 = 72
tv145 = 80
tv135 = 88
$T3 = 96
this$ = 128
??1CQueueS@@QEAA@XZ PROC				; CQueueS::~CQueueS, COMDAT

; 19   : {

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00009	48 c7 44 24 60
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 20   : 	if (!m_pArray) return;

  00012	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001e	75 05		 jne	 SHORT $LN7@CQueueS
  00020	e9 99 01 00 00	 jmp	 $LN1@CQueueS
$LN7@CQueueS:

; 21   : 
; 22   : 	void *p;
; 23   : 	int i;
; 24   : 	if (ISABLETODELETE(m_nObjAllocType)) {

  00025	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002d	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00030	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  00035	90		 npad	 1
  00036	0f b6 c0	 movzx	 eax, al
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 5c 01 00
	00		 je	 $LN8@CQueueS

; 25   : 		for (i = 0; i < m_nMax; i++) {

  00041	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00049	eb 0a		 jmp	 SHORT $LN4@CQueueS
$LN2@CQueueS:
  0004b	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0004f	ff c0		 inc	 eax
  00051	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@CQueueS:
  00055	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0005d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00060	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00064	0f 8d 33 01 00
	00		 jge	 $LN8@CQueueS

; 26   : 			p = m_pArray[i];

  0006a	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0006f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00077	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007a	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007e	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 27   : 			if (p) {

  00083	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00089	0f 84 09 01 00
	00		 je	 $LN9@CQueueS

; 28   : 				switch (m_nObjAllocType) {

  0008f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00097	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0009a	89 44 24 2c	 mov	 DWORD PTR tv88[rsp], eax
  0009e	83 7c 24 2c 02	 cmp	 DWORD PTR tv88[rsp], 2
  000a3	74 1e		 je	 SHORT $LN10@CQueueS
  000a5	83 7c 24 2c 03	 cmp	 DWORD PTR tv88[rsp], 3
  000aa	74 59		 je	 SHORT $LN11@CQueueS
  000ac	83 7c 24 2c 04	 cmp	 DWORD PTR tv88[rsp], 4
  000b1	74 63		 je	 SHORT $LN12@CQueueS
  000b3	83 7c 24 2c 05	 cmp	 DWORD PTR tv88[rsp], 5
  000b8	0f 84 9f 00 00
	00		 je	 $LN13@CQueueS
  000be	e9 d5 00 00 00	 jmp	 $LN9@CQueueS
$LN10@CQueueS:

; 29   : 				case eAlloc_Type_new:	delete p; break;

  000c3	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000c8	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  000cd	33 d2		 xor	 edx, edx
  000cf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T1[rsp]
  000d4	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000d9	90		 npad	 1
  000da	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000e0	75 0b		 jne	 SHORT $LN17@CQueueS
  000e2	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv92[rsp], 0
  000eb	eb 13		 jmp	 SHORT $LN18@CQueueS
$LN17@CQueueS:
  000ed	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000fb	48 89 44 24 48	 mov	 QWORD PTR tv92[rsp], rax
$LN18@CQueueS:
  00100	e9 93 00 00 00	 jmp	 $LN9@CQueueS
$LN11@CQueueS:

; 30   : 				case eAlloc_Type_alloc:	free(p); break;

  00105	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00110	90		 npad	 1
  00111	e9 82 00 00 00	 jmp	 $LN9@CQueueS
$LN12@CQueueS:

; 31   : 				case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00116	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0011b	48 89 44 24 50	 mov	 QWORD PTR tv145[rsp], rax
  00120	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv146[rsp], -1
$LL21@CQueueS:
  00129	48 ff 44 24 30	 inc	 QWORD PTR tv146[rsp]
  0012e	48 8b 44 24 50	 mov	 rax, QWORD PTR tv145[rsp]
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv146[rsp]
  00138	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  0013c	75 eb		 jne	 SHORT $LL21@CQueueS
  0013e	48 8b 44 24 30	 mov	 rax, QWORD PTR tv146[rsp]
  00143	48 ff c0	 inc	 rax
  00146	44 8b c0	 mov	 r8d, eax
  00149	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00155	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  0015a	90		 npad	 1
  0015b	eb 3b		 jmp	 SHORT $LN9@CQueueS
$LN13@CQueueS:

; 32   : 				case eAlloc_Type_newArray:	delete[] p; break;

  0015d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00162	48 89 44 24 40	 mov	 QWORD PTR $T2[rsp], rax
  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T2[rsp]
  0016c	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  00171	90		 npad	 1
  00172	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00178	75 0b		 jne	 SHORT $LN19@CQueueS
  0017a	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv135[rsp], 0
  00183	eb 13		 jmp	 SHORT $LN9@CQueueS
$LN19@CQueueS:
  00185	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  0018e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00193	48 89 44 24 58	 mov	 QWORD PTR tv135[rsp], rax
$LN9@CQueueS:

; 33   : 				case eAlloc_Type_none: break;
; 34   : 				case eAlloc_Type_MemPool: break;
; 35   : 				}
; 36   : 			}
; 37   : 		}			

  00198	e9 ae fe ff ff	 jmp	 $LN2@CQueueS
$LN8@CQueueS:

; 38   : 	}
; 39   : 	free(m_pArray);

  0019d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001a5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001ae	90		 npad	 1

; 40   : 	m_pArray = 0;

  001af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b7	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@CQueueS:

; 41   : 	SPIN_LOCK_DESTROY(&m_cLockPush);
; 42   : 	SPIN_LOCK_DESTROY(&m_cLockPop);
; 43   : }

  001be	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c6	48 83 c0 58	 add	 rax, 88			; 00000058H
  001ca	48 8b c8	 mov	 rcx, rax
  001cd	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  001d2	90		 npad	 1
  001d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001db	48 83 c0 50	 add	 rax, 80			; 00000050H
  001df	48 8b c8	 mov	 rcx, rax
  001e2	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::~win_atomic
  001e7	90		 npad	 1
  001e8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001f0	48 83 c0 20	 add	 rax, 32			; 00000020H
  001f4	48 8b c8	 mov	 rcx, rax
  001f7	e8 00 00 00 00	 call	 ??1critical_section@win32@common@@UEAA@XZ ; common::win32::critical_section::~critical_section
  001fc	90		 npad	 1
  001fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00205	48 83 c0 18	 add	 rax, 24
  00209	48 8b c8	 mov	 rcx, rax
  0020c	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::~win_atomic
  00211	90		 npad	 1
  00212	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00216	c3		 ret	 0
??1CQueueS@@QEAA@XZ ENDP				; CQueueS::~CQueueS
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comqueue.cpp
;	COMDAT ??0CQueueS@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0CQueueS@@QEAA@XZ PROC				; CQueueS::CQueueS, COMDAT

; 6    : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 83 c0 18	 add	 rax, 24
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??0win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::win_atomic
  00024	90		 npad	 1
  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 83 c0 20	 add	 rax, 32			; 00000020H
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ??0critical_section@win32@common@@QEAA@XZ ; common::win32::critical_section::critical_section
  00036	90		 npad	 1
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003c	48 83 c0 50	 add	 rax, 80			; 00000050H
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 ??0win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::win_atomic
  00048	90		 npad	 1
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004e	48 83 c0 58	 add	 rax, 88			; 00000058H
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic

; 7    : 	memset(g_szMessage, 0, LEN_MEM_MESSAGE);

  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00061	48 8b f8	 mov	 rdi, rax
  00064	33 c0		 xor	 eax, eax
  00066	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0006b	f3 aa		 rep stosb

; 8    : 	m_pArray = NULL;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00072	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 9    : 	m_nMax = 0;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 10   : 	m_nFront = 0;

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 11   : 	m_nLast = 0;

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00096	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 12   : 	SPIN_LOCK_INIT(&m_cLockPush);

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a2	48 83 c0 18	 add	 rax, 24
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 initSpinLock

; 13   : 	SPIN_LOCK_INIT(&m_cLockPop);

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000b3	48 83 c0 50	 add	 rax, 80			; 00000050H
  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 initSpinLock

; 14   : 	m_nOldMax = 0;

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c4	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0

; 15   : }

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000d0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
??0CQueueS@@QEAA@XZ ENDP				; CQueueS::CQueueS
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA PROC			; `CQueueS::CQueueS'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 18	 add	 rcx, 24
  00011	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::~win_atomic
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA ENDP			; `CQueueS::CQueueS'::`1'::dtor$0
$T1 = 32
this$ = 64
?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA PROC			; `CQueueS::CQueueS'::`1'::dtor$1
  0001c	40 55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
  00025	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  00029	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0002d	e8 00 00 00 00	 call	 ??1critical_section@win32@common@@UEAA@XZ ; common::win32::critical_section::~critical_section
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA ENDP			; `CQueueS::CQueueS'::`1'::dtor$1
$T1 = 32
this$ = 64
?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA PROC			; `CQueueS::CQueueS'::`1'::dtor$2
  00038	40 55		 push	 rbp
  0003a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0003e	48 8b ea	 mov	 rbp, rdx
  00041	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  00045	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00049	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::~win_atomic
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA ENDP			; `CQueueS::CQueueS'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA PROC			; `CQueueS::CQueueS'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 18	 add	 rcx, 24
  00011	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::~win_atomic
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0CQueueS@@QEAA@XZ@4HA ENDP			; `CQueueS::CQueueS'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA PROC			; `CQueueS::CQueueS'::`1'::dtor$1
  0001c	40 55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
  00025	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  00029	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0002d	e8 00 00 00 00	 call	 ??1critical_section@win32@common@@UEAA@XZ ; common::win32::critical_section::~critical_section
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?dtor$1@?0???0CQueueS@@QEAA@XZ@4HA ENDP			; `CQueueS::CQueueS'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA PROC			; `CQueueS::CQueueS'::`1'::dtor$2
  00038	40 55		 push	 rbp
  0003a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0003e	48 8b ea	 mov	 rbp, rdx
  00041	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  00045	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00049	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QEAA@XZ ; common::win32::win_atomic::~win_atomic
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?dtor$2@?0???0CQueueS@@QEAA@XZ@4HA ENDP			; `CQueueS::CQueueS'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
e$ = 8
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z PROC		; ISABLETODELETE, COMDAT

; 247  : inline bool ISABLETODELETE(E_ALLOC_TYPE e) { if (eAlloc_Type_MemPool < e) return true; return false; }

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	83 7c 24 08 01	 cmp	 DWORD PTR e$[rsp], 1
  00009	7e 04		 jle	 SHORT $LN2@ISABLETODE
  0000b	b0 01		 mov	 al, 1
  0000d	eb 02		 jmp	 SHORT $LN1@ISABLETODE
$LN2@ISABLETODE:
  0000f	32 c0		 xor	 al, al
$LN1@ISABLETODE:
  00011	c3		 ret	 0
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ENDP		; ISABLETODELETE
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
_TEXT	SEGMENT
tv70 = 0
this$ = 32
nExchange$ = 40
nComperand$ = 48
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z PROC ; common::win32::win64_atomic::atomic_compare_exchange, COMDAT

; 120  : 	inline long long atomic_compare_exchange(long long nExchange, long long nComperand) {return InterlockedCompareExchange64(&m_count, nExchange, nComperand);} // return long

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24
  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nExchange$[rsp]
  0001d	48 89 04 24	 mov	 QWORD PTR tv70[rsp], rax
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR nComperand$[rsp]
  00026	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  0002a	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  0002e	f0 48 0f b1 0a	 lock cmpxchg QWORD PTR [rdx], rcx
  00033	48 83 c4 18	 add	 rsp, 24
  00037	c3		 ret	 0
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ENDP ; common::win32::win64_atomic::atomic_compare_exchange
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?init@win64_atomic@win32@common@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?init@win64_atomic@win32@common@@QEAAXXZ PROC		; common::win32::win64_atomic::init, COMDAT

; 114  : 	inline void init() { m_count = 0; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	c3		 ret	 0
?init@win64_atomic@win32@common@@QEAAXXZ ENDP		; common::win32::win64_atomic::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?getCount@win64_atomic@win32@common@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getCount@win64_atomic@win32@common@@QEAAHXZ PROC	; common::win32::win64_atomic::getCount, COMDAT

; 111  : 	inline int getCount() { return (int)m_count; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	c3		 ret	 0
?getCount@win64_atomic@win32@common@@QEAAHXZ ENDP	; common::win32::win64_atomic::getCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::~win64_atomic, COMDAT

; 108  : 	~win64_atomic() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::~win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::win64_atomic, COMDAT

; 107  : 	win64_atomic() {m_count = 0;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c3		 ret	 0
??0win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1win_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1win_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win_atomic::~win_atomic, COMDAT

; 88   : 	~win_atomic() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1win_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win_atomic::~win_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0win_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0win_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win_atomic::win_atomic, COMDAT

; 87   : 	win_atomic() {m_count = 0;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00010	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00015	c3		 ret	 0
??0win_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win_atomic::win_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gcritical_section@win32@common@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gcritical_section@win32@common@@UEAAPEAXI@Z PROC	; common::win32::critical_section::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1critical_section@win32@common@@UEAA@XZ ; common::win32::critical_section::~critical_section
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gcritical_section@win32@common@@UEAAPEAXI@Z ENDP	; common::win32::critical_section::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?leave@critical_section@win32@common@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?leave@critical_section@win32@common@@UEAAXXZ PROC	; common::win32::critical_section::leave, COMDAT

; 55   : 	void leave() { LeaveCriticalSection(&m_cs);}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
?leave@critical_section@win32@common@@UEAAXXZ ENDP	; common::win32::critical_section::leave
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?enter@critical_section@win32@common@@UEAA_N_N@Z
_TEXT	SEGMENT
tv72 = 32
bRet$ = 36
this$ = 64
bWait$ = 72
?enter@critical_section@win32@common@@UEAA_N_N@Z PROC	; common::win32::critical_section::enter, COMDAT

; 39   : 	{ 

$LN7:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 40   : 	     BOOL	bRet = TRUE;

  0000d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 1

; 41   : 
; 42   : 	     if (bWait) 

  00015	0f b6 44 24 48	 movzx	 eax, BYTE PTR bWait$[rsp]
  0001a	85 c0		 test	 eax, eax
  0001c	74 14		 je	 SHORT $LN2@enter

; 43   : 		     EnterCriticalSection(&m_cs);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 c0 08	 add	 rax, 8
  00027	48 8b c8	 mov	 rcx, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 44   : 	     else

  00030	eb 16		 jmp	 SHORT $LN3@enter
$LN2@enter:

; 45   :     #if(_WIN32_WINNT >= 0x0400)
; 46   : 		     bRet = TryEnterCriticalSection(&m_cs);

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 83 c0 08	 add	 rax, 8
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TryEnterCriticalSection
  00044	89 44 24 24	 mov	 DWORD PTR bRet$[rsp], eax
$LN3@enter:

; 47   :     #else
; 48   : 		    EnterCriticalSection(&m_cs);
; 49   :     #endif
; 50   : 
; 51   : 	     return (bRet)?true:false;

  00048	83 7c 24 24 00	 cmp	 DWORD PTR bRet$[rsp], 0
  0004d	74 07		 je	 SHORT $LN5@enter
  0004f	c6 44 24 20 01	 mov	 BYTE PTR tv72[rsp], 1
  00054	eb 05		 jmp	 SHORT $LN6@enter
$LN5@enter:
  00056	c6 44 24 20 00	 mov	 BYTE PTR tv72[rsp], 0
$LN6@enter:
  0005b	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv72[rsp]

; 52   : 
; 53   : 	} 

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
?enter@critical_section@win32@common@@UEAA_N_N@Z ENDP	; common::win32::critical_section::enter
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1critical_section@win32@common@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1critical_section@win32@common@@UEAA@XZ PROC		; common::win32::critical_section::~critical_section, COMDAT

; 36   : 	virtual ~critical_section() { DeleteCriticalSection(&m_cs);}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7critical_section@win32@common@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx
  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 8b c8	 mov	 rcx, rax
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	e8 00 00 00 00	 call	 ??1abstract_critical_section@common@@UEAA@XZ ; common::abstract_critical_section::~abstract_critical_section
  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
??1critical_section@win32@common@@UEAA@XZ ENDP		; common::win32::critical_section::~critical_section
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0critical_section@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0critical_section@win32@common@@QEAA@XZ PROC		; common::win32::critical_section::critical_section, COMDAT

; 35   : 	critical_section() { InitializeCriticalSection(&m_cs); }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??0abstract_critical_section@common@@QEAA@XZ
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7critical_section@win32@common@@6B@
  0001f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 83 c0 08	 add	 rax, 8
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
??0critical_section@win32@common@@QEAA@XZ ENDP		; common::win32::critical_section::critical_section
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gabstract_critical_section@common@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gabstract_critical_section@common@@UEAAPEAXI@Z PROC	; common::abstract_critical_section::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1abstract_critical_section@common@@UEAA@XZ ; common::abstract_critical_section::~abstract_critical_section
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 08 00 00 00	 mov	 edx, 8
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gabstract_critical_section@common@@UEAAPEAXI@Z ENDP	; common::abstract_critical_section::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0abstract_critical_section@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0abstract_critical_section@common@@QEAA@XZ PROC	; common::abstract_critical_section::abstract_critical_section, COMDAT
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7abstract_critical_section@common@@6B@
  00011	48 89 08	 mov	 QWORD PTR [rax], rcx
  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00019	c3		 ret	 0
??0abstract_critical_section@common@@QEAA@XZ ENDP	; common::abstract_critical_section::abstract_critical_section
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\abstract_mtsync.h
;	COMDAT ??1abstract_critical_section@common@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1abstract_critical_section@common@@UEAA@XZ PROC	; common::abstract_critical_section::~abstract_critical_section, COMDAT

; 61   : 	virtual ~abstract_critical_section() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7abstract_critical_section@common@@6B@
  00011	48 89 08	 mov	 QWORD PTR [rax], rcx
  00014	c3		 ret	 0
??1abstract_critical_section@common@@UEAA@XZ ENDP	; common::abstract_critical_section::~abstract_critical_section
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
__$ArrayPad$ = 48
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00027	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0002c	48 8d 44 24 58	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00031	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00036	b9 01 00 00 00	 mov	 ecx, 1
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00041	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00046	45 33 c0	 xor	 r8d, r8d
  00049	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Format$[rsp]
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 _vfprintf_l
  00056	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

  0005a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

  00063	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 957  : }

  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006c	48 33 cc	 xor	 rcx, rsp
  0006f	e8 00 00 00 00	 call	 __security_check_cookie
  00074	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00078	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
