; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_szSystemError@@3PADA				; g_szSystemError
PUBLIC	?g_szMessage@@3PADA				; g_szMessage
PUBLIC	?gs_pMMgr@@3PEAVCMemManager@@EA			; gs_pMMgr
_BSS	SEGMENT
?g_szSystemError@@3PADA DB 0400H DUP (?)		; g_szSystemError
?g_szMessage@@3PADA DB 080H DUP (?)			; g_szMessage
?gs_pMMgr@@3PEAVCMemManager@@EA DQ 01H DUP (?)		; gs_pMMgr
_BSS	ENDS
CONST	SEGMENT
$SG44505 DB	'getStrToInt parsing FAIL!!! cUnit[%c]', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	??_GCBufPool@@QEAAPEAXI@Z			; CBufPool::`scalar deleting destructor'
PUBLIC	??0CMemManager@@QEAA@XZ				; CMemManager::CMemManager
PUBLIC	??1CMemManager@@QEAA@XZ				; CMemManager::~CMemManager
PUBLIC	?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z	; CMemManager::init
PUBLIC	?init@CMemManager@@QEAAHPEADH@Z			; CMemManager::init
PUBLIC	?alloc@CMemManager@@QEAA_NXZ			; CMemManager::alloc
PUBLIC	?delBuf@CMemManager@@QEAAXPEADH@Z		; CMemManager::delBuf
PUBLIC	?delBufByIndex@CMemManager@@QEAAXPEADH@Z	; CMemManager::delBufByIndex
PUBLIC	?getStrToInt@CMemManager@@QEAAHPEAD@Z		; CMemManager::getStrToInt
PUBLIC	?__newBuf@CMemManager@@AEAAPEADH_K@Z		; CMemManager::__newBuf
PUBLIC	?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z		; OBJ_DELETE
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_atoi:PROC
EXTRN	??2@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??3@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	??0CBufPool@@QEAA@XZ:PROC			; CBufPool::CBufPool
EXTRN	??1CBufPool@@QEAA@XZ:PROC			; CBufPool::~CBufPool
EXTRN	?alloc@CBufPool@@QEAA_NHH@Z:PROC		; CBufPool::alloc
EXTRN	?newMem@CBufPool@@QEAAPEADXZ:PROC		; CBufPool::newMem
EXTRN	?delMem@CBufPool@@QEAAXPEAD@Z:PROC		; CBufPool::delMem
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getIndex@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$?getIndex@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCBufPool@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCBufPool@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CMemManager@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+338
	DD	imagerel $unwind$??0CMemManager@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CMemManager@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+154
	DD	imagerel $unwind$??1CMemManager@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@CMemManager@@QEAAHPEADH@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$?init@CMemManager@@QEAAHPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@CMemManager@@QEAA_NXZ DD imagerel $LN17
	DD	imagerel $LN17+466
	DD	imagerel $unwind$?alloc@CMemManager@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBuf@CMemManager@@QEAAXPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?delBuf@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBufByIndex@CMemManager@@QEAAXPEADH@Z DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$?delBufByIndex@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getStrToInt@CMemManager@@QEAAHPEAD@Z DD imagerel $LN16
	DD	imagerel $LN16+399
	DD	imagerel $unwind$?getStrToInt@CMemManager@@QEAAHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__newBuf@CMemManager@@AEAAPEADH_K@Z DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$?__newBuf@CMemManager@@AEAAPEADH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z DD imagerel $LN16
	DD	imagerel $LN16+272
	DD	imagerel $unwind$?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z DD 010d01H
	DD	0c20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__newBuf@CMemManager@@AEAAPEADH_K@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getStrToInt@CMemManager@@QEAAHPEAD@Z DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBufByIndex@CMemManager@@QEAAXPEADH@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBuf@CMemManager@@QEAAXPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?alloc@CMemManager@@QEAA_NXZ DD imagerel ?alloc@CMemManager@@QEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?alloc@CMemManager@@QEAA_NXZ+211
	DD	00H
	DD	imagerel ?alloc@CMemManager@@QEAA_NXZ+255
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?alloc@CMemManager@@QEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?alloc@CMemManager@@QEAA_NXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?alloc@CMemManager@@QEAA_NXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?alloc@CMemManager@@QEAA_NXZ
	DD	070H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@CMemManager@@QEAA_NXZ DD 021511H
	DD	011010cH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?alloc@CMemManager@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@CMemManager@@QEAAHPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CMemManager@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CMemManager@@QEAA@XZ DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCBufPool@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getIndex@@YAHH@Z DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z
_TEXT	SEGMENT
tv64 = 32
tv86 = 40
$T1 = 48
$T2 = 56
tv68 = 64
tv85 = 72
tv79 = 80
type$ = 112
p$ = 120
?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z PROC		; OBJ_DELETE, COMDAT

; 150  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 151  : 	switch (type) {

  0000d	8b 44 24 70	 mov	 eax, DWORD PTR type$[rsp]
  00011	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00015	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  0001a	74 1e		 je	 SHORT $LN4@OBJ_DELETE
  0001c	83 7c 24 20 03	 cmp	 DWORD PTR tv64[rsp], 3
  00021	74 58		 je	 SHORT $LN5@OBJ_DELETE
  00023	83 7c 24 20 04	 cmp	 DWORD PTR tv64[rsp], 4
  00028	74 61		 je	 SHORT $LN6@OBJ_DELETE
  0002a	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  0002f	0f 84 9c 00 00
	00		 je	 $LN7@OBJ_DELETE
  00035	e9 d1 00 00 00	 jmp	 $LN2@OBJ_DELETE
$LN4@OBJ_DELETE:

; 152  : 	case eAlloc_Type_new		: delete p; break;

  0003a	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  0003f	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  00044	33 d2		 xor	 edx, edx
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
  0004b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00050	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00056	75 0b		 jne	 SHORT $LN11@OBJ_DELETE
  00058	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00061	eb 13		 jmp	 SHORT $LN12@OBJ_DELETE
$LN11@OBJ_DELETE:
  00063	48 c7 44 24 78
	23 81 00 00	 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  0006c	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  00071	48 89 44 24 40	 mov	 QWORD PTR tv68[rsp], rax
$LN12@OBJ_DELETE:
  00076	e9 90 00 00 00	 jmp	 $LN2@OBJ_DELETE
$LN5@OBJ_DELETE:

; 153  : 	case eAlloc_Type_alloc		: free(p); break;

  0007b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00086	e9 80 00 00 00	 jmp	 $LN2@OBJ_DELETE
$LN6@OBJ_DELETE:

; 154  : 	case eAlloc_Type_BufPool	: gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  0008b	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  00090	48 89 44 24 48	 mov	 QWORD PTR tv85[rsp], rax
  00095	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR tv86[rsp], -1
$LL15@OBJ_DELETE:
  0009e	48 ff 44 24 28	 inc	 QWORD PTR tv86[rsp]
  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR tv85[rsp]
  000a8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv86[rsp]
  000ad	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  000b1	75 eb		 jne	 SHORT $LL15@OBJ_DELETE
  000b3	48 8b 44 24 28	 mov	 rax, QWORD PTR tv86[rsp]
  000b8	48 ff c0	 inc	 rax
  000bb	44 8b c0	 mov	 r8d, eax
  000be	48 8b 54 24 78	 mov	 rdx, QWORD PTR p$[rsp]
  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000ca	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  000cf	eb 3a		 jmp	 SHORT $LN2@OBJ_DELETE
$LN7@OBJ_DELETE:

; 155  : 	case eAlloc_Type_newArray	: delete[] p; break;

  000d1	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  000d6	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000e0	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  000e5	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000eb	75 0b		 jne	 SHORT $LN13@OBJ_DELETE
  000ed	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  000f6	eb 13		 jmp	 SHORT $LN14@OBJ_DELETE
$LN13@OBJ_DELETE:
  000f8	48 c7 44 24 78
	23 81 00 00	 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  00106	48 89 44 24 50	 mov	 QWORD PTR tv79[rsp], rax
$LN14@OBJ_DELETE:
$LN2@OBJ_DELETE:

; 156  : 	case eAlloc_Type_none		: break;
; 157  : 	case eAlloc_Type_MemPool	: break;
; 158  : 	}
; 159  : }

  0010b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0010f	c3		 ret	 0
?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z ENDP		; OBJ_DELETE
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ?__newBuf@CMemManager@@AEAAPEADH_K@Z
_TEXT	SEGMENT
p$1 = 32
this$ = 64
nIdx$ = 72
size$ = 80
?__newBuf@CMemManager@@AEAAPEADH_K@Z PROC		; CMemManager::__newBuf, COMDAT

; 125  : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 126  : 	if (IDX_BUF_2m < nIdx || !m_pBufList[nIdx]) {

  00012	83 7c 24 48 15	 cmp	 DWORD PTR nIdx$[rsp], 21
  00017	7f 11		 jg	 SHORT $LN3@newBuf
  00019	48 63 44 24 48	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00023	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00028	75 3c		 jne	 SHORT $LN2@newBuf
$LN3@newBuf:

; 127  : 		if (m_nOverMaxIdx < nIdx) m_nOverMaxIdx = nIdx;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002f	8b 4c 24 48	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00033	39 88 08 01 00
	00		 cmp	 DWORD PTR [rax+264], ecx
  00039	7d 0f		 jge	 SHORT $LN4@newBuf
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00040	8b 4c 24 48	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00044	89 88 08 01 00
	00		 mov	 DWORD PTR [rax+264], ecx
$LN4@newBuf:

; 128  : 		char *p = (char *)calloc(1, size);

  0004a	48 8b 54 24 50	 mov	 rdx, QWORD PTR size$[rsp]
  0004f	b9 01 00 00 00	 mov	 ecx, 1
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0005a	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax

; 129  : /*		if (p) {
; 130  : 			gs_cLogger.DebugLog(LEVEL_TRACE, "overIdx:%d, overSize:%lld calloc address[%p]", m_nOverMaxIdx, size, p);
; 131  : 		}
; 132  : 		else {
; 133  : 			gs_cLogger.DebugLog(LEVEL_ERROR, "calloc has Failed");
; 134  : 		}	*/	
; 135  : 		return p;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  00064	eb 13		 jmp	 SHORT $LN1@newBuf
$LN2@newBuf:

; 136  : 	}
; 137  : 
; 138  : 	return m_pBufList[nIdx]->newMem();

  00066	48 63 44 24 48	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00070	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00074	e8 00 00 00 00	 call	 ?newMem@CBufPool@@QEAAPEADXZ ; CBufPool::newMem
$LN1@newBuf:

; 139  : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
?__newBuf@CMemManager@@AEAAPEADH_K@Z ENDP		; CMemManager::__newBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ?getStrToInt@CMemManager@@QEAAHPEAD@Z
_TEXT	SEGMENT
cUnit$ = 32
nRes$ = 36
tv80 = 40
i$ = 44
pPos$ = 48
szNum$ = 56
__$ArrayPad$ = 88
this$ = 112
pData$ = 120
?getStrToInt@CMemManager@@QEAAHPEAD@Z PROC		; CMemManager::getStrToInt, COMDAT

; 47   : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 48   : 	TCHAR *pPos = pData;

  0001d	48 8b 44 24 78	 mov	 rax, QWORD PTR pData$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR pPos$[rsp], rax

; 49   : 	TCHAR szNum[32], cUnit = 0;

  00027	c6 44 24 20 00	 mov	 BYTE PTR cUnit$[rsp], 0

; 50   : 	int i = 0, nRes=0;

  0002c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00034	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR nRes$[rsp], 0
$LN2@getStrToIn:

; 51   : 	while (*pPos) {

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR pPos$[rsp]
  00041	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00044	85 c0		 test	 eax, eax
  00046	74 52		 je	 SHORT $LN3@getStrToIn

; 52   : 		if ('0' <= *pPos && *pPos <= '9') szNum[i++] = *pPos;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR pPos$[rsp]
  0004d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00050	83 f8 30	 cmp	 eax, 48			; 00000030H
  00053	7c 2a		 jl	 SHORT $LN6@getStrToIn
  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR pPos$[rsp]
  0005a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005d	83 f8 39	 cmp	 eax, 57			; 00000039H
  00060	7f 1d		 jg	 SHORT $LN6@getStrToIn
  00062	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$[rsp]
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pPos$[rsp]
  0006c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006f	88 4c 04 38	 mov	 BYTE PTR szNum$[rsp+rax], cl
  00073	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  00077	ff c0		 inc	 eax
  00079	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
  0007d	eb 0c		 jmp	 SHORT $LN7@getStrToIn
$LN6@getStrToIn:

; 53   : 		else cUnit = *pPos;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR pPos$[rsp]
  00084	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00087	88 44 24 20	 mov	 BYTE PTR cUnit$[rsp], al
$LN7@getStrToIn:

; 54   : 		pPos++;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR pPos$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 30	 mov	 QWORD PTR pPos$[rsp], rax

; 55   : 	}

  00098	eb a2		 jmp	 SHORT $LN2@getStrToIn
$LN3@getStrToIn:

; 56   : 	nRes = _ttoi(szNum);

  0009a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR szNum$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000a5	89 44 24 24	 mov	 DWORD PTR nRes$[rsp], eax

; 57   : 	if (cUnit) {

  000a9	0f be 44 24 20	 movsx	 eax, BYTE PTR cUnit$[rsp]
  000ae	85 c0		 test	 eax, eax
  000b0	0f 84 8a 00 00
	00		 je	 $LN8@getStrToIn

; 58   : 		switch (cUnit) {

  000b6	0f be 44 24 20	 movsx	 eax, BYTE PTR cUnit$[rsp]
  000bb	89 44 24 28	 mov	 DWORD PTR tv80[rsp], eax
  000bf	8b 44 24 28	 mov	 eax, DWORD PTR tv80[rsp]
  000c3	83 e8 47	 sub	 eax, 71			; 00000047H
  000c6	89 44 24 28	 mov	 DWORD PTR tv80[rsp], eax
  000ca	83 7c 24 28 26	 cmp	 DWORD PTR tv80[rsp], 38	; 00000026H
  000cf	77 5c		 ja	 SHORT $LN12@getStrToIn
  000d1	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv80[rsp]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000dd	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN14@getStrToIn[rcx+rax]
  000e5	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN15@getStrToIn[rcx+rax*4]
  000ec	48 03 c1	 add	 rax, rcx
  000ef	ff e0		 jmp	 rax
$LN9@getStrToIn:

; 59   : 		case 'k': case 'K': nRes = nRes * 1024; break;

  000f1	69 44 24 24 00
	04 00 00	 imul	 eax, DWORD PTR nRes$[rsp], 1024 ; 00000400H
  000f9	89 44 24 24	 mov	 DWORD PTR nRes$[rsp], eax
  000fd	eb 41		 jmp	 SHORT $LN4@getStrToIn
$LN10@getStrToIn:

; 60   : 		case 'm': case 'M': nRes = nRes * 1024 * 1024; break;

  000ff	69 44 24 24 00
	04 00 00	 imul	 eax, DWORD PTR nRes$[rsp], 1024 ; 00000400H
  00107	69 c0 00 04 00
	00		 imul	 eax, eax, 1024		; 00000400H
  0010d	89 44 24 24	 mov	 DWORD PTR nRes$[rsp], eax
  00111	eb 2d		 jmp	 SHORT $LN4@getStrToIn
$LN11@getStrToIn:

; 61   : 		case 'g': case 'G': nRes = nRes * 1024 * 1024 * 1024; break;

  00113	69 44 24 24 00
	04 00 00	 imul	 eax, DWORD PTR nRes$[rsp], 1024 ; 00000400H
  0011b	69 c0 00 04 00
	00		 imul	 eax, eax, 1024		; 00000400H
  00121	69 c0 00 04 00
	00		 imul	 eax, eax, 1024		; 00000400H
  00127	89 44 24 24	 mov	 DWORD PTR nRes$[rsp], eax
  0012b	eb 13		 jmp	 SHORT $LN4@getStrToIn
$LN12@getStrToIn:

; 62   : 		default: printf("getStrToInt parsing FAIL!!! cUnit[%c]\n", cUnit);

  0012d	0f be 44 24 20	 movsx	 eax, BYTE PTR cUnit$[rsp]
  00132	8b d0		 mov	 edx, eax
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG44505
  0013b	e8 00 00 00 00	 call	 printf
$LN4@getStrToIn:
$LN8@getStrToIn:

; 63   : 		}
; 64   : 	}
; 65   : 	return nRes;

  00140	8b 44 24 24	 mov	 eax, DWORD PTR nRes$[rsp]

; 66   : }

  00144	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00149	48 33 cc	 xor	 rcx, rsp
  0014c	e8 00 00 00 00	 call	 __security_check_cookie
  00151	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00155	c3		 ret	 0
  00156	66 90		 npad	 2
$LN15@getStrToIn:
  00158	00 00 00 00	 DD	 $LN11@getStrToIn
  0015c	00 00 00 00	 DD	 $LN9@getStrToIn
  00160	00 00 00 00	 DD	 $LN10@getStrToIn
  00164	00 00 00 00	 DD	 $LN12@getStrToIn
$LN14@getStrToIn:
  00168	00		 DB	 0
  00169	03		 DB	 3
  0016a	03		 DB	 3
  0016b	03		 DB	 3
  0016c	01		 DB	 1
  0016d	03		 DB	 3
  0016e	02		 DB	 2
  0016f	03		 DB	 3
  00170	03		 DB	 3
  00171	03		 DB	 3
  00172	03		 DB	 3
  00173	03		 DB	 3
  00174	03		 DB	 3
  00175	03		 DB	 3
  00176	03		 DB	 3
  00177	03		 DB	 3
  00178	03		 DB	 3
  00179	03		 DB	 3
  0017a	03		 DB	 3
  0017b	03		 DB	 3
  0017c	03		 DB	 3
  0017d	03		 DB	 3
  0017e	03		 DB	 3
  0017f	03		 DB	 3
  00180	03		 DB	 3
  00181	03		 DB	 3
  00182	03		 DB	 3
  00183	03		 DB	 3
  00184	03		 DB	 3
  00185	03		 DB	 3
  00186	03		 DB	 3
  00187	03		 DB	 3
  00188	00		 DB	 0
  00189	03		 DB	 3
  0018a	03		 DB	 3
  0018b	03		 DB	 3
  0018c	01		 DB	 1
  0018d	03		 DB	 3
  0018e	02		 DB	 2
?getStrToInt@CMemManager@@QEAAHPEAD@Z ENDP		; CMemManager::getStrToInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ?delBufByIndex@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
this$ = 48
pBuf$ = 56
nIdx$ = 64
?delBufByIndex@CMemManager@@QEAAXPEADH@Z PROC		; CMemManager::delBufByIndex, COMDAT

; 143  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 144  : 	if (IDX_BUF_2m < nIdx || !m_pBufList[nIdx]) { if (pBuf) free(pBuf); return; }

  00013	83 7c 24 40 15	 cmp	 DWORD PTR nIdx$[rsp], 21
  00018	7f 11		 jg	 SHORT $LN3@delBufByIn
  0001a	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00024	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00029	75 15		 jne	 SHORT $LN2@delBufByIn
$LN3@delBufByIn:
  0002b	48 83 7c 24 38
	00		 cmp	 QWORD PTR pBuf$[rsp], 0
  00031	74 0b		 je	 SHORT $LN4@delBufByIn
  00033	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pBuf$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@delBufByIn:
  0003e	eb 29		 jmp	 SHORT $LN1@delBufByIn
$LN2@delBufByIn:

; 145  : 	if(m_pBufList[nIdx]) m_pBufList[nIdx]->delMem(pBuf);

  00040	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0004f	74 18		 je	 SHORT $LN5@delBufByIn
  00051	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00056	48 8b 54 24 38	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0005b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00060	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00064	e8 00 00 00 00	 call	 ?delMem@CBufPool@@QEAAXPEAD@Z ; CBufPool::delMem
$LN5@delBufByIn:
$LN1@delBufByIn:

; 146  : }

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
?delBufByIndex@CMemManager@@QEAAXPEADH@Z ENDP		; CMemManager::delBufByIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
pBuf$ = 72
nSize$ = 80
?delBuf@CMemManager@@QEAAXPEADH@Z PROC			; CMemManager::delBuf, COMDAT

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR nSize$[rsp]
  00017	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0001c	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00020	44 8b 44 24 20	 mov	 r8d, DWORD PTR nIdx$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?delBuf@CMemManager@@QEAAXPEADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ?alloc@CMemManager@@QEAA_NXZ
_TEXT	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
tv138 = 56
$T3 = 64
$T4 = 72
tv85 = 80
$T5 = 88
$T6 = 96
tv166 = 104
$T7 = 112
this$ = 144
?alloc@CMemManager@@QEAA_NXZ PROC			; CMemManager::alloc, COMDAT

; 89   : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000c	48 c7 44 24 70
	fe ff ff ff	 mov	 QWORD PTR $T7[rsp], -2

; 90   : 	int i;
; 91   : 	for (i = IDX_BUF_2; i < IDX_BUF_MAX; i++)

  00015	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0001d	eb 0a		 jmp	 SHORT $LN4@alloc
$LN2@alloc:
  0001f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@alloc:
  00029	83 7c 24 20 16	 cmp	 DWORD PTR i$[rsp], 22
  0002e	0f 8d 94 01 00
	00		 jge	 $LN3@alloc

; 92   : 	{
; 93   : 		if (!m_stConfig.nMaxList[i]) continue;

  00034	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00041	83 bc 81 b0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+176], 0
  00049	75 02		 jne	 SHORT $LN5@alloc
  0004b	eb d2		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 94   : 
; 95   : 		if (m_pBufList[i]) {

  0004d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00052	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0005a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0005f	74 5c		 je	 SHORT $LN6@alloc

; 96   : 			delete m_pBufList[i];

  00061	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00066	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00072	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  00077	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  0007c	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00081	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00087	74 16		 je	 SHORT $LN10@alloc
  00089	ba 01 00 00 00	 mov	 edx, 1
  0008e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00093	e8 00 00 00 00	 call	 ??_GCBufPool@@QEAAPEAXI@Z
  00098	48 89 44 24 50	 mov	 QWORD PTR tv85[rsp], rax
  0009d	eb 09		 jmp	 SHORT $LN11@alloc
$LN10@alloc:
  0009f	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
$LN11@alloc:

; 97   : 			m_pBufList[i] = NULL;

  000a8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ad	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000b5	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN6@alloc:

; 98   : 		}
; 99   : 		m_pBufList[i] = new (std::nothrow) CBufPool();

  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  000c4	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  000c9	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  000ce	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  000d3	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000d9	74 11		 je	 SHORT $LN12@alloc
  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  000e0	e8 00 00 00 00	 call	 ??0CBufPool@@QEAA@XZ	; CBufPool::CBufPool
  000e5	48 89 44 24 38	 mov	 QWORD PTR tv138[rsp], rax
  000ea	eb 09		 jmp	 SHORT $LN13@alloc
$LN12@alloc:
  000ec	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv138[rsp], 0
$LN13@alloc:
  000f5	48 8b 44 24 38	 mov	 rax, QWORD PTR tv138[rsp]
  000fa	48 89 44 24 58	 mov	 QWORD PTR $T5[rsp], rax
  000ff	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00104	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0010c	48 8b 54 24 58	 mov	 rdx, QWORD PTR $T5[rsp]
  00111	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 100  : 		if (m_pBufList[i]) {

  00115	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0011a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00122	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00127	0f 84 96 00 00
	00		 je	 $LN7@alloc

; 101  : 			if (!m_pBufList[i]->alloc(i, m_stConfig.nMaxList[i])) {

  0012d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00132	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00137	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR this$[rsp]
  0013f	44 8b 84 82 b0
	00 00 00	 mov	 r8d, DWORD PTR [rdx+rax*4+176]
  00147	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0014b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00153	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00157	e8 00 00 00 00	 call	 ?alloc@CBufPool@@QEAA_NHH@Z ; CBufPool::alloc
  0015c	0f b6 c0	 movzx	 eax, al
  0015f	85 c0		 test	 eax, eax
  00161	75 60		 jne	 SHORT $LN7@alloc

; 102  : 				delete m_pBufList[i];

  00163	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00168	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00170	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00174	48 89 44 24 60	 mov	 QWORD PTR $T6[rsp], rax
  00179	48 8b 44 24 60	 mov	 rax, QWORD PTR $T6[rsp]
  0017e	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00183	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00189	74 16		 je	 SHORT $LN14@alloc
  0018b	ba 01 00 00 00	 mov	 edx, 1
  00190	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  00195	e8 00 00 00 00	 call	 ??_GCBufPool@@QEAAPEAXI@Z
  0019a	48 89 44 24 68	 mov	 QWORD PTR tv166[rsp], rax
  0019f	eb 09		 jmp	 SHORT $LN15@alloc
$LN14@alloc:
  001a1	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv166[rsp], 0
$LN15@alloc:

; 103  : 				m_pBufList[i] = NULL;

  001aa	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001af	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001b7	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 104  : 				return false;

  001bf	32 c0		 xor	 al, al
  001c1	eb 07		 jmp	 SHORT $LN1@alloc
$LN7@alloc:

; 105  : 			}
; 106  : 		}
; 107  : 	}

  001c3	e9 57 fe ff ff	 jmp	 $LN2@alloc
$LN3@alloc:

; 108  : 	return true;

  001c8	b0 01		 mov	 al, 1
$LN1@alloc:

; 109  : 
; 110  : }

  001ca	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001d1	c3		 ret	 0
?alloc@CMemManager@@QEAA_NXZ ENDP			; CMemManager::alloc
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
tv138 = 56
$T3 = 64
$T4 = 72
tv85 = 80
$T5 = 88
$T6 = 96
tv166 = 104
$T7 = 112
this$ = 144
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA PROC	; `CMemManager::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 30	 mov	 rcx, QWORD PTR $T2[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA ENDP	; `CMemManager::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
tv138 = 56
$T3 = 64
$T4 = 72
tv85 = 80
$T5 = 88
$T6 = 96
tv166 = 104
$T7 = 112
this$ = 144
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA PROC	; `CMemManager::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 30	 mov	 rcx, QWORD PTR $T2[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA ENDP	; `CMemManager::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ?init@CMemManager@@QEAAHPEADH@Z
_TEXT	SEGMENT
nSize$ = 32
nIdx$ = 36
this$ = 64
pStrSize$ = 72
nCount$ = 80
?init@CMemManager@@QEAAHPEADH@Z PROC			; CMemManager::init, COMDAT

; 78   : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 79   : 	int nSize = getStrToInt(pStrSize);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStrSize$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	e8 00 00 00 00	 call	 ?getStrToInt@CMemManager@@QEAAHPEAD@Z ; CMemManager::getStrToInt
  00022	89 44 24 20	 mov	 DWORD PTR nSize$[rsp], eax

; 80   : 	int nIdx;
; 81   : 	if (nSize) {

  00026	83 7c 24 20 00	 cmp	 DWORD PTR nSize$[rsp], 0
  0002b	74 33		 je	 SHORT $LN2@init

; 82   : 		nIdx = getIndex(nSize);

  0002d	8b 4c 24 20	 mov	 ecx, DWORD PTR nSize$[rsp]
  00031	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00036	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 83   : 		m_stConfig.nMaxList[nIdx] += nCount;

  0003a	48 63 44 24 24	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00044	8b 84 81 b0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+176]
  0004b	03 44 24 50	 add	 eax, DWORD PTR nCount$[rsp]
  0004f	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR nIdx$[rsp]
  00054	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  00059	89 84 8a b0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+176], eax
$LN2@init:

; 84   : 	}
; 85   : 	return nSize;

  00060	8b 44 24 20	 mov	 eax, DWORD PTR nSize$[rsp]

; 86   : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?init@CMemManager@@QEAAHPEADH@Z ENDP			; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z
_TEXT	SEGMENT
i$ = 0
this$ = 32
pConf$ = 40
?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z PROC		; CMemManager::init, COMDAT

; 69   : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 70   : 	int i;
; 71   : 	for (i = 0; i < IDX_BUF_MAX; i++)

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00015	eb 08		 jmp	 SHORT $LN4@init
$LN2@init:
  00017	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@init:
  0001f	83 3c 24 16	 cmp	 DWORD PTR i$[rsp], 22
  00023	7d 2e		 jge	 SHORT $LN3@init

; 72   : 	{
; 73   : 		m_stConfig.nMaxList[i] += pConf->nMaxList[i];

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0002d	48 8b 54 24 20	 mov	 rdx, QWORD PTR this$[rsp]
  00032	8b 84 82 b0 00
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+176]
  00039	48 8b 54 24 28	 mov	 rdx, QWORD PTR pConf$[rsp]
  0003e	03 04 8a	 add	 eax, DWORD PTR [rdx+rcx*4]
  00041	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00045	48 8b 54 24 20	 mov	 rdx, QWORD PTR this$[rsp]
  0004a	89 84 8a b0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+176], eax

; 74   : 	}

  00051	eb c4		 jmp	 SHORT $LN2@init
$LN3@init:

; 75   : }

  00053	48 83 c4 18	 add	 rsp, 24
  00057	c3		 ret	 0
?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z ENDP		; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ??1CMemManager@@QEAA@XZ
_TEXT	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
tv79 = 56
this$ = 80
??1CMemManager@@QEAA@XZ PROC				; CMemManager::~CMemManager, COMDAT

; 35   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 36   : 	int i =  0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 37   : 	for (i = IDX_BUF_2; i < IDX_BUF_MAX; i++) {

  00011	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00019	eb 0a		 jmp	 SHORT $LN4@CMemManage
$LN2@CMemManage:
  0001b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001f	ff c0		 inc	 eax
  00021	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@CMemManage:
  00025	83 7c 24 20 16	 cmp	 DWORD PTR i$[rsp], 22
  0002a	7d 69		 jge	 SHORT $LN3@CMemManage

; 38   : 		if (m_pBufList[i]) {

  0002c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00036	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0003b	74 56		 je	 SHORT $LN5@CMemManage

; 39   : 			delete m_pBufList[i]; m_pBufList[i] = 0;

  0003d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00047	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0004b	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  00055	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0005a	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00060	74 16		 je	 SHORT $LN7@CMemManage
  00062	ba 01 00 00 00	 mov	 edx, 1
  00067	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0006c	e8 00 00 00 00	 call	 ??_GCBufPool@@QEAAPEAXI@Z
  00071	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  00076	eb 09		 jmp	 SHORT $LN8@CMemManage
$LN7@CMemManage:
  00078	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
$LN8@CMemManage:
  00081	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0008b	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN5@CMemManage:

; 40   : 		}
; 41   : 	}

  00093	eb 86		 jmp	 SHORT $LN2@CMemManage
$LN3@CMemManage:

; 42   : 
; 43   : 
; 44   : }

  00095	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00099	c3		 ret	 0
??1CMemManager@@QEAA@XZ ENDP				; CMemManager::~CMemManager
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
;	COMDAT ??0CMemManager@@QEAA@XZ
_TEXT	SEGMENT
i$ = 0
this$ = 32
??0CMemManager@@QEAA@XZ PROC				; CMemManager::CMemManager, COMDAT

; 9    : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 10   : 	m_nOverMaxIdx = 0;

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0000f	c7 80 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+264], 0

; 11   : 	memset(m_pBufList, 0, sizeof(m_pBufList));

  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0001e	48 8b 7c 24 20	 mov	 rdi, QWORD PTR this$[rsp]
  00023	33 c0		 xor	 eax, eax
  00025	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  0002a	f3 aa		 rep stosb

; 12   : 	memset(&m_stConfig, 0, sizeof(STBufConf));

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00041	f3 aa		 rep stosb

; 13   : 	int i;
; 14   : 
; 15   : 	m_stConfig.nMaxList[IDX_BUF_2] = 256;

  00043	b8 04 00 00 00	 mov	 eax, 4
  00048	48 6b c0 01	 imul	 rax, rax, 1
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  00051	c7 84 01 b0 00
	00 00 00 01 00
	00		 mov	 DWORD PTR [rcx+rax+176], 256 ; 00000100H

; 16   : 	m_stConfig.nMaxList[IDX_BUF_4] = 256;

  0005c	b8 04 00 00 00	 mov	 eax, 4
  00061	48 6b c0 02	 imul	 rax, rax, 2
  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  0006a	c7 84 01 b0 00
	00 00 00 01 00
	00		 mov	 DWORD PTR [rcx+rax+176], 256 ; 00000100H

; 17   : 	m_stConfig.nMaxList[IDX_BUF_8] = 2048;

  00075	b8 04 00 00 00	 mov	 eax, 4
  0007a	48 6b c0 03	 imul	 rax, rax, 3
  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  00083	c7 84 01 b0 00
	00 00 00 08 00
	00		 mov	 DWORD PTR [rcx+rax+176], 2048 ; 00000800H

; 18   : 	m_stConfig.nMaxList[IDX_BUF_16] = 2048;

  0008e	b8 04 00 00 00	 mov	 eax, 4
  00093	48 6b c0 04	 imul	 rax, rax, 4
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  0009c	c7 84 01 b0 00
	00 00 00 08 00
	00		 mov	 DWORD PTR [rcx+rax+176], 2048 ; 00000800H

; 19   : 	for (i = IDX_BUF_32; i < IDX_BUF_16k; i++)

  000a7	c7 04 24 05 00
	00 00		 mov	 DWORD PTR i$[rsp], 5
  000ae	eb 08		 jmp	 SHORT $LN4@CMemManage
$LN2@CMemManage:
  000b0	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000b3	ff c0		 inc	 eax
  000b5	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@CMemManage:
  000b8	83 3c 24 0e	 cmp	 DWORD PTR i$[rsp], 14
  000bc	7d 16		 jge	 SHORT $LN3@CMemManage

; 20   : 	{
; 21   : 		m_stConfig.nMaxList[i] = 64;

  000be	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  000c7	c7 84 81 b0 00
	00 00 40 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+176], 64 ; 00000040H

; 22   : 	}

  000d2	eb dc		 jmp	 SHORT $LN2@CMemManage
$LN3@CMemManage:

; 23   : 	for (i = IDX_BUF_16k; i < IDX_BUF_64k; i++)

  000d4	c7 04 24 0e 00
	00 00		 mov	 DWORD PTR i$[rsp], 14
  000db	eb 08		 jmp	 SHORT $LN7@CMemManage
$LN5@CMemManage:
  000dd	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000e0	ff c0		 inc	 eax
  000e2	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@CMemManage:
  000e5	83 3c 24 10	 cmp	 DWORD PTR i$[rsp], 16
  000e9	7d 16		 jge	 SHORT $LN6@CMemManage

; 24   : 	{
; 25   : 		m_stConfig.nMaxList[i] = 4;

  000eb	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  000f4	c7 84 81 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+176], 4

; 26   : 	}

  000ff	eb dc		 jmp	 SHORT $LN5@CMemManage
$LN6@CMemManage:

; 27   : 	for (i = IDX_BUF_64k; i < IDX_BUF_512k; i++)

  00101	c7 04 24 10 00
	00 00		 mov	 DWORD PTR i$[rsp], 16
  00108	eb 08		 jmp	 SHORT $LN10@CMemManage
$LN8@CMemManage:
  0010a	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0010d	ff c0		 inc	 eax
  0010f	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN10@CMemManage:
  00112	83 3c 24 13	 cmp	 DWORD PTR i$[rsp], 19
  00116	7d 16		 jge	 SHORT $LN9@CMemManage

; 28   : 	{
; 29   : 		m_stConfig.nMaxList[i] = 2;

  00118	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0011c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  00121	c7 84 81 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+176], 2

; 30   : 	}

  0012c	eb dc		 jmp	 SHORT $LN8@CMemManage
$LN9@CMemManage:

; 31   : 	m_stConfig.nMaxList[IDX_BUF_1m] = 1;

  0012e	b8 04 00 00 00	 mov	 eax, 4
  00133	48 6b c0 14	 imul	 rax, rax, 20
  00137	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  0013c	c7 84 01 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+176], 1

; 32   : }

  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0014c	48 83 c4 10	 add	 rsp, 16
  00150	5f		 pop	 rdi
  00151	c3		 ret	 0
??0CMemManager@@QEAA@XZ ENDP				; CMemManager::CMemManager
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCBufPool@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCBufPool@@QEAAPEAXI@Z PROC				; CBufPool::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CBufPool@@QEAA@XZ	; CBufPool::~CBufPool
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCBufPool@@QEAAPEAXI@Z ENDP				; CBufPool::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = 0
m$ = 4
tv80 = 8
$S1$ = 16
s$ = 48
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	f2 0f 2a 44 24
	30		 cvtsi2sd xmm0, DWORD PTR s$[rsp]
  0000e	f2 0f 11 44 24
	10		 movsd	 QWORD PTR $S1$[rsp], xmm0
  00014	b8 04 00 00 00	 mov	 eax, 4
  00019	48 6b c0 01	 imul	 rax, rax, 1
  0001d	8b 44 04 10	 mov	 eax, DWORD PTR $S1$[rsp+rax]
  00021	c1 f8 14	 sar	 eax, 20
  00024	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  00029	89 44 24 04	 mov	 DWORD PTR m$[rsp], eax
  0002d	8b 44 24 04	 mov	 eax, DWORD PTR m$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	89 4c 24 08	 mov	 DWORD PTR tv80[rsp], ecx
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR tv80[rsp]
  00041	d3 e0		 shl	 eax, cl
  00043	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  0004f	23 c8		 and	 ecx, eax
  00051	8b c1		 mov	 eax, ecx
  00053	85 c0		 test	 eax, eax
  00055	74 09		 je	 SHORT $LN3@getIndex
  00057	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  0005e	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN4@getIndex:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR m$[rsp]
  0006e	03 c8		 add	 ecx, eax
  00070	8b c1		 mov	 eax, ecx
  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
__$ArrayPad$ = 48
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00027	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0002c	48 8d 44 24 58	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00031	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00036	b9 01 00 00 00	 mov	 ecx, 1
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00041	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00046	45 33 c0	 xor	 r8d, r8d
  00049	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Format$[rsp]
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 _vfprintf_l
  00056	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

  0005a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

  00063	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 957  : }

  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006c	48 33 cc	 xor	 rcx, rsp
  0006f	e8 00 00 00 00	 call	 __security_check_cookie
  00074	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00078	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
