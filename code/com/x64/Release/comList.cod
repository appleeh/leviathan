; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG44514 DB	'm_nMaxCount[%d]', 00H
$SG44515 DB	'CSList::__alloc', 00H
$SG44536 DB	'i[%d] m_nLast[%d] m_nCurCount[%d]', 00H
	ORG $+6
$SG44537 DB	'CSList::add', 00H
	ORG $+4
$SG44558 DB	' i[%d] m_nLast[%d] m_nCurCount[%d]', 00H
	ORG $+5
$SG44559 DB	'CSList::push_back', 00H
	ORG $+6
$SG44585 DB	' del FAIL! i[%d] m_nMax[%d]', 00H
	ORG $+4
$SG44586 DB	'CSList::del', 00H
	ORG $+4
$SG44600 DB	'i[%d] m_nMax[%d]', 00H
	ORG $+7
$SG44601 DB	'CSList::del', 00H
CONST	ENDS
PUBLIC	?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z		; ISABLETODELETE
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?delBuf@CMemManager@@QEAAXPEADH@Z		; CMemManager::delBuf
PUBLIC	??0CSList@@QEAA@XZ				; CSList::CSList
PUBLIC	??1CSList@@QEAA@XZ				; CSList::~CSList
PUBLIC	?clear@CSList@@QEAAXXZ				; CSList::clear
PUBLIC	?add@CSList@@QEAA_NPEAXPEAH@Z			; CSList::add
PUBLIC	?push_back@CSList@@QEAA_NPEAXPEAH@Z		; CSList::push_back
PUBLIC	?del@CSList@@QEAA_NPEAX_N@Z			; CSList::del
PUBLIC	?del@CSList@@QEAA_NH_N@Z			; CSList::del
PUBLIC	?getNext@CSList@@QEAAPEAXPEAH@Z			; CSList::getNext
PUBLIC	?__alloc@CSList@@AEAAHH@Z			; CSList::__alloc
PUBLIC	?_DEL@CSList@@AEAAXH@Z				; CSList::_DEL
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	?delBufByIndex@CMemManager@@QEAAXPEADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	?__debugLog@CLogger@@QEAAXHPEBDH0ZZ:PROC	; CLogger::__debugLog
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?gs_pMMgr@@3PEAVCMemManager@@EA:QWORD		; gs_pMMgr
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getIndex@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$?getIndex@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBuf@CMemManager@@QEAAXPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?delBuf@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CSList@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+486
	DD	imagerel $unwind$??1CSList@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@CSList@@QEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+505
	DD	imagerel $unwind$?clear@CSList@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?add@CSList@@QEAA_NPEAXPEAH@Z DD imagerel $LN15
	DD	imagerel $LN15+424
	DD	imagerel $unwind$?add@CSList@@QEAA_NPEAXPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@CSList@@QEAA_NPEAXPEAH@Z DD imagerel $LN15
	DD	imagerel $LN15+424
	DD	imagerel $unwind$?push_back@CSList@@QEAA_NPEAXPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@CSList@@QEAA_NPEAX_N@Z DD imagerel $LN21
	DD	imagerel $LN21+502
	DD	imagerel $unwind$?del@CSList@@QEAA_NPEAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@CSList@@QEAA_NH_N@Z DD imagerel $LN14
	DD	imagerel $LN14+441
	DD	imagerel $unwind$?del@CSList@@QEAA_NH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@CSList@@AEAAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+208
	DD	imagerel $unwind$?__alloc@CSList@@AEAAHH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@CSList@@AEAAHH@Z DD 030f01H
	DD	0700b820fH
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@CSList@@QEAA_NH_N@Z DD 011201H
	DD	0e212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@CSList@@QEAA_NPEAX_N@Z DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@CSList@@QEAA_NPEAXPEAH@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?add@CSList@@QEAA_NPEAXPEAH@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@CSList@@QEAAXXZ DD 021c19H
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CSList@@QEAA@XZ DD imagerel ??1CSList@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CSList@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CSList@@QEAA@XZ
	DD	060H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CSList@@QEAA@XZ DD 022419H
	DD	011010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??1CSList@@QEAA@XZ
	DD	073H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBuf@CMemManager@@QEAAXPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getIndex@@YAHH@Z DD 010801H
	DD	04208H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?_DEL@CSList@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
?_DEL@CSList@@AEAAXH@Z PROC				; CSList::_DEL, COMDAT

; 60   : 	inline void _DEL(int i) { m_pArray[i] = 0; m_nUse--; m_nDelIdx = i; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 63 44 24 10	 movsxd	 rax, DWORD PTR i$[rsp]
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c8		 dec	 eax
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 4c 24 10	 mov	 ecx, DWORD PTR i$[rsp]
  00039	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  0003c	c3		 ret	 0
?_DEL@CSList@@AEAAXH@Z ENDP				; CSList::_DEL
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ?__alloc@CSList@@AEAAHH@Z
_TEXT	SEGMENT
pList$ = 48
this$ = 96
nMaxCount$ = 104
?__alloc@CSList@@AEAAHH@Z PROC				; CSList::__alloc, COMDAT

; 66   : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 67   : 	if (nMaxCount <= m_nMax) return m_nMax;

  0000f	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00014	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00017	39 44 24 68	 cmp	 DWORD PTR nMaxCount$[rsp], eax
  0001b	7f 0d		 jg	 SHORT $LN2@alloc
  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00022	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00025	e9 9f 00 00 00	 jmp	 $LN1@alloc
$LN2@alloc:

; 68   : 	void** pList = (void**)calloc(nMaxCount, sizeof(void*));

  0002a	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0002f	ba 08 00 00 00	 mov	 edx, 8
  00034	48 8b c8	 mov	 rcx, rax
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0003d	48 89 44 24 30	 mov	 QWORD PTR pList$[rsp], rax

; 69   : 	if (!pList) {

  00042	48 83 7c 24 30
	00		 cmp	 QWORD PTR pList$[rsp], 0
  00048	75 36		 jne	 SHORT $LN3@alloc

; 70   : 		gs_cLogger.DebugLog(LEVEL_ERROR, _T("m_nMaxCount[%d]"), nMaxCount);

  0004a	8b 44 24 68	 mov	 eax, DWORD PTR nMaxCount$[rsp]
  0004e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44514
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	41 b9 46 00 00
	00		 mov	 r9d, 70			; 00000046H
  00064	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44515
  0006b	ba 05 00 00 00	 mov	 edx, 5
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00077	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 71   : 		return 0;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 49		 jmp	 SHORT $LN1@alloc
$LN3@alloc:

; 72   : 	}
; 73   : 	//_stprintf(g_szMessage, _T("CList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 74   : 	if (m_pArray) {

  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00085	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00089	74 2d		 je	 SHORT $LN4@alloc

; 75   : 		memcpy(pList, m_pArray, m_nMax * sizeof(void*));

  0008b	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00090	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00094	48 c1 e0 03	 shl	 rax, 3
  00098	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0009d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pList$[rsp]
  000a2	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	f3 a4		 rep movsb

; 76   : 		free(m_pArray);

  000aa	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000af	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@alloc:

; 77   : 	}
; 78   : 	m_pArray = pList;

  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pList$[rsp]
  000c2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 79   : 	return nMaxCount;

  000c5	8b 44 24 68	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 80   : }

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	5f		 pop	 rdi
  000ce	5e		 pop	 rsi
  000cf	c3		 ret	 0
?__alloc@CSList@@AEAAHH@Z ENDP				; CSList::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?getNext@CSList@@QEAAPEAXPEAH@Z
_TEXT	SEGMENT
this$ = 8
pIdx$ = 16
?getNext@CSList@@QEAAPEAXPEAH@Z PROC			; CSList::getNext, COMDAT

; 35   : 	inline void* getNext(int *pIdx) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 36   : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000a	eb 10		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  0000c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00011	8b 00		 mov	 eax, DWORD PTR [rax]
  00013	ff c0		 inc	 eax
  00015	48 8b 4c 24 10	 mov	 rcx, QWORD PTR pIdx$[rsp]
  0001a	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@getNext:
  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00026	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00029	39 08		 cmp	 DWORD PTR [rax], ecx
  0002b	7d 2f		 jge	 SHORT $LN3@getNext

; 37   : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002d	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00032	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00035	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00042	74 16		 je	 SHORT $LN5@getNext
  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00049	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 38   : 		}

  0005a	eb b0		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 39   : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
$LN1@getNext:

; 40   : 	}

  0005e	c3		 ret	 0
?getNext@CSList@@QEAAPEAXPEAH@Z ENDP			; CSList::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ?del@CSList@@QEAA_NH_N@Z
_TEXT	SEGMENT
tv81 = 64
tv158 = 72
$T1 = 80
tv157 = 88
$T2 = 96
this$ = 128
i$ = 136
bDeepDelete$ = 144
?del@CSList@@QEAA_NH_N@Z PROC				; CSList::del, COMDAT

; 178  : {

$LN14:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 179  : 	if (!ISINCLUDE(i, m_nMax)) {

  00012	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0001a	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  0001d	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00024	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 4b		 jne	 SHORT $LN4@del

; 180  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "i[%d] m_nMax[%d]", i, m_nMax);

  00030	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00038	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0003b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0003f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00046	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44600
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	41 b9 b4 00 00
	00		 mov	 r9d, 180		; 000000b4H
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44601
  00063	ba 05 00 00 00	 mov	 edx, 5
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0006f	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 181  : 		return false;

  00074	32 c0		 xor	 al, al
  00076	e9 39 01 00 00	 jmp	 $LN1@del
$LN4@del:

; 182  : 	}
; 183  : 	if (bDeepDelete) {

  0007b	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR bDeepDelete$[rsp]
  00083	85 c0		 test	 eax, eax
  00085	0f 84 13 01 00
	00		 je	 $LN5@del

; 184  : 		switch (m_nObjAllocType) {

  0008b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00093	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00096	89 44 24 40	 mov	 DWORD PTR tv81[rsp], eax
  0009a	83 7c 24 40 02	 cmp	 DWORD PTR tv81[rsp], 2
  0009f	74 1e		 je	 SHORT $LN6@del
  000a1	83 7c 24 40 03	 cmp	 DWORD PTR tv81[rsp], 3
  000a6	74 44		 je	 SHORT $LN7@del
  000a8	83 7c 24 40 04	 cmp	 DWORD PTR tv81[rsp], 4
  000ad	74 5f		 je	 SHORT $LN8@del
  000af	83 7c 24 40 05	 cmp	 DWORD PTR tv81[rsp], 5
  000b4	0f 84 be 00 00
	00		 je	 $LN9@del
  000ba	e9 df 00 00 00	 jmp	 $LN2@del
$LN6@del:

; 185  : 		case eAlloc_Type_new:	delete m_pArray[i]; break;

  000bf	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000cf	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000d6	48 89 44 24 50	 mov	 QWORD PTR $T1[rsp], rax
  000db	33 d2		 xor	 edx, edx
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T1[rsp]
  000e2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000e7	e9 b2 00 00 00	 jmp	 $LN2@del
$LN7@del:

; 186  : 		case eAlloc_Type_alloc:	free(m_pArray[i]); break;

  000ec	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  000f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000fc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ff	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00109	e9 90 00 00 00	 jmp	 $LN2@del
$LN8@del:

; 187  : 		case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)m_pArray[i], STRING_SIZE((TCHAR *)m_pArray[i])); break;

  0010e	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00116	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0011e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00121	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00125	48 89 44 24 58	 mov	 QWORD PTR tv157[rsp], rax
  0012a	48 c7 44 24 48
	ff ff ff ff	 mov	 QWORD PTR tv158[rsp], -1
$LL13@del:
  00133	48 ff 44 24 48	 inc	 QWORD PTR tv158[rsp]
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR tv157[rsp]
  0013d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv158[rsp]
  00142	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00146	75 eb		 jne	 SHORT $LL13@del
  00148	48 8b 44 24 48	 mov	 rax, QWORD PTR tv158[rsp]
  0014d	48 ff c0	 inc	 rax
  00150	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00158	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR this$[rsp]
  00160	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00163	44 8b c0	 mov	 r8d, eax
  00166	48 8b 14 ca	 mov	 rdx, QWORD PTR [rdx+rcx*8]
  0016a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00171	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00176	eb 26		 jmp	 SHORT $LN2@del
$LN9@del:

; 188  : 		case eAlloc_Type_newArray:	delete[] m_pArray[i]; break;

  00178	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00180	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00188	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0018b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0018f	48 89 44 24 60	 mov	 QWORD PTR $T2[rsp], rax
  00194	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T2[rsp]
  00199	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN2@del:
$LN5@del:

; 189  : 		case eAlloc_Type_none: break;
; 190  : 		case eAlloc_Type_MemPool: break;
; 191  : 		}
; 192  : 	}
; 193  : 	_DEL(i);

  0019e	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  001a5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001ad	e8 00 00 00 00	 call	 ?_DEL@CSList@@AEAAXH@Z	; CSList::_DEL

; 194  : //	_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 195  : 	return true;

  001b2	b0 01		 mov	 al, 1
$LN1@del:

; 196  : }

  001b4	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001b8	c3		 ret	 0
?del@CSList@@QEAA_NH_N@Z ENDP				; CSList::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ?del@CSList@@QEAA_NPEAX_N@Z
_TEXT	SEGMENT
i$ = 64
tv75 = 68
tv140 = 72
$T1 = 80
$T2 = 88
tv79 = 96
tv139 = 104
tv90 = 112
this$ = 144
p$ = 152
bDeepDelete$ = 160
?del@CSList@@QEAA_NPEAX_N@Z PROC			; CSList::del, COMDAT

; 154  : {

$LN21:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 155  : 	int i;
; 156  : 	for (i = 0; i < m_nMax; i++) {

  00016	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001e	eb 0a		 jmp	 SHORT $LN4@del
$LN2@del:
  00020	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@del:
  0002a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00032	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00035	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00039	0f 8d 6c 01 00
	00		 jge	 $LN3@del

; 157  : 		if (m_pArray[i] == p) {

  0003f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00044	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00057	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  0005b	0f 85 45 01 00
	00		 jne	 $LN7@del

; 158  : 			if (bDeepDelete) {

  00061	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR bDeepDelete$[rsp]
  00069	85 c0		 test	 eax, eax
  0006b	0f 84 20 01 00
	00		 je	 $LN8@del

; 159  : 				switch (m_nObjAllocType) {

  00071	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00079	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0007c	89 44 24 44	 mov	 DWORD PTR tv75[rsp], eax
  00080	83 7c 24 44 02	 cmp	 DWORD PTR tv75[rsp], 2
  00085	74 1e		 je	 SHORT $LN9@del
  00087	83 7c 24 44 03	 cmp	 DWORD PTR tv75[rsp], 3
  0008c	74 61		 je	 SHORT $LN10@del
  0008e	83 7c 24 44 04	 cmp	 DWORD PTR tv75[rsp], 4
  00093	74 6d		 je	 SHORT $LN11@del
  00095	83 7c 24 44 05	 cmp	 DWORD PTR tv75[rsp], 5
  0009a	0f 84 ae 00 00
	00		 je	 $LN12@del
  000a0	e9 ec 00 00 00	 jmp	 $LN5@del
$LN9@del:

; 160  : 				case eAlloc_Type_new:	delete p; break;

  000a5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000ad	48 89 44 24 50	 mov	 QWORD PTR $T1[rsp], rax
  000b2	33 d2		 xor	 edx, edx
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T1[rsp]
  000b9	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000be	48 83 7c 24 50
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000c4	75 0b		 jne	 SHORT $LN16@del
  000c6	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  000cf	eb 19		 jmp	 SHORT $LN17@del
$LN16@del:
  000d1	48 c7 84 24 98
	00 00 00 23 81
	00 00		 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  000dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000e5	48 89 44 24 60	 mov	 QWORD PTR tv79[rsp], rax
$LN17@del:
  000ea	e9 a2 00 00 00	 jmp	 $LN5@del
$LN10@del:

; 161  : 				case eAlloc_Type_alloc:	free(p); break;

  000ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000fd	e9 8f 00 00 00	 jmp	 $LN5@del
$LN11@del:

; 162  : 				case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00102	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0010a	48 89 44 24 68	 mov	 QWORD PTR tv139[rsp], rax
  0010f	48 c7 44 24 48
	ff ff ff ff	 mov	 QWORD PTR tv140[rsp], -1
$LL20@del:
  00118	48 ff 44 24 48	 inc	 QWORD PTR tv140[rsp]
  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR tv139[rsp]
  00122	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv140[rsp]
  00127	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  0012b	75 eb		 jne	 SHORT $LL20@del
  0012d	48 8b 44 24 48	 mov	 rax, QWORD PTR tv140[rsp]
  00132	48 ff c0	 inc	 rax
  00135	44 8b c0	 mov	 r8d, eax
  00138	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00140	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00147	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  0014c	eb 43		 jmp	 SHORT $LN5@del
$LN12@del:

; 163  : 				case eAlloc_Type_newArray:	delete[] p; break;

  0014e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00156	48 89 44 24 58	 mov	 QWORD PTR $T2[rsp], rax
  0015b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T2[rsp]
  00160	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  00165	48 83 7c 24 58
	00		 cmp	 QWORD PTR $T2[rsp], 0
  0016b	75 0b		 jne	 SHORT $LN18@del
  0016d	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  00176	eb 19		 jmp	 SHORT $LN19@del
$LN18@del:
  00178	48 c7 84 24 98
	00 00 00 23 81
	00 00		 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  00184	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0018c	48 89 44 24 70	 mov	 QWORD PTR tv90[rsp], rax
$LN19@del:
$LN5@del:
$LN8@del:

; 164  : 				case eAlloc_Type_none: break;
; 165  : 				case eAlloc_Type_MemPool: break;
; 166  : 				}
; 167  : 			}
; 168  : 			_DEL(i);

  00191	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00195	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0019d	e8 00 00 00 00	 call	 ?_DEL@CSList@@AEAAXH@Z	; CSList::_DEL

; 169  : //			_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 170  : 			return true;

  001a2	b0 01		 mov	 al, 1
  001a4	eb 48		 jmp	 SHORT $LN1@del
$LN7@del:

; 171  : 		}
; 172  : 	}

  001a6	e9 75 fe ff ff	 jmp	 $LN2@del
$LN3@del:

; 173  : 	gs_cLogger.DebugLog(LEVEL_ERROR, " del FAIL! i[%d] m_nMax[%d]", i, m_nMax);

  001ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001b6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001ba	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  001be	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44585
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	41 b9 ad 00 00
	00		 mov	 r9d, 173		; 000000adH
  001d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44586
  001db	ba 05 00 00 00	 mov	 edx, 5
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  001e7	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 174  : 	return false;

  001ec	32 c0		 xor	 al, al
$LN1@del:

; 175  : }

  001ee	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001f5	c3		 ret	 0
?del@CSList@@QEAA_NPEAX_N@Z ENDP			; CSList::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ?push_back@CSList@@QEAA_NPEAXPEAH@Z
_TEXT	SEGMENT
nIdx$ = 64
i$ = 68
this$ = 96
Obj$ = 104
pIdx$ = 112
?push_back@CSList@@QEAA_NPEAXPEAH@Z PROC		; CSList::push_back, COMDAT

; 119  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 120  : 	int nIdx, i;
; 121  : 
; 122  : 	if (m_nUse >= m_nMax) {

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00020	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00023	7c 4b		 jl	 SHORT $LN5@push_back

; 123  : 		if (!__alloc(m_nMax + UNIT_ADD_SIZE)) return false;

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0002a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002d	83 c0 0a	 add	 eax, 10
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?__alloc@CSList@@AEAAHH@Z ; CSList::__alloc
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN6@push_back
  00040	32 c0		 xor	 al, al
  00042	e9 5c 01 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 124  : 		nIdx = m_nMax;

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004f	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax

; 125  : 		m_nMax += UNIT_ADD_SIZE;

  00053	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0005b	83 c0 0a	 add	 eax, 10
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 126  : 		goto ADD_SUCCESS;

  00066	e9 e9 00 00 00	 jmp	 $LN7@push_back
  0006b	e9 e4 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN5@push_back:

; 127  : 	}
; 128  : 
; 129  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00070	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00079	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	75 16		 jne	 SHORT $LN8@push_back
  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00090	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax
  00094	e9 bb 00 00 00	 jmp	 $LN9@push_back
  00099	e9 b6 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN8@push_back:

; 130  : 
; 131  : 	nIdx = m_nLast;

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000a3	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a6	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax

; 132  : 	for (i = 0; i < m_nMax; i++)

  000aa	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b2	eb 0a		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  000b4	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  000b8	ff c0		 inc	 eax
  000ba	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN4@push_back:
  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000c3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c6	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  000ca	7d 3a		 jge	 SHORT $LN3@push_back

; 133  : 	{
; 134  : 		if (nIdx >= m_nMax) nIdx = 0;

  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000d1	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000d4	39 44 24 40	 cmp	 DWORD PTR nIdx$[rsp], eax
  000d8	7c 08		 jl	 SHORT $LN10@push_back
  000da	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR nIdx$[rsp], 0
$LN10@push_back:

; 135  : 		if (!m_pArray[nIdx]) {

  000e2	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000ec	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ef	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000f4	75 04		 jne	 SHORT $LN11@push_back

; 136  : 			goto ADD_SUCCESS;

  000f6	eb 5c		 jmp	 SHORT $LN12@push_back
  000f8	eb 5a		 jmp	 SHORT $ADD_SUCCESS$16
$LN11@push_back:

; 137  : 		}
; 138  : 		nIdx++;

  000fa	8b 44 24 40	 mov	 eax, DWORD PTR nIdx$[rsp]
  000fe	ff c0		 inc	 eax
  00100	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax

; 139  : 	}

  00104	eb ae		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 140  : 	gs_cLogger.DebugLog(LEVEL_ERROR, " i[%d] m_nLast[%d] m_nCurCount[%d]", nIdx, m_nLast, m_nUse);

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0010b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010e	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00117	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0011a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0011e	8b 44 24 40	 mov	 eax, DWORD PTR nIdx$[rsp]
  00122	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44558
  0012d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00132	41 b9 8c 00 00
	00		 mov	 r9d, 140		; 0000008cH
  00138	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44559
  0013f	ba 05 00 00 00	 mov	 edx, 5
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0014b	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 141  : 	return false;

  00150	32 c0		 xor	 al, al
  00152	eb 4f		 jmp	 SHORT $LN1@push_back
$LN7@push_back:
$LN9@push_back:
$LN12@push_back:
$ADD_SUCCESS$16:

; 142  : 
; 143  : ADD_SUCCESS:
; 144  : 	m_nUse++;

  00154	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00159	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0015c	ff c0		 inc	 eax
  0015e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00163	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 145  : 	m_pArray[nIdx] = Obj;

  00166	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0016b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00170	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00173	48 8b 54 24 68	 mov	 rdx, QWORD PTR Obj$[rsp]
  00178	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 146  : 	m_nLast++;

  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00181	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00184	ff c0		 inc	 eax
  00186	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0018b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 147  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 148  : 	if (pIdx) *pIdx = nIdx;

  0018e	48 83 7c 24 70
	00		 cmp	 QWORD PTR pIdx$[rsp], 0
  00194	74 0b		 je	 SHORT $LN13@push_back
  00196	48 8b 44 24 70	 mov	 rax, QWORD PTR pIdx$[rsp]
  0019b	8b 4c 24 40	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0019f	89 08		 mov	 DWORD PTR [rax], ecx
$LN13@push_back:

; 149  : 	return true;

  001a1	b0 01		 mov	 al, 1
$LN1@push_back:

; 150  : }

  001a3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a7	c3		 ret	 0
?push_back@CSList@@QEAA_NPEAXPEAH@Z ENDP		; CSList::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ?add@CSList@@QEAA_NPEAXPEAH@Z
_TEXT	SEGMENT
nIdx$ = 64
i$ = 68
this$ = 96
Obj$ = 104
pIdx$ = 112
?add@CSList@@QEAA_NPEAXPEAH@Z PROC			; CSList::add, COMDAT

; 83   : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 84   : 	int nIdx, i;
; 85   : 
; 86   : 	if (m_nUse >= m_nMax) {

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00020	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00023	7c 4b		 jl	 SHORT $LN5@add

; 87   : 		if (!__alloc(m_nMax + UNIT_ADD_SIZE)) {

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0002a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002d	83 c0 0a	 add	 eax, 10
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?__alloc@CSList@@AEAAHH@Z ; CSList::__alloc
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN6@add

; 88   : 			return false;

  00040	32 c0		 xor	 al, al
  00042	e9 5c 01 00 00	 jmp	 $LN1@add
$LN6@add:

; 89   : 		}
; 90   : 		nIdx = m_nMax;

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004f	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax

; 91   : 		m_nMax += UNIT_ADD_SIZE;

  00053	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0005b	83 c0 0a	 add	 eax, 10
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 92   : 		goto ADD_SUCCESS;

  00066	e9 e9 00 00 00	 jmp	 $LN7@add
  0006b	e9 e4 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN5@add:

; 93   : 	}
; 94   : 
; 95   : 	if (!m_pArray[m_nDelIdx]) { nIdx = m_nDelIdx; goto ADD_SUCCESS; }

  00070	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 63 40 10	 movsxd	 rax, DWORD PTR [rax+16]
  00079	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	75 16		 jne	 SHORT $LN8@add
  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00090	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax
  00094	e9 bb 00 00 00	 jmp	 $LN9@add
  00099	e9 b6 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN8@add:

; 96   : 
; 97   : 	nIdx = m_nLast;

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000a3	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a6	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax

; 98   : 	for (i = 0; i < m_nMax; i++)

  000aa	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b2	eb 0a		 jmp	 SHORT $LN4@add
$LN2@add:
  000b4	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  000b8	ff c0		 inc	 eax
  000ba	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN4@add:
  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000c3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c6	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  000ca	7d 3a		 jge	 SHORT $LN3@add

; 99   : 	{
; 100  : 		if (nIdx >= m_nMax) nIdx = 0;

  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000d1	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000d4	39 44 24 40	 cmp	 DWORD PTR nIdx$[rsp], eax
  000d8	7c 08		 jl	 SHORT $LN10@add
  000da	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR nIdx$[rsp], 0
$LN10@add:

; 101  : 		if (!m_pArray[nIdx]) {

  000e2	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000ec	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ef	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000f4	75 04		 jne	 SHORT $LN11@add

; 102  : 			goto ADD_SUCCESS;

  000f6	eb 5c		 jmp	 SHORT $LN12@add
  000f8	eb 5a		 jmp	 SHORT $ADD_SUCCESS$16
$LN11@add:

; 103  : 		}
; 104  : 		nIdx++;

  000fa	8b 44 24 40	 mov	 eax, DWORD PTR nIdx$[rsp]
  000fe	ff c0		 inc	 eax
  00100	89 44 24 40	 mov	 DWORD PTR nIdx$[rsp], eax

; 105  : 	}

  00104	eb ae		 jmp	 SHORT $LN2@add
$LN3@add:

; 106  : 	gs_cLogger.DebugLog(LEVEL_ERROR, _T("i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0010b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010e	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00117	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0011a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0011e	8b 44 24 40	 mov	 eax, DWORD PTR nIdx$[rsp]
  00122	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44536
  0012d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00132	41 b9 6a 00 00
	00		 mov	 r9d, 106		; 0000006aH
  00138	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44537
  0013f	ba 05 00 00 00	 mov	 edx, 5
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0014b	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 107  : 	return false;

  00150	32 c0		 xor	 al, al
  00152	eb 4f		 jmp	 SHORT $LN1@add
$LN7@add:
$LN9@add:
$LN12@add:
$ADD_SUCCESS$16:

; 108  : 
; 109  : ADD_SUCCESS:
; 110  : 	m_nUse++;

  00154	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00159	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0015c	ff c0		 inc	 eax
  0015e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00163	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 111  : 	m_pArray[nIdx] = Obj;

  00166	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0016b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00170	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00173	48 8b 54 24 68	 mov	 rdx, QWORD PTR Obj$[rsp]
  00178	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 112  : 	m_nLast++;

  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00181	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00184	ff c0		 inc	 eax
  00186	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  0018b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 113  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 114  : 	if (pIdx) *pIdx = nIdx;

  0018e	48 83 7c 24 70
	00		 cmp	 QWORD PTR pIdx$[rsp], 0
  00194	74 0b		 je	 SHORT $LN13@add
  00196	48 8b 44 24 70	 mov	 rax, QWORD PTR pIdx$[rsp]
  0019b	8b 4c 24 40	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0019f	89 08		 mov	 DWORD PTR [rax], ecx
$LN13@add:

; 115  : 	return true;

  001a1	b0 01		 mov	 al, 1
$LN1@add:

; 116  : }

  001a3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a7	c3		 ret	 0
?add@CSList@@QEAA_NPEAXPEAH@Z ENDP			; CSList::add
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ?clear@CSList@@QEAAXXZ
_TEXT	SEGMENT
p$1 = 32
tv75 = 40
tv144 = 48
$T2 = 56
$T3 = 64
tv79 = 72
tv143 = 80
tv90 = 88
tv134 = 96
idx$4 = 104
__$ArrayPad$ = 112
this$ = 144
?clear@CSList@@QEAAXXZ PROC				; CSList::clear, COMDAT

; 41   : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 42   : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0001c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00024	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00027	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 56 01 00
	00		 je	 $LN6@clear

; 43   : 		int idx = 0;

  00037	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR idx$4[rsp], 0

; 44   : 		void *p = getNext(&idx);

  0003f	48 8d 54 24 68	 lea	 rdx, QWORD PTR idx$4[rsp]
  00044	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	e8 00 00 00 00	 call	 ?getNext@CSList@@QEAAPEAXPEAH@Z ; CSList::getNext
  00051	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax
$LN2@clear:

; 45   : 		while (p) {

  00056	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$1[rsp], 0
  0005c	0f 84 2b 01 00
	00		 je	 $LN3@clear

; 46   : 			idx++;

  00062	8b 44 24 68	 mov	 eax, DWORD PTR idx$4[rsp]
  00066	ff c0		 inc	 eax
  00068	89 44 24 68	 mov	 DWORD PTR idx$4[rsp], eax

; 47   : 			switch (m_nObjAllocType) {

  0006c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00074	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00077	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
  0007b	83 7c 24 28 02	 cmp	 DWORD PTR tv75[rsp], 2
  00080	74 1e		 je	 SHORT $LN7@clear
  00082	83 7c 24 28 03	 cmp	 DWORD PTR tv75[rsp], 3
  00087	74 58		 je	 SHORT $LN8@clear
  00089	83 7c 24 28 04	 cmp	 DWORD PTR tv75[rsp], 4
  0008e	74 61		 je	 SHORT $LN9@clear
  00090	83 7c 24 28 05	 cmp	 DWORD PTR tv75[rsp], 5
  00095	0f 84 9c 00 00
	00		 je	 $LN10@clear
  0009b	e9 d1 00 00 00	 jmp	 $LN4@clear
$LN7@clear:

; 48   : 			case eAlloc_Type_new:	delete p; break;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  000a5	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000aa	33 d2		 xor	 edx, edx
  000ac	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000b1	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000b6	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000bc	75 0b		 jne	 SHORT $LN14@clear
  000be	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  000c7	eb 13		 jmp	 SHORT $LN15@clear
$LN14@clear:
  000c9	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$1[rsp], 33059 ; 00008123H
  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  000d7	48 89 44 24 48	 mov	 QWORD PTR tv79[rsp], rax
$LN15@clear:
  000dc	e9 90 00 00 00	 jmp	 $LN4@clear
$LN8@clear:

; 49   : 			case eAlloc_Type_alloc:	free(p); break;

  000e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$1[rsp]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000ec	e9 80 00 00 00	 jmp	 $LN4@clear
$LN9@clear:

; 50   : 			case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  000f6	48 89 44 24 50	 mov	 QWORD PTR tv143[rsp], rax
  000fb	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv144[rsp], -1
$LL18@clear:
  00104	48 ff 44 24 30	 inc	 QWORD PTR tv144[rsp]
  00109	48 8b 44 24 50	 mov	 rax, QWORD PTR tv143[rsp]
  0010e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv144[rsp]
  00113	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00117	75 eb		 jne	 SHORT $LL18@clear
  00119	48 8b 44 24 30	 mov	 rax, QWORD PTR tv144[rsp]
  0011e	48 ff c0	 inc	 rax
  00121	44 8b c0	 mov	 r8d, eax
  00124	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$1[rsp]
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00130	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00135	eb 3a		 jmp	 SHORT $LN4@clear
$LN10@clear:

; 51   : 			case eAlloc_Type_newArray:	delete[] p; break;

  00137	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  0013c	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  00146	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  0014b	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00151	75 0b		 jne	 SHORT $LN16@clear
  00153	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  0015c	eb 13		 jmp	 SHORT $LN17@clear
$LN16@clear:
  0015e	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$1[rsp], 33059 ; 00008123H
  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  0016c	48 89 44 24 58	 mov	 QWORD PTR tv90[rsp], rax
$LN17@clear:
$LN4@clear:

; 52   : 			case eAlloc_Type_none: break;
; 53   : 			case eAlloc_Type_MemPool: break;
; 54   : 			}
; 55   : 			p = getNext(&idx);

  00171	48 8d 54 24 68	 lea	 rdx, QWORD PTR idx$4[rsp]
  00176	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0017e	e8 00 00 00 00	 call	 ?getNext@CSList@@QEAAPEAXPEAH@Z ; CSList::getNext
  00183	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax

; 56   : 		}

  00188	e9 c9 fe ff ff	 jmp	 $LN2@clear
$LN3@clear:
$LN6@clear:

; 57   : 	}
; 58   : 	memset(m_pArray, 0, sizeof(void *) * m_nMax);

  0018d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00195	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00199	48 c1 e0 03	 shl	 rax, 3
  0019d	48 89 44 24 60	 mov	 QWORD PTR tv134[rsp], rax
  001a2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001aa	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  001ad	33 c0		 xor	 eax, eax
  001af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv134[rsp]
  001b4	f3 aa		 rep stosb

; 59   : 	m_nUse = 0;

  001b6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001be	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 60   : 	m_nLast = 0;

  001c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001cd	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 61   : 	m_nDelIdx = 0;

  001d4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001dc	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 62   : }

  001e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e8	48 33 cc	 xor	 rcx, rsp
  001eb	e8 00 00 00 00	 call	 __security_check_cookie
  001f0	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001f7	5f		 pop	 rdi
  001f8	c3		 ret	 0
?clear@CSList@@QEAAXXZ ENDP				; CSList::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ??1CSList@@QEAA@XZ
_TEXT	SEGMENT
p$1 = 32
tv77 = 40
tv138 = 48
$T2 = 56
$T3 = 64
tv81 = 72
tv137 = 80
tv92 = 88
$T4 = 96
idx$5 = 104
__$ArrayPad$ = 112
this$ = 144
??1CSList@@QEAA@XZ PROC					; CSList::~CSList, COMDAT

; 16   : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000c	48 c7 44 24 60
	fe ff ff ff	 mov	 QWORD PTR $T4[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 17   : 	if (!m_pArray) return;

  00024	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00030	75 05		 jne	 SHORT $LN6@CSList
  00032	e9 99 01 00 00	 jmp	 $LN1@CSList
$LN6@CSList:

; 18   : 
; 19   : 	if (ISABLETODELETE(m_nObjAllocType)) {

  00037	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0003f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00042	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  00047	90		 npad	 1
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 5c 01 00
	00		 je	 $LN7@CSList

; 20   : 		int idx = 0;

  00053	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR idx$5[rsp], 0

; 21   : 		void *p = getNext(&idx);

  0005b	48 8d 54 24 68	 lea	 rdx, QWORD PTR idx$5[rsp]
  00060	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00068	e8 00 00 00 00	 call	 ?getNext@CSList@@QEAAPEAXPEAH@Z ; CSList::getNext
  0006d	90		 npad	 1
  0006e	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax
$LN2@CSList:

; 22   : 		while (p) {

  00073	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$1[rsp], 0
  00079	0f 84 30 01 00
	00		 je	 $LN7@CSList

; 23   : 			idx++;

  0007f	8b 44 24 68	 mov	 eax, DWORD PTR idx$5[rsp]
  00083	ff c0		 inc	 eax
  00085	89 44 24 68	 mov	 DWORD PTR idx$5[rsp], eax

; 24   : 			switch (m_nObjAllocType) {

  00089	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00091	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00094	89 44 24 28	 mov	 DWORD PTR tv77[rsp], eax
  00098	83 7c 24 28 02	 cmp	 DWORD PTR tv77[rsp], 2
  0009d	74 1e		 je	 SHORT $LN8@CSList
  0009f	83 7c 24 28 03	 cmp	 DWORD PTR tv77[rsp], 3
  000a4	74 59		 je	 SHORT $LN9@CSList
  000a6	83 7c 24 28 04	 cmp	 DWORD PTR tv77[rsp], 4
  000ab	74 63		 je	 SHORT $LN10@CSList
  000ad	83 7c 24 28 05	 cmp	 DWORD PTR tv77[rsp], 5
  000b2	0f 84 9f 00 00
	00		 je	 $LN11@CSList
  000b8	e9 d5 00 00 00	 jmp	 $LN4@CSList
$LN8@CSList:

; 25   : 			case eAlloc_Type_new:	delete p; break;

  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  000c2	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000c7	33 d2		 xor	 edx, edx
  000c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000ce	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000d3	90		 npad	 1
  000d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000da	75 0b		 jne	 SHORT $LN15@CSList
  000dc	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
  000e5	eb 13		 jmp	 SHORT $LN16@CSList
$LN15@CSList:
  000e7	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$1[rsp], 33059 ; 00008123H
  000f0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  000f5	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
$LN16@CSList:
  000fa	e9 93 00 00 00	 jmp	 $LN4@CSList
$LN9@CSList:

; 26   : 			case eAlloc_Type_alloc:	free(p); break;

  000ff	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$1[rsp]
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0010a	90		 npad	 1
  0010b	e9 82 00 00 00	 jmp	 $LN4@CSList
$LN10@CSList:

; 27   : 			case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  00115	48 89 44 24 50	 mov	 QWORD PTR tv137[rsp], rax
  0011a	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv138[rsp], -1
$LL19@CSList:
  00123	48 ff 44 24 30	 inc	 QWORD PTR tv138[rsp]
  00128	48 8b 44 24 50	 mov	 rax, QWORD PTR tv137[rsp]
  0012d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv138[rsp]
  00132	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00136	75 eb		 jne	 SHORT $LL19@CSList
  00138	48 8b 44 24 30	 mov	 rax, QWORD PTR tv138[rsp]
  0013d	48 ff c0	 inc	 rax
  00140	44 8b c0	 mov	 r8d, eax
  00143	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$1[rsp]
  00148	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0014f	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00154	90		 npad	 1
  00155	eb 3b		 jmp	 SHORT $LN4@CSList
$LN11@CSList:

; 28   : 			case eAlloc_Type_newArray:	delete[] p; break;

  00157	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  0015c	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00161	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  00166	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  0016b	90		 npad	 1
  0016c	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00172	75 0b		 jne	 SHORT $LN17@CSList
  00174	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv92[rsp], 0
  0017d	eb 13		 jmp	 SHORT $LN4@CSList
$LN17@CSList:
  0017f	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$1[rsp], 33059 ; 00008123H
  00188	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  0018d	48 89 44 24 58	 mov	 QWORD PTR tv92[rsp], rax
$LN4@CSList:

; 29   : 			case eAlloc_Type_none: break;
; 30   : 			case eAlloc_Type_MemPool: break;
; 31   : 			}
; 32   : 			p = getNext(&idx);

  00192	48 8d 54 24 68	 lea	 rdx, QWORD PTR idx$5[rsp]
  00197	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0019f	e8 00 00 00 00	 call	 ?getNext@CSList@@QEAAPEAXPEAH@Z ; CSList::getNext
  001a4	90		 npad	 1
  001a5	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax

; 33   : 		}

  001aa	e9 c4 fe ff ff	 jmp	 $LN2@CSList
$LN7@CSList:

; 34   : 	}
; 35   : 
; 36   : 	free(m_pArray);

  001af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001c0	90		 npad	 1

; 37   : 	m_pArray = 0;

  001c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c9	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@CSList:

; 38   : }

  001d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d5	48 33 cc	 xor	 rcx, rsp
  001d8	e8 00 00 00 00	 call	 __security_check_cookie
  001dd	90		 npad	 1
  001de	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001e5	c3		 ret	 0
??1CSList@@QEAA@XZ ENDP					; CSList::~CSList
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comlist.cpp
;	COMDAT ??0CSList@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0CSList@@QEAA@XZ PROC					; CSList::CSList, COMDAT

; 6    : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 7    : 	m_pArray = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 8    : 	m_nUse = 0;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 9    : 	m_nLast = 0;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00022	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 10   : 	m_nDelIdx = 0;

  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 11   : 	m_nMax = 0;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 12   : 	m_nObjAllocType = eAlloc_Type_none;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 13   : }

  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00052	c3		 ret	 0
??0CSList@@QEAA@XZ ENDP					; CSList::CSList
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
pBuf$ = 72
nSize$ = 80
?delBuf@CMemManager@@QEAAXPEADH@Z PROC			; CMemManager::delBuf, COMDAT

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR nSize$[rsp]
  00017	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0001c	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00020	44 8b 44 24 20	 mov	 r8d, DWORD PTR nIdx$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?delBuf@CMemManager@@QEAAXPEADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = 0
m$ = 4
tv80 = 8
$S1$ = 16
s$ = 48
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	f2 0f 2a 44 24
	30		 cvtsi2sd xmm0, DWORD PTR s$[rsp]
  0000e	f2 0f 11 44 24
	10		 movsd	 QWORD PTR $S1$[rsp], xmm0
  00014	b8 04 00 00 00	 mov	 eax, 4
  00019	48 6b c0 01	 imul	 rax, rax, 1
  0001d	8b 44 04 10	 mov	 eax, DWORD PTR $S1$[rsp+rax]
  00021	c1 f8 14	 sar	 eax, 20
  00024	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  00029	89 44 24 04	 mov	 DWORD PTR m$[rsp], eax
  0002d	8b 44 24 04	 mov	 eax, DWORD PTR m$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	89 4c 24 08	 mov	 DWORD PTR tv80[rsp], ecx
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR tv80[rsp]
  00041	d3 e0		 shl	 eax, cl
  00043	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  0004f	23 c8		 and	 ecx, eax
  00051	8b c1		 mov	 eax, ecx
  00053	85 c0		 test	 eax, eax
  00055	74 09		 je	 SHORT $LN3@getIndex
  00057	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  0005e	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN4@getIndex:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR m$[rsp]
  0006e	03 c8		 add	 ecx, eax
  00070	8b c1		 mov	 eax, ecx
  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
i$ = 8
max$ = 16
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	83 7c 24 08 00	 cmp	 DWORD PTR i$[rsp], 0
  0000d	7c 0e		 jl	 SHORT $LN2@ISINCLUDE
  0000f	8b 44 24 10	 mov	 eax, DWORD PTR max$[rsp]
  00013	39 44 24 08	 cmp	 DWORD PTR i$[rsp], eax
  00017	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  00019	b0 01		 mov	 al, 1
  0001b	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  0001d	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  0001f	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
e$ = 8
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z PROC		; ISABLETODELETE, COMDAT

; 247  : inline bool ISABLETODELETE(E_ALLOC_TYPE e) { if (eAlloc_Type_MemPool < e) return true; return false; }

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	83 7c 24 08 01	 cmp	 DWORD PTR e$[rsp], 1
  00009	7e 04		 jle	 SHORT $LN2@ISABLETODE
  0000b	b0 01		 mov	 al, 1
  0000d	eb 02		 jmp	 SHORT $LN1@ISABLETODE
$LN2@ISABLETODE:
  0000f	32 c0		 xor	 al, al
$LN1@ISABLETODE:
  00011	c3		 ret	 0
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ENDP		; ISABLETODELETE
_TEXT	ENDS
END
