; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG8594	DB	'%s hashMap key distribution m_nMaxCount[%d]', 0aH, 00H
	ORG $+3
$SG8596	DB	' --- m_pHashData[%d] useCount[%d]', 0aH, 00H
	ORG $+5
$SG8599	DB	' m_nMaxCount[%d] usedKeyCount[%d]', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	_tcsncpy
PUBLIC	_tcscmp
PUBLIC	??0CHash@@QEAA@I@Z				; CHash::CHash
PUBLIC	??1CHash@@QEAA@XZ				; CHash::~CHash
PUBLIC	?clear@CHash@@QEAAXXZ				; CHash::clear
PUBLIC	?getHashNo@CHash@@QEAAIPEAD@Z			; CHash::getHashNo
PUBLIC	?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z	; CHash::hashLookup
PUBLIC	?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z	; CHash::hashLookup
PUBLIC	?getNext@CHash@@QEAAPEAUSThash_next@@I@Z	; CHash::getNext
PUBLIC	?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z	; CHash::getNext
PUBLIC	?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ; CHash::getNode
PUBLIC	?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z ; CHash::setValue
PUBLIC	?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z ; CHash::setValue
PUBLIC	?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::addNode
PUBLIC	?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::uniqueAddNode
PUBLIC	?getString@CHash@@QEAA_KPEAD0I@Z		; CHash::getString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	memset:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp__mbscmp:PROC
EXTRN	__imp__mbsnbcpy:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+4
	DD	imagerel $unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tcsncpy DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_tcsncpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tcscmp DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$_tcscmp
pdata	ENDS
pdata	SEGMENT
$pdata$??0CHash@@QEAA@I@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$??0CHash@@QEAA@I@Z
$pdata$??1CHash@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??1CHash@@QEAA@XZ
$pdata$?clear@CHash@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?clear@CHash@@QEAAXXZ
$pdata$?getHashNo@CHash@@QEAAIPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+150
	DD	imagerel $unwind$?getHashNo@CHash@@QEAAIPEAD@Z
$pdata$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z
$pdata$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+146
	DD	imagerel $unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z
$pdata$?getNext@CHash@@QEAAPEAUSThash_next@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?getNext@CHash@@QEAAPEAUSThash_next@@I@Z
$pdata$?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z
$pdata$?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z DD imagerel $LN7
	DD	imagerel $LN7+190
	DD	imagerel $unwind$?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z
$pdata$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z
$pdata$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z DD imagerel $LN7
	DD	imagerel $LN7+148
	DD	imagerel $unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z
$pdata$?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+336
	DD	imagerel $unwind$?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z
$pdata$?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD imagerel $LN10
	DD	imagerel $LN10+368
	DD	imagerel $unwind$?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z
$pdata$?getString@CHash@@QEAA_KPEAD0I@Z DD imagerel $LN14
	DD	imagerel $LN14+769
	DD	imagerel $unwind$?getString@CHash@@QEAA_KPEAD0I@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+1
?getString@CHash@@QEAA_KPEAD0I@Z$rtcName$0 DB 073H	; CHash::getString
	DB	07aH
	DB	042H
	DB	075H
	DB	066H
	DB	00H
	ORG $+2
?getString@CHash@@QEAA_KPEAD0I@Z$rtcName$1 DB 073H	; CHash::getString
	DB	07aH
	DB	055H
	DB	06eH
	DB	069H
	DB	074H
	DB	00H
	ORG $+5
?getString@CHash@@QEAA_KPEAD0I@Z$rtcVarDesc DD 01060H	; CHash::getString
	DD	0200H
	DQ	FLAT:?getString@CHash@@QEAA_KPEAD0I@Z$rtcName$1
	DD	040H
	DD	01000H
	DQ	FLAT:?getString@CHash@@QEAA_KPEAD0I@Z$rtcName$0
	ORG $+96
?getString@CHash@@QEAA_KPEAD0I@Z$rtcFrameData DD 02H	; CHash::getString
	DD	00H
	DQ	FLAT:?getString@CHash@@QEAA_KPEAD0I@Z$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$??0CHash@@QEAA@I@Z DD 022201H
	DD	0700a320eH
$unwind$??1CHash@@QEAA@XZ DD 021e01H
	DD	07006320aH
$unwind$?clear@CHash@@QEAAXXZ DD 021e01H
	DD	07006320aH
$unwind$?getHashNo@CHash@@QEAAIPEAD@Z DD 022301H
	DD	0700b520fH
$unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z DD 022301H
	DD	0700b520fH
$unwind$?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z DD 022701H
	DD	0700f5213H
$unwind$?getNext@CHash@@QEAAPEAUSThash_next@@I@Z DD 010a01H
	DD	0700aH
$unwind$?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z DD 022301H
	DD	0700b520fH
$unwind$?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z DD 022801H
	DD	070105214H
$unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z DD 022801H
	DD	070105214H
$unwind$?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z DD 022c01H
	DD	070145218H
$unwind$?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD 022d01H
	DD	070155219H
$unwind$?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z DD 022d01H
	DD	070155219H
$unwind$?getString@CHash@@QEAA_KPEAD0I@Z DD 034b19H
	DD	02520122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	01280H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tcscmp DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tcsncpy DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 023c19H
	DD	07015b219H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNext$ = 32
szBuf$ = 64
szUnit$ = 4192
i$ = 4708
j$ = 4712
nNextPos$ = 4716
nStrSize$ = 4720
nUseCount$ = 4724
__$ArrayPad$ = 4736
this$ = 4768
pTitle$ = 4776
pBuf$ = 4784
nBufMax$ = 4792
?getString@CHash@@QEAA_KPEAD0I@Z PROC			; CHash::getString

; 176  : {

$LN14:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	b8 90 12 00 00	 mov	 eax, 4752		; 00001290H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 a4 04 00 00	 mov	 ecx, 1188		; 000004a4H
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 a0
	12 00 00	 mov	 rcx, QWORD PTR [rsp+4768]
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00040	48 33 c4	 xor	 rax, rsp
  00043	48 89 84 24 80
	12 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 177  : 	/*
; 178  : 	TCHAR szBuf[128];
; 179  : 	size_t nSize[5];
; 180  : 	memset(nSize, 0, sizeof(nSize));
; 181  : 	int i, cnt = 0;
; 182  : 	nSize[cnt++] = sizeof(m_pHashData);
; 183  : 	nSize[cnt++] = sizeof(SThash_value);
; 184  : 	_stprintf(szBuf, _T("%s m_pHashData's size:%ul maxCount:%d, unitSize:%d\n"), pTitle, nSize[0], m_nMaxCount, nSize[1]);
; 185  : 	_tcscpy(pBuf, szBuf);
; 186  : 	for (i = 0; i < cnt; i++)
; 187  : 	{
; 188  : 		nSize[4] += nSize[i];
; 189  : 	}
; 190  : 	return nSize[4];
; 191  : 	*/
; 192  : 
; 193  : 	SThash_next *pNext;
; 194  : 	TCHAR szBuf[4096], szUnit[512];
; 195  : 	unsigned int i,j, nNextPos=0, nStrSize, nUseCount=0;

  0004b	c7 84 24 6c 12
	00 00 00 00 00
	00		 mov	 DWORD PTR nNextPos$[rsp], 0
  00056	c7 84 24 74 12
	00 00 00 00 00
	00		 mov	 DWORD PTR nUseCount$[rsp], 0

; 196  : 
; 197  : 	_stprintf(szUnit, _T("%s hashMap key distribution m_nMaxCount[%d]\n"), pTitle, m_nMaxCount);

  00061	48 8b 84 24 a0
	12 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00069	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  0006c	4c 8b 84 24 a8
	12 00 00	 mov	 r8, QWORD PTR pTitle$[rsp]
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8594
  0007b	48 8d 8c 24 60
	10 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  00083	e8 00 00 00 00	 call	 sprintf

; 198  : 	nStrSize = (int)_tcslen(szUnit);

  00088	48 8d 8c 24 60
	10 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  00090	e8 00 00 00 00	 call	 strlen
  00095	89 84 24 70 12
	00 00		 mov	 DWORD PTR nStrSize$[rsp], eax

; 199  : 	_tcscpy(szBuf + nNextPos, szUnit);

  0009c	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]
  000a3	48 8d 44 04 40	 lea	 rax, QWORD PTR szBuf$[rsp+rax]
  000a8	48 8d 94 24 60
	10 00 00	 lea	 rdx, QWORD PTR szUnit$[rsp]
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	e8 00 00 00 00	 call	 strcpy

; 200  : 	nNextPos += nStrSize;

  000b8	8b 84 24 70 12
	00 00		 mov	 eax, DWORD PTR nStrSize$[rsp]
  000bf	8b 8c 24 6c 12
	00 00		 mov	 ecx, DWORD PTR nNextPos$[rsp]
  000c6	03 c8		 add	 ecx, eax
  000c8	8b c1		 mov	 eax, ecx
  000ca	89 84 24 6c 12
	00 00		 mov	 DWORD PTR nNextPos$[rsp], eax

; 201  : 
; 202  : 	for (i = 0; i < m_nMaxCount; i++)

  000d1	c7 84 24 64 12
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  000dc	eb 10		 jmp	 SHORT $LN4@getString
$LN2@getString:
  000de	8b 84 24 64 12
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  000e5	ff c0		 inc	 eax
  000e7	89 84 24 64 12
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@getString:
  000ee	48 8b 84 24 a0
	12 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000f6	8b 00		 mov	 eax, DWORD PTR [rax]
  000f8	39 84 24 64 12
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  000ff	0f 83 0b 01 00
	00		 jae	 $LN3@getString

; 203  : 	{
; 204  : 		j = 0;

  00105	c7 84 24 68 12
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0

; 205  : 		for (pNext = m_pHashData[i].pNext; pNext != NULL; pNext = pNext->next) { j++; }

  00110	8b 84 24 64 12
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00117	48 6b c0 10	 imul	 rax, rax, 16
  0011b	48 8b 8c 24 a0
	12 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00123	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00127	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0012c	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
  00131	eb 0e		 jmp	 SHORT $LN7@getString
$LN5@getString:
  00133	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00138	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013c	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
$LN7@getString:
  00141	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00147	74 12		 je	 SHORT $LN6@getString
  00149	8b 84 24 68 12
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 84 24 68 12
	00 00		 mov	 DWORD PTR j$[rsp], eax
  00159	eb d8		 jmp	 SHORT $LN5@getString
$LN6@getString:

; 206  : 		if (j) {

  0015b	83 bc 24 68 12
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  00163	0f 84 a2 00 00
	00		 je	 $LN8@getString

; 207  : 			_stprintf(szUnit, _T(" --- m_pHashData[%d] useCount[%d]\n"), i, j);

  00169	44 8b 8c 24 68
	12 00 00	 mov	 r9d, DWORD PTR j$[rsp]
  00171	44 8b 84 24 64
	12 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8596
  00180	48 8d 8c 24 60
	10 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  00188	e8 00 00 00 00	 call	 sprintf

; 208  : 			nStrSize = (int)_tcslen(szUnit);

  0018d	48 8d 8c 24 60
	10 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  00195	e8 00 00 00 00	 call	 strlen
  0019a	89 84 24 70 12
	00 00		 mov	 DWORD PTR nStrSize$[rsp], eax

; 209  : 			if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  001a1	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]
  001a8	8b 8c 24 70 12
	00 00		 mov	 ecx, DWORD PTR nStrSize$[rsp]
  001af	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  001b3	39 84 24 b8 12
	00 00		 cmp	 DWORD PTR nBufMax$[rsp], eax
  001ba	73 0a		 jae	 SHORT $LN9@getString
  001bc	e9 de 00 00 00	 jmp	 $LN10@getString
  001c1	e9 d9 00 00 00	 jmp	 $ENDPROC$15
$LN9@getString:

; 210  : 			_tcscpy(szBuf+nNextPos, szUnit);

  001c6	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]
  001cd	48 8d 44 04 40	 lea	 rax, QWORD PTR szBuf$[rsp+rax]
  001d2	48 8d 94 24 60
	10 00 00	 lea	 rdx, QWORD PTR szUnit$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	e8 00 00 00 00	 call	 strcpy

; 211  : 			nNextPos += nStrSize;

  001e2	8b 84 24 70 12
	00 00		 mov	 eax, DWORD PTR nStrSize$[rsp]
  001e9	8b 8c 24 6c 12
	00 00		 mov	 ecx, DWORD PTR nNextPos$[rsp]
  001f0	03 c8		 add	 ecx, eax
  001f2	8b c1		 mov	 eax, ecx
  001f4	89 84 24 6c 12
	00 00		 mov	 DWORD PTR nNextPos$[rsp], eax

; 212  : 
; 213  : 			nUseCount++;

  001fb	8b 84 24 74 12
	00 00		 mov	 eax, DWORD PTR nUseCount$[rsp]
  00202	ff c0		 inc	 eax
  00204	89 84 24 74 12
	00 00		 mov	 DWORD PTR nUseCount$[rsp], eax
$LN8@getString:

; 214  : 		}
; 215  : 	}

  0020b	e9 ce fe ff ff	 jmp	 $LN2@getString
$LN3@getString:

; 216  : 	_stprintf(szUnit, _T(" m_nMaxCount[%d] usedKeyCount[%d]\n"), m_nMaxCount, nUseCount);

  00210	44 8b 8c 24 74
	12 00 00	 mov	 r9d, DWORD PTR nUseCount$[rsp]
  00218	48 8b 84 24 a0
	12 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00220	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00223	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8599
  0022a	48 8d 8c 24 60
	10 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  00232	e8 00 00 00 00	 call	 sprintf

; 217  : 	nStrSize = (int)_tcslen(szUnit);

  00237	48 8d 8c 24 60
	10 00 00	 lea	 rcx, QWORD PTR szUnit$[rsp]
  0023f	e8 00 00 00 00	 call	 strlen
  00244	89 84 24 70 12
	00 00		 mov	 DWORD PTR nStrSize$[rsp], eax

; 218  : 	if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  0024b	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]
  00252	8b 8c 24 70 12
	00 00		 mov	 ecx, DWORD PTR nStrSize$[rsp]
  00259	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0025d	39 84 24 b8 12
	00 00		 cmp	 DWORD PTR nBufMax$[rsp], eax
  00264	73 04		 jae	 SHORT $LN11@getString
  00266	eb 37		 jmp	 SHORT $LN12@getString
  00268	eb 35		 jmp	 SHORT $ENDPROC$15
$LN11@getString:

; 219  : 	_tcscpy(szBuf + nNextPos, szUnit);

  0026a	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]
  00271	48 8d 44 04 40	 lea	 rax, QWORD PTR szBuf$[rsp+rax]
  00276	48 8d 94 24 60
	10 00 00	 lea	 rdx, QWORD PTR szUnit$[rsp]
  0027e	48 8b c8	 mov	 rcx, rax
  00281	e8 00 00 00 00	 call	 strcpy

; 220  : 	nNextPos += nStrSize;

  00286	8b 84 24 70 12
	00 00		 mov	 eax, DWORD PTR nStrSize$[rsp]
  0028d	8b 8c 24 6c 12
	00 00		 mov	 ecx, DWORD PTR nNextPos$[rsp]
  00294	03 c8		 add	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	89 84 24 6c 12
	00 00		 mov	 DWORD PTR nNextPos$[rsp], eax
$LN10@getString:
$LN12@getString:
$ENDPROC$15:

; 221  : 
; 222  : ENDPROC:
; 223  : 	_tcsncpy(pBuf, szBuf, nNextPos);

  0029f	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]
  002a6	44 8b c0	 mov	 r8d, eax
  002a9	48 8d 54 24 40	 lea	 rdx, QWORD PTR szBuf$[rsp]
  002ae	48 8b 8c 24 b0
	12 00 00	 mov	 rcx, QWORD PTR pBuf$[rsp]
  002b6	e8 00 00 00 00	 call	 _tcsncpy

; 224  : 	pBuf[nNextPos] = 0;

  002bb	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]
  002c2	48 8b 8c 24 b0
	12 00 00	 mov	 rcx, QWORD PTR pBuf$[rsp]
  002ca	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 225  : 	return nNextPos;

  002ce	8b 84 24 6c 12
	00 00		 mov	 eax, DWORD PTR nNextPos$[rsp]

; 226  : }

  002d5	8b f8		 mov	 edi, eax
  002d7	48 8b cc	 mov	 rcx, rsp
  002da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?getString@CHash@@QEAA_KPEAD0I@Z$rtcFrameData
  002e1	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  002e6	8b c7		 mov	 eax, edi
  002e8	48 8b 8c 24 80
	12 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002f0	48 33 cc	 xor	 rcx, rsp
  002f3	e8 00 00 00 00	 call	 __security_check_cookie
  002f8	48 81 c4 90 12
	00 00		 add	 rsp, 4752		; 00001290H
  002ff	5f		 pop	 rdi
  00300	c3		 ret	 0
?getString@CHash@@QEAA_KPEAD0I@Z ENDP			; CHash::getString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNextAddr$ = 32
nHashNo$ = 40
this$ = 64
pNext$ = 72
pKey$ = 80
pData$ = 88
?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z PROC ; CHash::uniqueAddNode

; 151  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 152  : 	SThash_next **pNextAddr;
; 153  : 
; 154  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  0002d	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  0003c	89 44 24 28	 mov	 DWORD PTR nHashNo$[rsp], eax

; 155  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00045	8b 00		 mov	 eax, DWORD PTR [rax]
  00047	39 44 24 28	 cmp	 DWORD PTR nHashNo$[rsp], eax
  0004b	72 0a		 jb	 SHORT $LN5@uniqueAddN
  0004d	b8 fd ff ff ff	 mov	 eax, -3
  00052	e9 13 01 00 00	 jmp	 $LN1@uniqueAddN
$LN5@uniqueAddN:

; 156  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00057	48 83 7c 24 48
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  0005d	75 0a		 jne	 SHORT $LN6@uniqueAddN
  0005f	b8 fc ff ff ff	 mov	 eax, -4
  00064	e9 01 01 00 00	 jmp	 $LN1@uniqueAddN
$LN6@uniqueAddN:

; 157  : 
; 158  : 
; 159  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) 

  00069	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0006d	48 6b c0 10	 imul	 rax, rax, 16
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00076	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0007a	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0007f	48 89 44 24 20	 mov	 QWORD PTR pNextAddr$[rsp], rax
  00084	eb 11		 jmp	 SHORT $LN4@uniqueAddN
$LN2@uniqueAddN:
  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 83 c0 10	 add	 rax, 16
  00092	48 89 44 24 20	 mov	 QWORD PTR pNextAddr$[rsp], rax
$LN4@uniqueAddN:
  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  0009c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a0	74 22		 je	 SHORT $LN3@uniqueAddN

; 160  : 	{
; 161  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0) return eHASH_RESULT_DUPLICATE_KEYS;

  000a2	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000a7	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  000af	e8 00 00 00 00	 call	 _tcscmp
  000b4	85 c0		 test	 eax, eax
  000b6	75 0a		 jne	 SHORT $LN7@uniqueAddN
  000b8	b8 ff ff ff ff	 mov	 eax, -1
  000bd	e9 a8 00 00 00	 jmp	 $LN1@uniqueAddN
$LN7@uniqueAddN:

; 162  : 	}

  000c2	eb c2		 jmp	 SHORT $LN2@uniqueAddN
$LN3@uniqueAddN:

; 163  : 
; 164  : 	pNext->pNode.pKey = pKey;

  000c4	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  000ce	48 89 08	 mov	 QWORD PTR [rax], rcx

; 165  : 	pNext->pNode.value = pData;

  000d1	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pData$[rsp]
  000db	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 166  : 	pNext->next = NULL;

  000df	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000e4	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 167  : 	*pNextAddr = pNext;

  000ec	48 8b 44 24 20	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  000f1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pNext$[rsp]
  000f6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 168  : 
; 169  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  000f9	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000fd	48 6b c0 10	 imul	 rax, rax, 16
  00101	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00106	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0010a	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0010e	75 18		 jne	 SHORT $LN8@uniqueAddN
  00110	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00114	48 6b c0 10	 imul	 rax, rax, 16
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0011d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00121	8b 54 24 28	 mov	 edx, DWORD PTR nHashNo$[rsp]
  00125	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
$LN8@uniqueAddN:

; 170  : 	m_pHashData[nHashNo].nElementCnt++;

  00128	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0012c	48 6b c0 10	 imul	 rax, rax, 16
  00130	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00135	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00139	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0013d	ff c0		 inc	 eax
  0013f	8b 4c 24 28	 mov	 ecx, DWORD PTR nHashNo$[rsp]
  00143	48 6b c9 10	 imul	 rcx, rcx, 16
  00147	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  0014c	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00150	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 171  : 	m_nElementCount++;

  00154	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00159	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0015c	ff c0		 inc	 eax
  0015e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00163	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 172  : 	return nHashNo;

  00166	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
$LN1@uniqueAddN:

; 173  : }

  0016a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016e	5f		 pop	 rdi
  0016f	c3		 ret	 0
?uniqueAddNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ENDP ; CHash::uniqueAddNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNextAddr$ = 32
nHashNo$ = 40
this$ = 64
pNext$ = 72
pKey$ = 80
pData$ = 88
?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z PROC	; CHash::addNode

; 129  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 130  : 	SThash_next **pNextAddr;
; 131  : 
; 132  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  0002d	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  0003c	89 44 24 28	 mov	 DWORD PTR nHashNo$[rsp], eax

; 133  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00045	8b 00		 mov	 eax, DWORD PTR [rax]
  00047	39 44 24 28	 cmp	 DWORD PTR nHashNo$[rsp], eax
  0004b	72 0a		 jb	 SHORT $LN5@addNode
  0004d	b8 fd ff ff ff	 mov	 eax, -3
  00052	e9 f3 00 00 00	 jmp	 $LN1@addNode
$LN5@addNode:

; 134  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00057	48 83 7c 24 48
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  0005d	75 0a		 jne	 SHORT $LN6@addNode
  0005f	b8 fc ff ff ff	 mov	 eax, -4
  00064	e9 e1 00 00 00	 jmp	 $LN1@addNode
$LN6@addNode:

; 135  : 
; 136  : 	
; 137  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) {}

  00069	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0006d	48 6b c0 10	 imul	 rax, rax, 16
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00076	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0007a	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0007f	48 89 44 24 20	 mov	 QWORD PTR pNextAddr$[rsp], rax
  00084	eb 11		 jmp	 SHORT $LN4@addNode
$LN2@addNode:
  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 83 c0 10	 add	 rax, 16
  00092	48 89 44 24 20	 mov	 QWORD PTR pNextAddr$[rsp], rax
$LN4@addNode:
  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  0009c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a0	74 02		 je	 SHORT $LN3@addNode
  000a2	eb e2		 jmp	 SHORT $LN2@addNode
$LN3@addNode:

; 138  : 	pNext->pNode.pKey = pKey;

  000a4	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  000ae	48 89 08	 mov	 QWORD PTR [rax], rcx

; 139  : 	pNext->pNode.value = pData;

  000b1	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pData$[rsp]
  000bb	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 140  : 	pNext->next = NULL;

  000bf	48 8b 44 24 48	 mov	 rax, QWORD PTR pNext$[rsp]
  000c4	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 141  : 	*pNextAddr = pNext;

  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR pNextAddr$[rsp]
  000d1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pNext$[rsp]
  000d6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  : 
; 143  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  000d9	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000dd	48 6b c0 10	 imul	 rax, rax, 16
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e6	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ea	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  000ee	75 18		 jne	 SHORT $LN7@addNode
  000f0	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  000f4	48 6b c0 10	 imul	 rax, rax, 16
  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000fd	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00101	8b 54 24 28	 mov	 edx, DWORD PTR nHashNo$[rsp]
  00105	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
$LN7@addNode:

; 144  : 	m_pHashData[nHashNo].nElementCnt++;

  00108	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0010c	48 6b c0 10	 imul	 rax, rax, 16
  00110	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00115	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00119	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0011d	ff c0		 inc	 eax
  0011f	8b 4c 24 28	 mov	 ecx, DWORD PTR nHashNo$[rsp]
  00123	48 6b c9 10	 imul	 rcx, rcx, 16
  00127	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  0012c	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00130	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 145  : 	m_nElementCount++;

  00134	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00139	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0013c	ff c0		 inc	 eax
  0013e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00143	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 146  : 	return nHashNo;

  00146	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
$LN1@addNode:

; 147  : }

  0014a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014e	5f		 pop	 rdi
  0014f	c3		 ret	 0
?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ENDP	; CHash::addNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNext$ = 32
this$ = 64
nHashNo$ = 72
pKey$ = 80
pData$ = 88
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z PROC ; CHash::setValue

; 111  : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 112  : 	SThash_next *pNext;
; 113  : 
; 114  : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  0002c	8b 44 24 48	 mov	 eax, DWORD PTR nHashNo$[rsp]
  00030	48 6b c0 10	 imul	 rax, rax, 16
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00039	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003d	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00042	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
  00047	eb 0e		 jmp	 SHORT $LN4@setValue
$LN2@setValue:
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  0004e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00052	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@setValue:
  00057	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  0005d	74 2a		 je	 SHORT $LN3@setValue

; 115  : 	{
; 116  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00064	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00067	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  0006c	e8 00 00 00 00	 call	 _tcscmp
  00071	85 c0		 test	 eax, eax
  00073	75 12		 jne	 SHORT $LN5@setValue

; 117  : 		{
; 118  : 			pNext->pNode.value = pData;

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  0007a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pData$[rsp]
  0007f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 119  : 			return eHASH_RESULT_SUCESS;

  00083	33 c0		 xor	 eax, eax
  00085	eb 07		 jmp	 SHORT $LN1@setValue
$LN5@setValue:

; 120  : 		}
; 121  : 	}

  00087	eb c0		 jmp	 SHORT $LN2@setValue
$LN3@setValue:

; 122  : 	return eHASH_RESULT_NOT_FOUND;

  00089	b8 fe ff ff ff	 mov	 eax, -2
$LN1@setValue:

; 123  : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z ENDP ; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNode$ = 32
this$ = 64
pKey$ = 72
pData$ = 80
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z PROC ; CHash::setValue

; 101  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 102  : 	STHash_Node *pNode = hashLookup(pKey);

  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00032	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00037	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 103  : 	if (pNode) {

  0003c	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00042	74 12		 je	 SHORT $LN2@setValue

; 104  : 		pNode->value = pData;

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pData$[rsp]
  0004e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 105  : 		return eHASH_RESULT_SUCESS;

  00052	33 c0		 xor	 eax, eax
  00054	eb 05		 jmp	 SHORT $LN1@setValue
$LN2@setValue:

; 106  : 	}
; 107  : 	return eHASH_RESULT_NOT_FOUND;

  00056	b8 fe ff ff ff	 mov	 eax, -2
$LN1@setValue:

; 108  : }

  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@PEADPEAX@Z ENDP ; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNext$ = 32
nHashNo$ = 40
this$ = 64
pStr$ = 72
prevNext$ = 80
?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z PROC ; CHash::getNode

; 86   : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 87   : 	SThash_next *pNext;
; 88   : 	HASH_TYPE nHashNo = getHashNo(pStr);

  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStr$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00032	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  00037	89 44 24 28	 mov	 DWORD PTR nHashNo$[rsp], eax

; 89   : 
; 90   : 	prevNext = &m_pHashData[nHashNo].pNext;

  0003b	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0003f	48 6b c0 10	 imul	 rax, rax, 16
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00048	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004c	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00051	48 89 44 24 50	 mov	 QWORD PTR prevNext$[rsp], rax

; 91   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00056	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0005a	48 6b c0 10	 imul	 rax, rax, 16
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00067	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0006c	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
  00071	eb 0e		 jmp	 SHORT $LN4@getNode
$LN2@getNode:
  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00078	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007c	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@getNode:
  00081	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00087	74 2d		 je	 SHORT $LN3@getNode

; 92   : 	{
; 93   : 		if (_tcscmp(pStr, pNext->pNode.pKey) == 0) return pNext;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  0008e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00091	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pStr$[rsp]
  00096	e8 00 00 00 00	 call	 _tcscmp
  0009b	85 c0		 test	 eax, eax
  0009d	75 07		 jne	 SHORT $LN5@getNode
  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  000a4	eb 12		 jmp	 SHORT $LN1@getNode
$LN5@getNode:

; 94   : 		prevNext = &(pNext->next);

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  000ab	48 83 c0 10	 add	 rax, 16
  000af	48 89 44 24 50	 mov	 QWORD PTR prevNext$[rsp], rax

; 95   : 	}

  000b4	eb bd		 jmp	 SHORT $LN2@getNode
$LN3@getNode:

; 96   : 
; 97   : 	return NULL;

  000b6	33 c0		 xor	 eax, eax
$LN1@getNode:

; 98   : }

  000b8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ENDP ; CHash::getNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
nHashNo$ = 32
this$ = 64
pStr$ = 72
?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z PROC	; CHash::getNext

; 80   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 81   : 	HASH_TYPE nHashNo = getHashNo(pStr);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStr$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  00032	89 44 24 20	 mov	 DWORD PTR nHashNo$[rsp], eax

; 82   : 	return m_pHashData[nHashNo].pNext;

  00036	8b 44 24 20	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0003a	48 6b c0 10	 imul	 rax, rax, 16
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00043	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00047	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]

; 83   : }

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z ENDP	; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
this$ = 16
nHashKey$ = 24
?getNext@CHash@@QEAAPEAUSThash_next@@I@Z PROC		; CHash::getNext

; 72   : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 73   : 	if (nHashKey >= m_nMaxCount) return NULL;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000f	8b 00		 mov	 eax, DWORD PTR [rax]
  00011	39 44 24 18	 cmp	 DWORD PTR nHashKey$[rsp], eax
  00015	72 04		 jb	 SHORT $LN2@getNext
  00017	33 c0		 xor	 eax, eax
  00019	eb 16		 jmp	 SHORT $LN1@getNext
$LN2@getNext:

; 74   : 
; 75   : 	return m_pHashData[nHashKey].pNext;

  0001b	8b 44 24 18	 mov	 eax, DWORD PTR nHashKey$[rsp]
  0001f	48 6b c0 10	 imul	 rax, rax, 16
  00023	48 8b 4c 24 10	 mov	 rcx, QWORD PTR this$[rsp]
  00028	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002c	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
$LN1@getNext:

; 76   : }

  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ENDP		; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNext$ = 32
this$ = 64
nHashNo$ = 72
pKey$ = 80
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z PROC	; CHash::hashLookup

; 59   : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 60   : 	SThash_next *pNext;
; 61   : 	if(nHashNo >= m_nMaxCount) return NULL;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002c	8b 00		 mov	 eax, DWORD PTR [rax]
  0002e	39 44 24 48	 cmp	 DWORD PTR nHashNo$[rsp], eax
  00032	72 04		 jb	 SHORT $LN5@hashLookup
  00034	33 c0		 xor	 eax, eax
  00036	eb 54		 jmp	 SHORT $LN1@hashLookup
$LN5@hashLookup:

; 62   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00038	8b 44 24 48	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0003c	48 6b c0 10	 imul	 rax, rax, 16
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00045	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00049	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0004e	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
  00053	eb 0e		 jmp	 SHORT $LN4@hashLookup
$LN2@hashLookup:
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@hashLookup:
  00063	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00069	74 1f		 je	 SHORT $LN3@hashLookup

; 63   : 	{
; 64   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00070	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pKey$[rsp]
  00078	e8 00 00 00 00	 call	 _tcscmp
  0007d	85 c0		 test	 eax, eax
  0007f	75 07		 jne	 SHORT $LN6@hashLookup

; 65   : 			return &pNext->pNode;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00086	eb 04		 jmp	 SHORT $LN1@hashLookup
$LN6@hashLookup:

; 66   : 	}

  00088	eb cb		 jmp	 SHORT $LN2@hashLookup
$LN3@hashLookup:

; 67   : 
; 68   : 	return NULL;

  0008a	33 c0		 xor	 eax, eax
$LN1@hashLookup:

; 69   : 
; 70   : }

  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@IPEAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
pNext$ = 32
nHashNo$ = 40
this$ = 64
pKey$ = 72
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z PROC	; CHash::hashLookup

; 43   : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 44   : 	SThash_next *pNext;
; 45   : 	HASH_TYPE nHashNo = getHashNo(pKey);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QEAAIPEAD@Z ; CHash::getHashNo
  00032	89 44 24 28	 mov	 DWORD PTR nHashNo$[rsp], eax

; 46   : 	if(nHashNo >= m_nMaxCount) return NULL;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003b	8b 00		 mov	 eax, DWORD PTR [rax]
  0003d	39 44 24 28	 cmp	 DWORD PTR nHashNo$[rsp], eax
  00041	72 04		 jb	 SHORT $LN5@hashLookup
  00043	33 c0		 xor	 eax, eax
  00045	eb 54		 jmp	 SHORT $LN1@hashLookup
$LN5@hashLookup:

; 47   : 
; 48   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00047	8b 44 24 28	 mov	 eax, DWORD PTR nHashNo$[rsp]
  0004b	48 6b c0 10	 imul	 rax, rax, 16
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00054	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00058	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0005d	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
  00062	eb 0e		 jmp	 SHORT $LN4@hashLookup
$LN2@hashLookup:
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00069	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006d	48 89 44 24 20	 mov	 QWORD PTR pNext$[rsp], rax
$LN4@hashLookup:
  00072	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00078	74 1f		 je	 SHORT $LN3@hashLookup

; 49   : 	{
; 50   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  0007f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pKey$[rsp]
  00087	e8 00 00 00 00	 call	 _tcscmp
  0008c	85 c0		 test	 eax, eax
  0008e	75 07		 jne	 SHORT $LN6@hashLookup

; 51   : 			return &pNext->pNode;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext$[rsp]
  00095	eb 04		 jmp	 SHORT $LN1@hashLookup
$LN6@hashLookup:

; 52   : 	}

  00097	eb cb		 jmp	 SHORT $LN2@hashLookup
$LN3@hashLookup:

; 53   : 
; 54   : 	return NULL;

  00099	33 c0		 xor	 eax, eax
$LN1@hashLookup:

; 55   : 
; 56   : }

  0009b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
nLen$ = 32
i$ = 36
key$ = 40
this$ = 64
pStr$ = 72
?getHashNo@CHash@@QEAAIPEAD@Z PROC			; CHash::getHashNo

; 31   : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pStr$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	89 44 24 20	 mov	 DWORD PTR nLen$[rsp], eax

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;

  00031	8b 44 24 20	 mov	 eax, DWORD PTR nLen$[rsp]
  00035	89 44 24 28	 mov	 DWORD PTR key$[rsp], eax

; 35   : 	for(i=0; i < nLen; i++) {

  00039	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00041	eb 0a		 jmp	 SHORT $LN4@getHashNo
$LN2@getHashNo:
  00043	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00047	ff c0		 inc	 eax
  00049	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@getHashNo:
  0004d	8b 44 24 20	 mov	 eax, DWORD PTR nLen$[rsp]
  00051	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00055	73 22		 jae	 SHORT $LN3@getHashNo

; 36   : 		key += (key << 4) + (int)pStr[i];

  00057	8b 44 24 28	 mov	 eax, DWORD PTR key$[rsp]
  0005b	c1 e0 04	 shl	 eax, 4
  0005e	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  00062	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStr$[rsp]
  00067	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0006b	03 4c 24 28	 add	 ecx, DWORD PTR key$[rsp]
  0006f	03 c8		 add	 ecx, eax
  00071	8b c1		 mov	 eax, ecx
  00073	89 44 24 28	 mov	 DWORD PTR key$[rsp], eax

; 37   : 	}

  00077	eb ca		 jmp	 SHORT $LN2@getHashNo
$LN3@getHashNo:

; 38   : 	key = key % m_nMaxCount;

  00079	33 d2		 xor	 edx, edx
  0007b	8b 44 24 28	 mov	 eax, DWORD PTR key$[rsp]
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00084	f7 31		 div	 DWORD PTR [rcx]
  00086	8b c2		 mov	 eax, edx
  00088	89 44 24 28	 mov	 DWORD PTR key$[rsp], eax

; 39   : 	return key;

  0008c	8b 44 24 28	 mov	 eax, DWORD PTR key$[rsp]

; 40   : }

  00090	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
?getHashNo@CHash@@QEAAIPEAD@Z ENDP			; CHash::getHashNo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
this$ = 48
?clear@CHash@@QEAAXXZ PROC				; CHash::clear

; 26   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 27   : 	memset(m_pHashData, 0, sizeof(m_pHashData));

  0001e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00024	33 d2		 xor	 edx, edx
  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002f	e8 00 00 00 00	 call	 memset

; 28   : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
?clear@CHash@@QEAAXXZ ENDP				; CHash::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
this$ = 48
??1CHash@@QEAA@XZ PROC					; CHash::~CHash

; 18   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 19   : 	if(m_pHashData) {

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00028	74 1c		 je	 SHORT $LN2@CHash

; 20   : 		free(m_pHashData);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 21   : 		m_pHashData = NULL;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003e	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN2@CHash:

; 22   : 	}
; 23   : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
??1CHash@@QEAA@XZ ENDP					; CHash::~CHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
this$ = 48
max$ = 56
??0CHash@@QEAA@I@Z PROC					; CHash::CHash

; 10   : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 11   : 	// TODO m_nMaxCount 를 2의 제곱으로 조정한다.
; 12   : 	m_nMaxCount = max;

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00027	8b 4c 24 38	 mov	 ecx, DWORD PTR max$[rsp]
  0002b	89 08		 mov	 DWORD PTR [rax], ecx

; 13   : 	m_nElementCount = 0;

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00032	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 14   : 	m_pHashData = (SThash_value *)calloc(m_nMaxCount, sizeof(SThash_value));

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	ba 10 00 00 00	 mov	 edx, 16
  00045	8b c8		 mov	 ecx, eax
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00052	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 15   : }

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
??0CHash@@QEAA@I@Z ENDP					; CHash::CHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT _tcscmp
_TEXT	SEGMENT
_s1$ = 48
_s2$ = 56
_tcscmp	PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR _s2$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _s1$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mbscmp
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
_tcscmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT _tcsncpy
_TEXT	SEGMENT
_Dst$ = 48
_Source$ = 56
_Count$ = 64
_tcsncpy PROC						; COMDAT

; 1542 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00028	4c 8b 44 24 40	 mov	 r8, QWORD PTR _Count$[rsp]
  0002d	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Source$[rsp]
  00032	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Dst$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mbsnbcpy

; 1546 : #pragma warning(pop)
; 1547 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
_tcsncpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
__$ArrayPad$ = 80
_Buffer$ = 112
_Format$ = 120
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 18 00 00 00	 mov	 ecx, 24
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0003c	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  00041	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00049	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004e	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b 54 24 78	 mov	 rdx, QWORD PTR _Format$[rsp]
  0005b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00060	e8 00 00 00 00	 call	 _vsprintf_l
  00065	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00069	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  00072	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  00076	8b f8		 mov	 edi, eax
  00078	48 8b cc	 mov	 rcx, rsp
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  00082	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00087	8b c7		 mov	 eax, edi
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008e	48 33 cc	 xor	 rcx, rsp
  00091	e8 00 00 00 00	 call	 __security_check_cookie
  00096	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0003c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00041	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004d	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 83 c8 01	 or	 rax, 1
  00039	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0003e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00048	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  00052	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00057	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00065	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00069	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0006e	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00070	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00078	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0007a	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0007e	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00082	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00086	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 144  :         {

$LN3:
  00000	40 57		 push	 rdi

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00002	5f		 pop	 rdi
  00003	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
