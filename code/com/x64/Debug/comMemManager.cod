; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?g_szSystemError@@3PADA				; g_szSystemError
PUBLIC	?g_szMessage@@3PADA				; g_szMessage
PUBLIC	?gs_pMMgr@@3PEAVCMemManager@@EA			; gs_pMMgr
_BSS	SEGMENT
?g_szSystemError@@3PADA DB 0400H DUP (?)		; g_szSystemError
?g_szMessage@@3PADA DB 080H DUP (?)			; g_szMessage
?gs_pMMgr@@3PEAVCMemManager@@EA DQ 01H DUP (?)		; gs_pMMgr
_BSS	ENDS
CONST	SEGMENT
$SG44517 DB	'getStrToInt parsing FAIL!!! cUnit[%c]', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	??_GCBufPool@@QEAAPEAXI@Z			; CBufPool::`scalar deleting destructor'
PUBLIC	??0CMemManager@@QEAA@XZ				; CMemManager::CMemManager
PUBLIC	??1CMemManager@@QEAA@XZ				; CMemManager::~CMemManager
PUBLIC	?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z	; CMemManager::init
PUBLIC	?init@CMemManager@@QEAAHPEADH@Z			; CMemManager::init
PUBLIC	?alloc@CMemManager@@QEAA_NXZ			; CMemManager::alloc
PUBLIC	?delBuf@CMemManager@@QEAAXPEADH@Z		; CMemManager::delBuf
PUBLIC	?delBufByIndex@CMemManager@@QEAAXPEADH@Z	; CMemManager::delBufByIndex
PUBLIC	?getStrToInt@CMemManager@@QEAAHPEAD@Z		; CMemManager::getStrToInt
PUBLIC	?__newBuf@CMemManager@@AEAAPEADH_K@Z		; CMemManager::__newBuf
PUBLIC	?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z		; OBJ_DELETE
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_atoi:PROC
EXTRN	??2@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??3@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	??0CBufPool@@QEAA@XZ:PROC			; CBufPool::CBufPool
EXTRN	??1CBufPool@@QEAA@XZ:PROC			; CBufPool::~CBufPool
EXTRN	?alloc@CBufPool@@QEAA_NHH@Z:PROC		; CBufPool::alloc
EXTRN	?newMem@CBufPool@@QEAAPEADXZ:PROC		; CBufPool::newMem
EXTRN	?delMem@CBufPool@@QEAAXPEAD@Z:PROC		; CBufPool::delMem
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+4
	DD	imagerel $unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+162
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getIndex@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+162
	DD	imagerel $unwind$?getIndex@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCBufPool@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$??_GCBufPool@@QEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0CMemManager@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+379
	DD	imagerel $unwind$??0CMemManager@@QEAA@XZ
$pdata$??1CMemManager@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+176
	DD	imagerel $unwind$??1CMemManager@@QEAA@XZ
$pdata$?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z DD imagerel $LN6
	DD	imagerel $LN6+110
	DD	imagerel $unwind$?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z
$pdata$?init@CMemManager@@QEAAHPEADH@Z DD imagerel $LN4
	DD	imagerel $LN4+127
	DD	imagerel $unwind$?init@CMemManager@@QEAAHPEADH@Z
$pdata$?alloc@CMemManager@@QEAA_NXZ DD imagerel $LN17
	DD	imagerel $LN17+491
	DD	imagerel $unwind$?alloc@CMemManager@@QEAA_NXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA+42
	DD	imagerel $unwind$?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBuf@CMemManager@@QEAAXPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?delBuf@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?delBufByIndex@CMemManager@@QEAAXPEADH@Z DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$?delBufByIndex@CMemManager@@QEAAXPEADH@Z
$pdata$?getStrToInt@CMemManager@@QEAAHPEAD@Z DD imagerel $LN16
	DD	imagerel $LN16+459
	DD	imagerel $unwind$?getStrToInt@CMemManager@@QEAAHPEAD@Z
$pdata$?__newBuf@CMemManager@@AEAAPEADH_K@Z DD imagerel $LN6
	DD	imagerel $LN6+148
	DD	imagerel $unwind$?__newBuf@CMemManager@@AEAAPEADH_K@Z
$pdata$?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z DD imagerel $LN15
	DD	imagerel $LN15+248
	DD	imagerel $unwind$?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBuf@CMemManager@@QEAAXPEADH@Z DD 022801H
	DD	070105214H
xdata	ENDS
CONST	SEGMENT
	ORG $+1
$cppxdata$?alloc@CMemManager@@QEAA_NXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?alloc@CMemManager@@QEAA_NXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?alloc@CMemManager@@QEAA_NXZ
	DD	058H
	DD	00H
	DD	01H
?getStrToInt@CMemManager@@QEAAHPEAD@Z$rtcName$0 DB 073H	; CMemManager::getStrToInt
	DB	07aH
	DB	04eH
	DB	075H
	DB	06dH
	DB	00H
	ORG $+2
?getStrToInt@CMemManager@@QEAAHPEAD@Z$rtcFrameData DD 01H ; CMemManager::getStrToInt
	DD	00H
	DQ	FLAT:?getStrToInt@CMemManager@@QEAAHPEAD@Z$rtcVarDesc
	ORG $+8
?getStrToInt@CMemManager@@QEAAHPEAD@Z$rtcVarDesc DD 038H ; CMemManager::getStrToInt
	DD	020H
	DQ	FLAT:?getStrToInt@CMemManager@@QEAAHPEAD@Z$rtcName$0
CONST	ENDS
xdata	SEGMENT
$unwind$??0CMemManager@@QEAA@XZ DD 021e01H
	DD	07006520aH
$unwind$??1CMemManager@@QEAA@XZ DD 021e01H
	DD	07006720aH
$unwind$?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z DD 022301H
	DD	0700b120fH
$unwind$?init@CMemManager@@QEAAHPEADH@Z DD 022801H
	DD	070105214H
$unwind$?alloc@CMemManager@@QEAA_NXZ DD 022d11H
	DD	07006f20dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?alloc@CMemManager@@QEAA_NXZ
$stateUnwindMap$?alloc@CMemManager@@QEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA
$ip2state$?alloc@CMemManager@@QEAA_NXZ DD imagerel ?alloc@CMemManager@@QEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?alloc@CMemManager@@QEAA_NXZ+235
	DD	00H
	DD	imagerel ?alloc@CMemManager@@QEAA_NXZ+279
	DD	0ffffffffH
$unwind$?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$?delBufByIndex@CMemManager@@QEAAXPEADH@Z DD 022801H
	DD	070103214H
$unwind$?getStrToInt@CMemManager@@QEAAHPEAD@Z DD 033b19H
	DD	0120112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$?__newBuf@CMemManager@@AEAAPEADH_K@Z DD 022701H
	DD	0700f5213H
$unwind$?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z DD 022101H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCBufPool@@QEAAPEAXI@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getIndex@@YAHH@Z DD 021c01H
	DD	070059209H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?getIndex@@YAHH@Z$rtcName$0 DB 024H			; getIndex
	DB	053H
	DB	031H
	DB	00H
	ORG $+12
?getIndex@@YAHH@Z$rtcVarDesc DD 038H			; getIndex
	DD	08H
	DQ	FLAT:?getIndex@@YAHH@Z$rtcName$0
	ORG $+48
?getIndex@@YAHH@Z$rtcFrameData DD 01H			; getIndex
	DD	00H
	DQ	FLAT:?getIndex@@YAHH@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 023c19H
	DD	07015b219H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv64 = 48
tv68 = 56
tv79 = 64
type$ = 96
p$ = 104
?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z PROC		; OBJ_DELETE

; 150  : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	8b 4c 24 60	 mov	 ecx, DWORD PTR [rsp+96]

; 151  : 	switch (type) {

  00021	8b 44 24 60	 mov	 eax, DWORD PTR type$[rsp]
  00025	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  00029	83 7c 24 30 02	 cmp	 DWORD PTR tv64[rsp], 2
  0002e	74 1a		 je	 SHORT $LN4@OBJ_DELETE
  00030	83 7c 24 30 03	 cmp	 DWORD PTR tv64[rsp], 3
  00035	74 51		 je	 SHORT $LN5@OBJ_DELETE
  00037	83 7c 24 30 04	 cmp	 DWORD PTR tv64[rsp], 4
  0003c	74 57		 je	 SHORT $LN6@OBJ_DELETE
  0003e	83 7c 24 30 05	 cmp	 DWORD PTR tv64[rsp], 5
  00043	74 73		 je	 SHORT $LN7@OBJ_DELETE
  00045	e9 a8 00 00 00	 jmp	 $LN2@OBJ_DELETE
$LN4@OBJ_DELETE:

; 152  : 	case eAlloc_Type_new		: delete p; break;

  0004a	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  0004f	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00054	33 d2		 xor	 edx, edx
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0005b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00060	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00066	75 0b		 jne	 SHORT $LN11@OBJ_DELETE
  00068	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00071	eb 13		 jmp	 SHORT $LN12@OBJ_DELETE
$LN11@OBJ_DELETE:
  00073	48 c7 44 24 68
	23 81 00 00	 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  0007c	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  00081	48 89 44 24 38	 mov	 QWORD PTR tv68[rsp], rax
$LN12@OBJ_DELETE:
  00086	eb 6a		 jmp	 SHORT $LN2@OBJ_DELETE
$LN5@OBJ_DELETE:

; 153  : 	case eAlloc_Type_alloc		: free(p); break;

  00088	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00093	eb 5d		 jmp	 SHORT $LN2@OBJ_DELETE
$LN6@OBJ_DELETE:

; 154  : 	case eAlloc_Type_BufPool	: gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00095	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  0009a	e8 00 00 00 00	 call	 strlen
  0009f	48 ff c0	 inc	 rax
  000a2	44 8b c0	 mov	 r8d, eax
  000a5	48 8b 54 24 68	 mov	 rdx, QWORD PTR p$[rsp]
  000aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000b1	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  000b6	eb 3a		 jmp	 SHORT $LN2@OBJ_DELETE
$LN7@OBJ_DELETE:

; 155  : 	case eAlloc_Type_newArray	: delete[] p; break;

  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  000bd	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  000c7	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  000cc	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000d2	75 0b		 jne	 SHORT $LN13@OBJ_DELETE
  000d4	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  000dd	eb 13		 jmp	 SHORT $LN14@OBJ_DELETE
$LN13@OBJ_DELETE:
  000df	48 c7 44 24 68
	23 81 00 00	 mov	 QWORD PTR p$[rsp], 33059 ; 00008123H
  000e8	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  000ed	48 89 44 24 40	 mov	 QWORD PTR tv79[rsp], rax
$LN14@OBJ_DELETE:
$LN2@OBJ_DELETE:

; 156  : 	case eAlloc_Type_none		: break;
; 157  : 	case eAlloc_Type_MemPool	: break;
; 158  : 	}
; 159  : }

  000f2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PEAX@Z ENDP		; OBJ_DELETE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
p$1 = 32
this$ = 64
nIdx$ = 72
size$ = 80
?__newBuf@CMemManager@@AEAAPEADH_K@Z PROC		; CMemManager::__newBuf

; 125  : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 126  : 	if (IDX_BUF_2m < nIdx || !m_pBufList[nIdx]) {

  00027	83 7c 24 48 15	 cmp	 DWORD PTR nIdx$[rsp], 21
  0002c	7f 11		 jg	 SHORT $LN3@newBuf
  0002e	48 63 44 24 48	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00038	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0003d	75 3c		 jne	 SHORT $LN2@newBuf
$LN3@newBuf:

; 127  : 		if (m_nOverMaxIdx < nIdx) m_nOverMaxIdx = nIdx;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00044	8b 4c 24 48	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00048	39 88 08 01 00
	00		 cmp	 DWORD PTR [rax+264], ecx
  0004e	7d 0f		 jge	 SHORT $LN4@newBuf
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00055	8b 4c 24 48	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00059	89 88 08 01 00
	00		 mov	 DWORD PTR [rax+264], ecx
$LN4@newBuf:

; 128  : 		char *p = (char *)calloc(1, size);

  0005f	48 8b 54 24 50	 mov	 rdx, QWORD PTR size$[rsp]
  00064	b9 01 00 00 00	 mov	 ecx, 1
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0006f	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax

; 129  : /*		if (p) {
; 130  : 			gs_cLogger.DebugLog(LEVEL_TRACE, "overIdx:%d, overSize:%lld calloc address[%p]", m_nOverMaxIdx, size, p);
; 131  : 		}
; 132  : 		else {
; 133  : 			gs_cLogger.DebugLog(LEVEL_ERROR, "calloc has Failed");
; 134  : 		}	*/	
; 135  : 		return p;

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  00079	eb 13		 jmp	 SHORT $LN1@newBuf
$LN2@newBuf:

; 136  : 	}
; 137  : 
; 138  : 	return m_pBufList[nIdx]->newMem();

  0007b	48 63 44 24 48	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00085	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00089	e8 00 00 00 00	 call	 ?newMem@CBufPool@@QEAAPEADXZ ; CBufPool::newMem
$LN1@newBuf:

; 139  : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
?__newBuf@CMemManager@@AEAAPEADH_K@Z ENDP		; CMemManager::__newBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
pPos$ = 32
szNum$ = 56
cUnit$ = 100
i$ = 104
nRes$ = 108
tv80 = 120
__$ArrayPad$ = 128
this$ = 160
pData$ = 168
?getStrToInt@CMemManager@@QEAAHPEAD@Z PROC		; CMemManager::getStrToInt

; 47   : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+160]
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00030	48 33 c4	 xor	 rax, rsp
  00033	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 48   : 	TCHAR *pPos = pData;

  0003b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pData$[rsp]
  00043	48 89 44 24 20	 mov	 QWORD PTR pPos$[rsp], rax

; 49   : 	TCHAR szNum[32], cUnit = 0;

  00048	c6 44 24 64 00	 mov	 BYTE PTR cUnit$[rsp], 0

; 50   : 	int i = 0, nRes=0;

  0004d	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00055	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR nRes$[rsp], 0
$LN2@getStrToIn:

; 51   : 	while (*pPos) {

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR pPos$[rsp]
  00062	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00065	85 c0		 test	 eax, eax
  00067	74 52		 je	 SHORT $LN3@getStrToIn

; 52   : 		if ('0' <= *pPos && *pPos <= '9') szNum[i++] = *pPos;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR pPos$[rsp]
  0006e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00071	83 f8 30	 cmp	 eax, 48			; 00000030H
  00074	7c 2a		 jl	 SHORT $LN6@getStrToIn
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR pPos$[rsp]
  0007b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007e	83 f8 39	 cmp	 eax, 57			; 00000039H
  00081	7f 1d		 jg	 SHORT $LN6@getStrToIn
  00083	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPos$[rsp]
  0008d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00090	88 4c 04 38	 mov	 BYTE PTR szNum$[rsp+rax], cl
  00094	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00098	ff c0		 inc	 eax
  0009a	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  0009e	eb 0c		 jmp	 SHORT $LN7@getStrToIn
$LN6@getStrToIn:

; 53   : 		else cUnit = *pPos;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR pPos$[rsp]
  000a5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a8	88 44 24 64	 mov	 BYTE PTR cUnit$[rsp], al
$LN7@getStrToIn:

; 54   : 		pPos++;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR pPos$[rsp]
  000b1	48 ff c0	 inc	 rax
  000b4	48 89 44 24 20	 mov	 QWORD PTR pPos$[rsp], rax

; 55   : 	}

  000b9	eb a2		 jmp	 SHORT $LN2@getStrToIn
$LN3@getStrToIn:

; 56   : 	nRes = _ttoi(szNum);

  000bb	48 8d 4c 24 38	 lea	 rcx, QWORD PTR szNum$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000c6	89 44 24 6c	 mov	 DWORD PTR nRes$[rsp], eax

; 57   : 	if (cUnit) {

  000ca	0f be 44 24 64	 movsx	 eax, BYTE PTR cUnit$[rsp]
  000cf	85 c0		 test	 eax, eax
  000d1	0f 84 8a 00 00
	00		 je	 $LN8@getStrToIn

; 58   : 		switch (cUnit) {

  000d7	0f be 44 24 64	 movsx	 eax, BYTE PTR cUnit$[rsp]
  000dc	89 44 24 78	 mov	 DWORD PTR tv80[rsp], eax
  000e0	8b 44 24 78	 mov	 eax, DWORD PTR tv80[rsp]
  000e4	83 e8 47	 sub	 eax, 71			; 00000047H
  000e7	89 44 24 78	 mov	 DWORD PTR tv80[rsp], eax
  000eb	83 7c 24 78 26	 cmp	 DWORD PTR tv80[rsp], 38	; 00000026H
  000f0	77 5c		 ja	 SHORT $LN12@getStrToIn
  000f2	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv80[rsp]
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000fe	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN14@getStrToIn[rcx+rax]
  00106	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN15@getStrToIn[rcx+rax*4]
  0010d	48 03 c1	 add	 rax, rcx
  00110	ff e0		 jmp	 rax
$LN9@getStrToIn:

; 59   : 		case 'k': case 'K': nRes = nRes * 1024; break;

  00112	69 44 24 6c 00
	04 00 00	 imul	 eax, DWORD PTR nRes$[rsp], 1024 ; 00000400H
  0011a	89 44 24 6c	 mov	 DWORD PTR nRes$[rsp], eax
  0011e	eb 41		 jmp	 SHORT $LN4@getStrToIn
$LN10@getStrToIn:

; 60   : 		case 'm': case 'M': nRes = nRes * 1024 * 1024; break;

  00120	69 44 24 6c 00
	04 00 00	 imul	 eax, DWORD PTR nRes$[rsp], 1024 ; 00000400H
  00128	69 c0 00 04 00
	00		 imul	 eax, eax, 1024		; 00000400H
  0012e	89 44 24 6c	 mov	 DWORD PTR nRes$[rsp], eax
  00132	eb 2d		 jmp	 SHORT $LN4@getStrToIn
$LN11@getStrToIn:

; 61   : 		case 'g': case 'G': nRes = nRes * 1024 * 1024 * 1024; break;

  00134	69 44 24 6c 00
	04 00 00	 imul	 eax, DWORD PTR nRes$[rsp], 1024 ; 00000400H
  0013c	69 c0 00 04 00
	00		 imul	 eax, eax, 1024		; 00000400H
  00142	69 c0 00 04 00
	00		 imul	 eax, eax, 1024		; 00000400H
  00148	89 44 24 6c	 mov	 DWORD PTR nRes$[rsp], eax
  0014c	eb 13		 jmp	 SHORT $LN4@getStrToIn
$LN12@getStrToIn:

; 62   : 		default: printf("getStrToInt parsing FAIL!!! cUnit[%c]\n", cUnit);

  0014e	0f be 44 24 64	 movsx	 eax, BYTE PTR cUnit$[rsp]
  00153	8b d0		 mov	 edx, eax
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG44517
  0015c	e8 00 00 00 00	 call	 printf
$LN4@getStrToIn:
$LN8@getStrToIn:

; 63   : 		}
; 64   : 	}
; 65   : 	return nRes;

  00161	8b 44 24 6c	 mov	 eax, DWORD PTR nRes$[rsp]

; 66   : }

  00165	8b f8		 mov	 edi, eax
  00167	48 8b cc	 mov	 rcx, rsp
  0016a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?getStrToInt@CMemManager@@QEAAHPEAD@Z$rtcFrameData
  00171	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00176	8b c7		 mov	 eax, edi
  00178	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00180	48 33 cc	 xor	 rcx, rsp
  00183	e8 00 00 00 00	 call	 __security_check_cookie
  00188	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0018f	5f		 pop	 rdi
  00190	c3		 ret	 0
  00191	0f 1f 00	 npad	 3
$LN15@getStrToIn:
  00194	00 00 00 00	 DD	 $LN11@getStrToIn
  00198	00 00 00 00	 DD	 $LN9@getStrToIn
  0019c	00 00 00 00	 DD	 $LN10@getStrToIn
  001a0	00 00 00 00	 DD	 $LN12@getStrToIn
$LN14@getStrToIn:
  001a4	00		 DB	 0
  001a5	03		 DB	 3
  001a6	03		 DB	 3
  001a7	03		 DB	 3
  001a8	01		 DB	 1
  001a9	03		 DB	 3
  001aa	02		 DB	 2
  001ab	03		 DB	 3
  001ac	03		 DB	 3
  001ad	03		 DB	 3
  001ae	03		 DB	 3
  001af	03		 DB	 3
  001b0	03		 DB	 3
  001b1	03		 DB	 3
  001b2	03		 DB	 3
  001b3	03		 DB	 3
  001b4	03		 DB	 3
  001b5	03		 DB	 3
  001b6	03		 DB	 3
  001b7	03		 DB	 3
  001b8	03		 DB	 3
  001b9	03		 DB	 3
  001ba	03		 DB	 3
  001bb	03		 DB	 3
  001bc	03		 DB	 3
  001bd	03		 DB	 3
  001be	03		 DB	 3
  001bf	03		 DB	 3
  001c0	03		 DB	 3
  001c1	03		 DB	 3
  001c2	03		 DB	 3
  001c3	03		 DB	 3
  001c4	00		 DB	 0
  001c5	03		 DB	 3
  001c6	03		 DB	 3
  001c7	03		 DB	 3
  001c8	01		 DB	 1
  001c9	03		 DB	 3
  001ca	02		 DB	 2
?getStrToInt@CMemManager@@QEAAHPEAD@Z ENDP		; CMemManager::getStrToInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
this$ = 48
pBuf$ = 56
nIdx$ = 64
?delBufByIndex@CMemManager@@QEAAXPEADH@Z PROC		; CMemManager::delBufByIndex

; 143  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 144  : 	if (IDX_BUF_2m < nIdx || !m_pBufList[nIdx]) { if (pBuf) free(pBuf); return; }

  00028	83 7c 24 40 15	 cmp	 DWORD PTR nIdx$[rsp], 21
  0002d	7f 11		 jg	 SHORT $LN3@delBufByIn
  0002f	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00039	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0003e	75 15		 jne	 SHORT $LN2@delBufByIn
$LN3@delBufByIn:
  00040	48 83 7c 24 38
	00		 cmp	 QWORD PTR pBuf$[rsp], 0
  00046	74 0b		 je	 SHORT $LN4@delBufByIn
  00048	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pBuf$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@delBufByIn:
  00053	eb 29		 jmp	 SHORT $LN1@delBufByIn
$LN2@delBufByIn:

; 145  : 	if(m_pBufList[nIdx]) m_pBufList[nIdx]->delMem(pBuf);

  00055	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00064	74 18		 je	 SHORT $LN5@delBufByIn
  00066	48 63 44 24 40	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0006b	48 8b 54 24 38	 mov	 rdx, QWORD PTR pBuf$[rsp]
  00070	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00075	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00079	e8 00 00 00 00	 call	 ?delMem@CBufPool@@QEAAXPEAD@Z ; CBufPool::delMem
$LN5@delBufByIn:
$LN1@delBufByIn:

; 146  : }

  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
?delBufByIndex@CMemManager@@QEAAXPEADH@Z ENDP		; CMemManager::delBufByIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
pBuf$ = 72
nSize$ = 80
?delBuf@CMemManager@@QEAAXPEADH@Z PROC			; CMemManager::delBuf, COMDAT

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	8b 4c 24 50	 mov	 ecx, DWORD PTR nSize$[rsp]
  0002c	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00031	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00035	44 8b 44 24 20	 mov	 r8d, DWORD PTR nIdx$[rsp]
  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00044	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
?delBuf@CMemManager@@QEAAXPEADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv85 = 96
tv138 = 104
tv166 = 112
this$ = 144
?alloc@CMemManager@@QEAA_NXZ PROC			; CMemManager::alloc

; 89   : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00024	48 c7 44 24 58
	fe ff ff ff	 mov	 QWORD PTR $T7[rsp], -2

; 90   : 	int i;
; 91   : 	for (i = IDX_BUF_2; i < IDX_BUF_MAX; i++)

  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00035	eb 0a		 jmp	 SHORT $LN4@alloc
$LN2@alloc:
  00037	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0003b	ff c0		 inc	 eax
  0003d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@alloc:
  00041	83 7c 24 20 16	 cmp	 DWORD PTR i$[rsp], 22
  00046	0f 8d 94 01 00
	00		 jge	 $LN3@alloc

; 92   : 	{
; 93   : 		if (!m_stConfig.nMaxList[i]) continue;

  0004c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00051	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00059	83 bc 81 b0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+176], 0
  00061	75 02		 jne	 SHORT $LN5@alloc
  00063	eb d2		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 94   : 
; 95   : 		if (m_pBufList[i]) {

  00065	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00072	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00077	74 5c		 je	 SHORT $LN6@alloc

; 96   : 			delete m_pBufList[i];

  00079	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0007e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00086	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0008a	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  00094	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00099	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0009f	74 16		 je	 SHORT $LN10@alloc
  000a1	ba 01 00 00 00	 mov	 edx, 1
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000ab	e8 00 00 00 00	 call	 ??_GCBufPool@@QEAAPEAXI@Z
  000b0	48 89 44 24 60	 mov	 QWORD PTR tv85[rsp], rax
  000b5	eb 09		 jmp	 SHORT $LN11@alloc
$LN10@alloc:
  000b7	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
$LN11@alloc:

; 97   : 			m_pBufList[i] = NULL;

  000c0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000cd	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN6@alloc:

; 98   : 		}
; 99   : 		m_pBufList[i] = new (std::nothrow) CBufPool();

  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  000dc	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  000e1	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  000e6	48 89 44 24 40	 mov	 QWORD PTR $T4[rsp], rax
  000eb	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T4[rsp], 0
  000f1	74 11		 je	 SHORT $LN12@alloc
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T4[rsp]
  000f8	e8 00 00 00 00	 call	 ??0CBufPool@@QEAA@XZ	; CBufPool::CBufPool
  000fd	48 89 44 24 68	 mov	 QWORD PTR tv138[rsp], rax
  00102	eb 09		 jmp	 SHORT $LN13@alloc
$LN12@alloc:
  00104	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv138[rsp], 0
$LN13@alloc:
  0010d	48 8b 44 24 68	 mov	 rax, QWORD PTR tv138[rsp]
  00112	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  00117	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0011c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00124	48 8b 54 24 38	 mov	 rdx, QWORD PTR $T3[rsp]
  00129	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 100  : 		if (m_pBufList[i]) {

  0012d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00132	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0013a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0013f	0f 84 96 00 00
	00		 je	 $LN7@alloc

; 101  : 			if (!m_pBufList[i]->alloc(i, m_stConfig.nMaxList[i])) {

  00145	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0014a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0014f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR this$[rsp]
  00157	44 8b 84 82 b0
	00 00 00	 mov	 r8d, DWORD PTR [rdx+rax*4+176]
  0015f	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00163	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0016b	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0016f	e8 00 00 00 00	 call	 ?alloc@CBufPool@@QEAA_NHH@Z ; CBufPool::alloc
  00174	0f b6 c0	 movzx	 eax, al
  00177	85 c0		 test	 eax, eax
  00179	75 60		 jne	 SHORT $LN7@alloc

; 102  : 				delete m_pBufList[i];

  0017b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00180	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00188	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0018c	48 89 44 24 50	 mov	 QWORD PTR $T6[rsp], rax
  00191	48 8b 44 24 50	 mov	 rax, QWORD PTR $T6[rsp]
  00196	48 89 44 24 48	 mov	 QWORD PTR $T5[rsp], rax
  0019b	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T5[rsp], 0
  001a1	74 16		 je	 SHORT $LN14@alloc
  001a3	ba 01 00 00 00	 mov	 edx, 1
  001a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T5[rsp]
  001ad	e8 00 00 00 00	 call	 ??_GCBufPool@@QEAAPEAXI@Z
  001b2	48 89 44 24 70	 mov	 QWORD PTR tv166[rsp], rax
  001b7	eb 09		 jmp	 SHORT $LN15@alloc
$LN14@alloc:
  001b9	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv166[rsp], 0
$LN15@alloc:

; 103  : 				m_pBufList[i] = NULL;

  001c2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001cf	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 104  : 				return false;

  001d7	32 c0		 xor	 al, al
  001d9	eb 07		 jmp	 SHORT $LN1@alloc
$LN7@alloc:

; 105  : 			}
; 106  : 		}
; 107  : 	}

  001db	e9 57 fe ff ff	 jmp	 $LN2@alloc
$LN3@alloc:

; 108  : 	return true;

  001e0	b0 01		 mov	 al, 1
$LN1@alloc:

; 109  : 
; 110  : }

  001e2	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001e9	5f		 pop	 rdi
  001ea	c3		 ret	 0
?alloc@CMemManager@@QEAA_NXZ ENDP			; CMemManager::alloc
_TEXT	ENDS
text$x	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv85 = 96
tv138 = 104
tv166 = 112
this$ = 144
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA PROC	; `CMemManager::alloc'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001a	48 8b 4d 40	 mov	 rcx, QWORD PTR $T4[rbp]
  0001e	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	5f		 pop	 rdi
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA ENDP	; `CMemManager::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv85 = 96
tv138 = 104
tv166 = 112
this$ = 144
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA PROC	; `CMemManager::alloc'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001a	48 8b 4d 40	 mov	 rcx, QWORD PTR $T4[rbp]
  0001e	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	5f		 pop	 rdi
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$0@?0??alloc@CMemManager@@QEAA_NXZ@4HA ENDP	; `CMemManager::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
nSize$ = 32
nIdx$ = 36
this$ = 64
pStrSize$ = 72
nCount$ = 80
?init@CMemManager@@QEAAHPEADH@Z PROC			; CMemManager::init

; 78   : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 79   : 	int nSize = getStrToInt(pStrSize);

  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR pStrSize$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00032	e8 00 00 00 00	 call	 ?getStrToInt@CMemManager@@QEAAHPEAD@Z ; CMemManager::getStrToInt
  00037	89 44 24 20	 mov	 DWORD PTR nSize$[rsp], eax

; 80   : 	int nIdx;
; 81   : 	if (nSize) {

  0003b	83 7c 24 20 00	 cmp	 DWORD PTR nSize$[rsp], 0
  00040	74 33		 je	 SHORT $LN2@init

; 82   : 		nIdx = getIndex(nSize);

  00042	8b 4c 24 20	 mov	 ecx, DWORD PTR nSize$[rsp]
  00046	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0004b	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 83   : 		m_stConfig.nMaxList[nIdx] += nCount;

  0004f	48 63 44 24 24	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00059	8b 84 81 b0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+176]
  00060	03 44 24 50	 add	 eax, DWORD PTR nCount$[rsp]
  00064	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR nIdx$[rsp]
  00069	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  0006e	89 84 8a b0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+176], eax
$LN2@init:

; 84   : 	}
; 85   : 	return nSize;

  00075	8b 44 24 20	 mov	 eax, DWORD PTR nSize$[rsp]

; 86   : }

  00079	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
?init@CMemManager@@QEAAHPEADH@Z ENDP			; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
i$ = 0
this$ = 32
pConf$ = 40
?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z PROC		; CMemManager::init

; 69   : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]

; 70   : 	int i;
; 71   : 	for (i = 0; i < IDX_BUF_MAX; i++)

  00023	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0002a	eb 08		 jmp	 SHORT $LN4@init
$LN2@init:
  0002c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0002f	ff c0		 inc	 eax
  00031	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@init:
  00034	83 3c 24 16	 cmp	 DWORD PTR i$[rsp], 22
  00038	7d 2e		 jge	 SHORT $LN3@init

; 72   : 	{
; 73   : 		m_stConfig.nMaxList[i] += pConf->nMaxList[i];

  0003a	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0003e	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00042	48 8b 54 24 20	 mov	 rdx, QWORD PTR this$[rsp]
  00047	8b 84 82 b0 00
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+176]
  0004e	48 8b 54 24 28	 mov	 rdx, QWORD PTR pConf$[rsp]
  00053	03 04 8a	 add	 eax, DWORD PTR [rdx+rcx*4]
  00056	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0005a	48 8b 54 24 20	 mov	 rdx, QWORD PTR this$[rsp]
  0005f	89 84 8a b0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+176], eax

; 74   : 	}

  00066	eb c4		 jmp	 SHORT $LN2@init
$LN3@init:

; 75   : }

  00068	48 83 c4 10	 add	 rsp, 16
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z ENDP		; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
i$ = 32
$T1 = 40
$T2 = 48
tv79 = 56
this$ = 80
??1CMemManager@@QEAA@XZ PROC				; CMemManager::~CMemManager

; 35   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 36   : 	int i =  0;

  0001e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 37   : 	for (i = IDX_BUF_2; i < IDX_BUF_MAX; i++) {

  00026	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0002e	eb 0a		 jmp	 SHORT $LN4@CMemManage
$LN2@CMemManage:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@CMemManage:
  0003a	83 7c 24 20 16	 cmp	 DWORD PTR i$[rsp], 22
  0003f	7d 69		 jge	 SHORT $LN3@CMemManage

; 38   : 		if (m_pBufList[i]) {

  00041	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00050	74 56		 je	 SHORT $LN5@CMemManage

; 39   : 			delete m_pBufList[i]; m_pBufList[i] = 0;

  00052	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0005c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00060	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  00065	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  0006a	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0006f	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00075	74 16		 je	 SHORT $LN7@CMemManage
  00077	ba 01 00 00 00	 mov	 edx, 1
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00081	e8 00 00 00 00	 call	 ??_GCBufPool@@QEAAPEAXI@Z
  00086	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  0008b	eb 09		 jmp	 SHORT $LN8@CMemManage
$LN7@CMemManage:
  0008d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
$LN8@CMemManage:
  00096	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000a0	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN5@CMemManage:

; 40   : 		}
; 41   : 	}

  000a8	eb 86		 jmp	 SHORT $LN2@CMemManage
$LN3@CMemManage:

; 42   : 
; 43   : 
; 44   : }

  000aa	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
??1CMemManager@@QEAA@XZ ENDP				; CMemManager::~CMemManager
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
i$ = 32
this$ = 64
??0CMemManager@@QEAA@XZ PROC				; CMemManager::CMemManager

; 9    : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 10   : 	m_nOverMaxIdx = 0;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	c7 80 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+264], 0

; 11   : 	memset(m_pBufList, 0, sizeof(m_pBufList));

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00032	41 b8 b0 00 00
	00		 mov	 r8d, 176		; 000000b0H
  00038	33 d2		 xor	 edx, edx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 memset

; 12   : 	memset(&m_stConfig, 0, sizeof(STBufConf));

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00047	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  0004d	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00053	33 d2		 xor	 edx, edx
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 memset

; 13   : 	int i;
; 14   : 
; 15   : 	m_stConfig.nMaxList[IDX_BUF_2] = 256;

  0005d	b8 04 00 00 00	 mov	 eax, 4
  00062	48 6b c0 01	 imul	 rax, rax, 1
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0006b	c7 84 01 b0 00
	00 00 00 01 00
	00		 mov	 DWORD PTR [rcx+rax+176], 256 ; 00000100H

; 16   : 	m_stConfig.nMaxList[IDX_BUF_4] = 256;

  00076	b8 04 00 00 00	 mov	 eax, 4
  0007b	48 6b c0 02	 imul	 rax, rax, 2
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00084	c7 84 01 b0 00
	00 00 00 01 00
	00		 mov	 DWORD PTR [rcx+rax+176], 256 ; 00000100H

; 17   : 	m_stConfig.nMaxList[IDX_BUF_8] = 2048;

  0008f	b8 04 00 00 00	 mov	 eax, 4
  00094	48 6b c0 03	 imul	 rax, rax, 3
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0009d	c7 84 01 b0 00
	00 00 00 08 00
	00		 mov	 DWORD PTR [rcx+rax+176], 2048 ; 00000800H

; 18   : 	m_stConfig.nMaxList[IDX_BUF_16] = 2048;

  000a8	b8 04 00 00 00	 mov	 eax, 4
  000ad	48 6b c0 04	 imul	 rax, rax, 4
  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000b6	c7 84 01 b0 00
	00 00 00 08 00
	00		 mov	 DWORD PTR [rcx+rax+176], 2048 ; 00000800H

; 19   : 	for (i = IDX_BUF_32; i < IDX_BUF_16k; i++)

  000c1	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR i$[rsp], 5
  000c9	eb 0a		 jmp	 SHORT $LN4@CMemManage
$LN2@CMemManage:
  000cb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000cf	ff c0		 inc	 eax
  000d1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@CMemManage:
  000d5	83 7c 24 20 0e	 cmp	 DWORD PTR i$[rsp], 14
  000da	7d 17		 jge	 SHORT $LN3@CMemManage

; 20   : 	{
; 21   : 		m_stConfig.nMaxList[i] = 64;

  000dc	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e6	c7 84 81 b0 00
	00 00 40 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+176], 64 ; 00000040H

; 22   : 	}

  000f1	eb d8		 jmp	 SHORT $LN2@CMemManage
$LN3@CMemManage:

; 23   : 	for (i = IDX_BUF_16k; i < IDX_BUF_64k; i++)

  000f3	c7 44 24 20 0e
	00 00 00	 mov	 DWORD PTR i$[rsp], 14
  000fb	eb 0a		 jmp	 SHORT $LN7@CMemManage
$LN5@CMemManage:
  000fd	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00101	ff c0		 inc	 eax
  00103	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@CMemManage:
  00107	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  0010c	7d 17		 jge	 SHORT $LN6@CMemManage

; 24   : 	{
; 25   : 		m_stConfig.nMaxList[i] = 4;

  0010e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00118	c7 84 81 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+176], 4

; 26   : 	}

  00123	eb d8		 jmp	 SHORT $LN5@CMemManage
$LN6@CMemManage:

; 27   : 	for (i = IDX_BUF_64k; i < IDX_BUF_512k; i++)

  00125	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR i$[rsp], 16
  0012d	eb 0a		 jmp	 SHORT $LN10@CMemManage
$LN8@CMemManage:
  0012f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00133	ff c0		 inc	 eax
  00135	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@CMemManage:
  00139	83 7c 24 20 13	 cmp	 DWORD PTR i$[rsp], 19
  0013e	7d 17		 jge	 SHORT $LN9@CMemManage

; 28   : 	{
; 29   : 		m_stConfig.nMaxList[i] = 2;

  00140	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00145	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0014a	c7 84 81 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+176], 2

; 30   : 	}

  00155	eb d8		 jmp	 SHORT $LN8@CMemManage
$LN9@CMemManage:

; 31   : 	m_stConfig.nMaxList[IDX_BUF_1m] = 1;

  00157	b8 04 00 00 00	 mov	 eax, 4
  0015c	48 6b c0 14	 imul	 rax, rax, 20
  00160	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00165	c7 84 01 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+176], 1

; 32   : }

  00170	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00175	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00179	5f		 pop	 rdi
  0017a	c3		 ret	 0
??0CMemManager@@QEAA@XZ ENDP				; CMemManager::CMemManager
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GCBufPool@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCBufPool@@QEAAPEAXI@Z PROC				; CBufPool::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ??1CBufPool@@QEAA@XZ	; CBufPool::~CBufPool
  0002c	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 0f		 je	 SHORT $LN2@scalar
  00037	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
??_GCBufPool@@QEAAPEAXI@Z ENDP				; CBufPool::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
m$ = 32
$S1$ = 56
tv80 = 68
tv73 = 72
s$ = 96
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 14 00 00 00	 mov	 ecx, 20
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 60	 mov	 ecx, DWORD PTR [rsp+96]
  0001c	f2 0f 2a 44 24
	60		 cvtsi2sd xmm0, DWORD PTR s$[rsp]
  00022	f2 0f 11 44 24
	38		 movsd	 QWORD PTR $S1$[rsp], xmm0
  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	48 6b c0 01	 imul	 rax, rax, 1
  00031	8b 44 04 38	 mov	 eax, DWORD PTR $S1$[rsp+rax]
  00035	c1 f8 14	 sar	 eax, 20
  00038	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  0003d	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR m$[rsp]
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	89 4c 24 44	 mov	 DWORD PTR tv80[rsp], ecx
  0004e	0f b6 c8	 movzx	 ecx, al
  00051	8b 44 24 44	 mov	 eax, DWORD PTR tv80[rsp]
  00055	d3 e0		 shl	 eax, cl
  00057	8b 4c 24 60	 mov	 ecx, DWORD PTR s$[rsp]
  0005b	2b c8		 sub	 ecx, eax
  0005d	8b c1		 mov	 eax, ecx
  0005f	8b 4c 24 60	 mov	 ecx, DWORD PTR s$[rsp]
  00063	23 c8		 and	 ecx, eax
  00065	8b c1		 mov	 eax, ecx
  00067	85 c0		 test	 eax, eax
  00069	74 0a		 je	 SHORT $LN3@getIndex
  0006b	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00073	eb 08		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  00075	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN4@getIndex:
  0007d	8b 44 24 48	 mov	 eax, DWORD PTR tv73[rsp]
  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR m$[rsp]
  00085	03 c8		 add	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	8b f8		 mov	 edi, eax
  0008b	48 8b cc	 mov	 rcx, rsp
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?getIndex@@YAHH@Z$rtcFrameData
  00095	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0009a	8b c7		 mov	 eax, edi
  0009c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
__$ArrayPad$ = 80
_Format$ = 112
printf	PROC						; COMDAT

; 950  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 18 00 00 00	 mov	 ecx, 24
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  0003c	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  00041	48 8d 44 24 78	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00046	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0004b	b9 01 00 00 00	 mov	 ecx, 1
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00056	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Format$[rsp]
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 _vfprintf_l
  0006b	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

  0006f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

  00078	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 957  : }

  0007c	8b f8		 mov	 edi, eax
  0007e	48 8b cc	 mov	 rcx, rsp
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:printf$rtcFrameData
  00088	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0008d	8b c7		 mov	 eax, edi
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00094	48 33 cc	 xor	 rcx, rsp
  00097	e8 00 00 00 00	 call	 __security_check_cookie
  0009c	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 144  :         {

$LN3:
  00000	40 57		 push	 rdi

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00002	5f		 pop	 rdi
  00003	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00041	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
