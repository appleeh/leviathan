; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comHash.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG9056	DB	'%s hashMap key distribution m_nMaxCount[%d]', 0aH, 00H
	ORG $+3
$SG9058	DB	' --- m_pHashData[%d] useCount[%d]', 0aH, 00H
	ORG $+1
$SG9061	DB	' m_nMaxCount[%d] usedKeyCount[%d]', 0aH, 00H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	__tcsncpy
PUBLIC	__tcscmp
PUBLIC	??0CHash@@QAE@I@Z				; CHash::CHash
PUBLIC	??1CHash@@QAE@XZ				; CHash::~CHash
PUBLIC	?clear@CHash@@QAEXXZ				; CHash::clear
PUBLIC	?getHashNo@CHash@@QAEIPAD@Z			; CHash::getHashNo
PUBLIC	?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z	; CHash::hashLookup
PUBLIC	?hashLookup@CHash@@QAEPAUSTHash_Node@@IPAD@Z	; CHash::hashLookup
PUBLIC	?getNext@CHash@@QAEPAUSThash_next@@I@Z		; CHash::getNext
PUBLIC	?getNext@CHash@@QAEPAUSThash_next@@PAD@Z	; CHash::getNext
PUBLIC	?getNode@CHash@@QAEPAUSThash_next@@PADPAPAU2@@Z	; CHash::getNode
PUBLIC	?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@PADPAX@Z ; CHash::setValue
PUBLIC	?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@IPADPAX@Z ; CHash::setValue
PUBLIC	?addNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z	; CHash::addNode
PUBLIC	?uniqueAddNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z ; CHash::uniqueAddNode
PUBLIC	?getString@CHash@@QAEIPAD0I@Z			; CHash::getString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___mbscmp:PROC
EXTRN	__imp___mbsnbcpy:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_nUseCount$ = -4656					; size = 4
_nStrSize$ = -4652					; size = 4
_nNextPos$ = -4648					; size = 4
_j$ = -4644						; size = 4
_i$ = -4640						; size = 4
_szUnit$ = -4632					; size = 512
_szBuf$ = -4112						; size = 4096
_pNext$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTitle$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nBufMax$ = 16						; size = 4
?getString@CHash@@QAEIPAD0I@Z PROC			; CHash::getString
; _this$ = ecx

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 30 12 00 00	 mov	 eax, 4656		; 00001230H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	51		 push	 ecx
  0000f	8d bd d0 ed ff
	ff		 lea	 edi, DWORD PTR [ebp-4656]
  00015	b9 8c 04 00 00	 mov	 ecx, 1164		; 0000048cH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	59		 pop	 ecx
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 	/*
; 178  : 	TCHAR szBuf[128];
; 179  : 	size_t nSize[5];
; 180  : 	memset(nSize, 0, sizeof(nSize));
; 181  : 	int i, cnt = 0;
; 182  : 	nSize[cnt++] = sizeof(m_pHashData);
; 183  : 	nSize[cnt++] = sizeof(SThash_value);
; 184  : 	_stprintf(szBuf, _T("%s m_pHashData's size:%ul maxCount:%d, unitSize:%d\n"), pTitle, nSize[0], m_nMaxCount, nSize[1]);
; 185  : 	_tcscpy(pBuf, szBuf);
; 186  : 	for (i = 0; i < cnt; i++)
; 187  : 	{
; 188  : 		nSize[4] += nSize[i];
; 189  : 	}
; 190  : 	return nSize[4];
; 191  : 	*/
; 192  : 
; 193  : 	SThash_next *pNext;
; 194  : 	TCHAR szBuf[4096], szUnit[512];
; 195  : 	unsigned int i,j, nNextPos=0, nStrSize, nUseCount=0;

  0002f	c7 85 d8 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _nNextPos$[ebp], 0
  00039	c7 85 d0 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _nUseCount$[ebp], 0

; 196  : 
; 197  : 	_stprintf(szUnit, _T("%s hashMap key distribution m_nMaxCount[%d]\n"), pTitle, m_nMaxCount);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	51		 push	 ecx
  00049	8b 55 08	 mov	 edx, DWORD PTR _pTitle$[ebp]
  0004c	52		 push	 edx
  0004d	68 00 00 00 00	 push	 OFFSET $SG9056
  00052	8d 85 e8 ed ff
	ff		 lea	 eax, DWORD PTR _szUnit$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _sprintf
  0005e	83 c4 10	 add	 esp, 16			; 00000010H

; 198  : 	nStrSize = (int)_tcslen(szUnit);

  00061	8d 8d e8 ed ff
	ff		 lea	 ecx, DWORD PTR _szUnit$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _strlen
  0006d	83 c4 04	 add	 esp, 4
  00070	89 85 d4 ed ff
	ff		 mov	 DWORD PTR _nStrSize$[ebp], eax

; 199  : 	_tcscpy(szBuf + nNextPos, szUnit);

  00076	8d 95 e8 ed ff
	ff		 lea	 edx, DWORD PTR _szUnit$[ebp]
  0007c	52		 push	 edx
  0007d	8b 85 d8 ed ff
	ff		 mov	 eax, DWORD PTR _nNextPos$[ebp]
  00083	8d 8c 05 f0 ef
	ff ff		 lea	 ecx, DWORD PTR _szBuf$[ebp+eax]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 _strcpy
  00090	83 c4 08	 add	 esp, 8

; 200  : 	nNextPos += nStrSize;

  00093	8b 95 d8 ed ff
	ff		 mov	 edx, DWORD PTR _nNextPos$[ebp]
  00099	03 95 d4 ed ff
	ff		 add	 edx, DWORD PTR _nStrSize$[ebp]
  0009f	89 95 d8 ed ff
	ff		 mov	 DWORD PTR _nNextPos$[ebp], edx

; 201  : 
; 202  : 	for (i = 0; i < m_nMaxCount; i++)

  000a5	c7 85 e0 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000af	eb 0f		 jmp	 SHORT $LN4@getString
$LN2@getString:
  000b1	8b 85 e0 ed ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000b7	83 c0 01	 add	 eax, 1
  000ba	89 85 e0 ed ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@getString:
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	8b 95 e0 ed ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000c9	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000cb	0f 83 e6 00 00
	00		 jae	 $LN3@getString

; 203  : 	{
; 204  : 		j = 0;

  000d1	c7 85 dc ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0

; 205  : 		for (pNext = m_pHashData[i].pNext; pNext != NULL; pNext = pNext->next) { j++; }

  000db	6b 85 e0 ed ff
	ff 0c		 imul	 eax, DWORD PTR _i$[ebp], 12
  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000e8	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  000ec	89 45 f4	 mov	 DWORD PTR _pNext$[ebp], eax
  000ef	eb 09		 jmp	 SHORT $LN7@getString
$LN5@getString:
  000f1	8b 4d f4	 mov	 ecx, DWORD PTR _pNext$[ebp]
  000f4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f7	89 55 f4	 mov	 DWORD PTR _pNext$[ebp], edx
$LN7@getString:
  000fa	83 7d f4 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  000fe	74 11		 je	 SHORT $LN6@getString
  00100	8b 85 dc ed ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00106	83 c0 01	 add	 eax, 1
  00109	89 85 dc ed ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
  0010f	eb e0		 jmp	 SHORT $LN5@getString
$LN6@getString:

; 206  : 		if (j) {

  00111	83 bd dc ed ff
	ff 00		 cmp	 DWORD PTR _j$[ebp], 0
  00118	0f 84 94 00 00
	00		 je	 $LN8@getString

; 207  : 			_stprintf(szUnit, _T(" --- m_pHashData[%d] useCount[%d]\n"), i, j);

  0011e	8b 8d dc ed ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00124	51		 push	 ecx
  00125	8b 95 e0 ed ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0012b	52		 push	 edx
  0012c	68 00 00 00 00	 push	 OFFSET $SG9058
  00131	8d 85 e8 ed ff
	ff		 lea	 eax, DWORD PTR _szUnit$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _sprintf
  0013d	83 c4 10	 add	 esp, 16			; 00000010H

; 208  : 			nStrSize = (int)_tcslen(szUnit);

  00140	8d 8d e8 ed ff
	ff		 lea	 ecx, DWORD PTR _szUnit$[ebp]
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 _strlen
  0014c	83 c4 04	 add	 esp, 4
  0014f	89 85 d4 ed ff
	ff		 mov	 DWORD PTR _nStrSize$[ebp], eax

; 209  : 			if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  00155	8b 95 d4 ed ff
	ff		 mov	 edx, DWORD PTR _nStrSize$[ebp]
  0015b	8b 85 d8 ed ff
	ff		 mov	 eax, DWORD PTR _nNextPos$[ebp]
  00161	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00165	39 4d 10	 cmp	 DWORD PTR _nBufMax$[ebp], ecx
  00168	73 0a		 jae	 SHORT $LN9@getString
  0016a	e9 c6 00 00 00	 jmp	 $ENDPROC$18
  0016f	e9 c1 00 00 00	 jmp	 $ENDPROC$18
$LN9@getString:

; 210  : 			_tcscpy(szBuf+nNextPos, szUnit);

  00174	8d 95 e8 ed ff
	ff		 lea	 edx, DWORD PTR _szUnit$[ebp]
  0017a	52		 push	 edx
  0017b	8b 85 d8 ed ff
	ff		 mov	 eax, DWORD PTR _nNextPos$[ebp]
  00181	8d 8c 05 f0 ef
	ff ff		 lea	 ecx, DWORD PTR _szBuf$[ebp+eax]
  00188	51		 push	 ecx
  00189	e8 00 00 00 00	 call	 _strcpy
  0018e	83 c4 08	 add	 esp, 8

; 211  : 			nNextPos += nStrSize;

  00191	8b 95 d8 ed ff
	ff		 mov	 edx, DWORD PTR _nNextPos$[ebp]
  00197	03 95 d4 ed ff
	ff		 add	 edx, DWORD PTR _nStrSize$[ebp]
  0019d	89 95 d8 ed ff
	ff		 mov	 DWORD PTR _nNextPos$[ebp], edx

; 212  : 
; 213  : 			nUseCount++;

  001a3	8b 85 d0 ed ff
	ff		 mov	 eax, DWORD PTR _nUseCount$[ebp]
  001a9	83 c0 01	 add	 eax, 1
  001ac	89 85 d0 ed ff
	ff		 mov	 DWORD PTR _nUseCount$[ebp], eax
$LN8@getString:

; 214  : 		}
; 215  : 	}

  001b2	e9 fa fe ff ff	 jmp	 $LN2@getString
$LN3@getString:

; 216  : 	_stprintf(szUnit, _T(" m_nMaxCount[%d] usedKeyCount[%d]\n"), m_nMaxCount, nUseCount);

  001b7	8b 8d d0 ed ff
	ff		 mov	 ecx, DWORD PTR _nUseCount$[ebp]
  001bd	51		 push	 ecx
  001be	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001c1	8b 02		 mov	 eax, DWORD PTR [edx]
  001c3	50		 push	 eax
  001c4	68 00 00 00 00	 push	 OFFSET $SG9061
  001c9	8d 8d e8 ed ff
	ff		 lea	 ecx, DWORD PTR _szUnit$[ebp]
  001cf	51		 push	 ecx
  001d0	e8 00 00 00 00	 call	 _sprintf
  001d5	83 c4 10	 add	 esp, 16			; 00000010H

; 217  : 	nStrSize = (int)_tcslen(szUnit);

  001d8	8d 95 e8 ed ff
	ff		 lea	 edx, DWORD PTR _szUnit$[ebp]
  001de	52		 push	 edx
  001df	e8 00 00 00 00	 call	 _strlen
  001e4	83 c4 04	 add	 esp, 4
  001e7	89 85 d4 ed ff
	ff		 mov	 DWORD PTR _nStrSize$[ebp], eax

; 218  : 	if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  001ed	8b 85 d4 ed ff
	ff		 mov	 eax, DWORD PTR _nStrSize$[ebp]
  001f3	8b 8d d8 ed ff
	ff		 mov	 ecx, DWORD PTR _nNextPos$[ebp]
  001f9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  001fd	39 55 10	 cmp	 DWORD PTR _nBufMax$[ebp], edx
  00200	73 04		 jae	 SHORT $LN11@getString
  00202	eb 31		 jmp	 SHORT $ENDPROC$18
  00204	eb 2f		 jmp	 SHORT $ENDPROC$18
$LN11@getString:

; 219  : 	_tcscpy(szBuf + nNextPos, szUnit);

  00206	8d 85 e8 ed ff
	ff		 lea	 eax, DWORD PTR _szUnit$[ebp]
  0020c	50		 push	 eax
  0020d	8b 8d d8 ed ff
	ff		 mov	 ecx, DWORD PTR _nNextPos$[ebp]
  00213	8d 94 0d f0 ef
	ff ff		 lea	 edx, DWORD PTR _szBuf$[ebp+ecx]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 _strcpy
  00220	83 c4 08	 add	 esp, 8

; 220  : 	nNextPos += nStrSize;

  00223	8b 85 d8 ed ff
	ff		 mov	 eax, DWORD PTR _nNextPos$[ebp]
  00229	03 85 d4 ed ff
	ff		 add	 eax, DWORD PTR _nStrSize$[ebp]
  0022f	89 85 d8 ed ff
	ff		 mov	 DWORD PTR _nNextPos$[ebp], eax
$ENDPROC$18:

; 221  : 
; 222  : ENDPROC:
; 223  : 	_tcsncpy(pBuf, szBuf, nNextPos);

  00235	8b 8d d8 ed ff
	ff		 mov	 ecx, DWORD PTR _nNextPos$[ebp]
  0023b	51		 push	 ecx
  0023c	8d 95 f0 ef ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  00242	52		 push	 edx
  00243	8b 45 0c	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 __tcsncpy
  0024c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  : 	pBuf[nNextPos] = 0;

  0024f	8b 4d 0c	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00252	03 8d d8 ed ff
	ff		 add	 ecx, DWORD PTR _nNextPos$[ebp]
  00258	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 225  : 	return nNextPos;

  0025b	8b 85 d8 ed ff
	ff		 mov	 eax, DWORD PTR _nNextPos$[ebp]

; 226  : }

  00261	52		 push	 edx
  00262	8b cd		 mov	 ecx, ebp
  00264	50		 push	 eax
  00265	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@getString
  0026b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00270	58		 pop	 eax
  00271	5a		 pop	 edx
  00272	5f		 pop	 edi
  00273	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00276	33 cd		 xor	 ecx, ebp
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	81 c4 30 12 00
	00		 add	 esp, 4656		; 00001230H
  00283	3b ec		 cmp	 ebp, esp
  00285	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028a	8b e5		 mov	 esp, ebp
  0028c	5d		 pop	 ebp
  0028d	c2 0c 00	 ret	 12			; 0000000cH
$LN17@getString:
  00290	02 00 00 00	 DD	 2
  00294	00 00 00 00	 DD	 $LN16@getString
$LN16@getString:
  00298	f0 ef ff ff	 DD	 -4112			; ffffeff0H
  0029c	00 10 00 00	 DD	 4096			; 00001000H
  002a0	00 00 00 00	 DD	 $LN14@getString
  002a4	e8 ed ff ff	 DD	 -4632			; ffffede8H
  002a8	00 02 00 00	 DD	 512			; 00000200H
  002ac	00 00 00 00	 DD	 $LN15@getString
$LN15@getString:
  002b0	73		 DB	 115			; 00000073H
  002b1	7a		 DB	 122			; 0000007aH
  002b2	55		 DB	 85			; 00000055H
  002b3	6e		 DB	 110			; 0000006eH
  002b4	69		 DB	 105			; 00000069H
  002b5	74		 DB	 116			; 00000074H
  002b6	00		 DB	 0
$LN14@getString:
  002b7	73		 DB	 115			; 00000073H
  002b8	7a		 DB	 122			; 0000007aH
  002b9	42		 DB	 66			; 00000042H
  002ba	75		 DB	 117			; 00000075H
  002bb	66		 DB	 102			; 00000066H
  002bc	00		 DB	 0
?getString@CHash@@QAEIPAD0I@Z ENDP			; CHash::getString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_nHashNo$ = -12						; size = 4
_pNextAddr$ = -8					; size = 4
_this$ = -4						; size = 4
_pNext$ = 8						; size = 4
_pKey$ = 12						; size = 4
_pData$ = 16						; size = 4
?uniqueAddNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z PROC	; CHash::uniqueAddNode
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 	SThash_next **pNextAddr;
; 153  : 
; 154  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pKey$[ebp]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QAEIPAD@Z ; CHash::getHashNo
  0002a	89 45 f4	 mov	 DWORD PTR _nHashNo$[ebp], eax

; 155  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 55 f4	 mov	 edx, DWORD PTR _nHashNo$[ebp]
  00033	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00035	72 0a		 jb	 SHORT $LN5@uniqueAddN
  00037	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0003c	e9 c7 00 00 00	 jmp	 $LN1@uniqueAddN
$LN5@uniqueAddN:

; 156  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00041	83 7d 08 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00045	75 0a		 jne	 SHORT $LN6@uniqueAddN
  00047	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004c	e9 b7 00 00 00	 jmp	 $LN1@uniqueAddN
$LN6@uniqueAddN:

; 157  : 
; 158  : 
; 159  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) 

  00051	6b 45 f4 0c	 imul	 eax, DWORD PTR _nHashNo$[ebp], 12
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005b	8d 44 02 08	 lea	 eax, DWORD PTR [edx+eax+8]
  0005f	89 45 f8	 mov	 DWORD PTR _pNextAddr$[ebp], eax
  00062	eb 0b		 jmp	 SHORT $LN4@uniqueAddN
$LN2@uniqueAddN:
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _pNextAddr$[ebp]
  00067	8b 11		 mov	 edx, DWORD PTR [ecx]
  00069	83 c2 08	 add	 edx, 8
  0006c	89 55 f8	 mov	 DWORD PTR _pNextAddr$[ebp], edx
$LN4@uniqueAddN:
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _pNextAddr$[ebp]
  00072	83 38 00	 cmp	 DWORD PTR [eax], 0
  00075	74 1d		 je	 SHORT $LN3@uniqueAddN

; 160  : 	{
; 161  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0) return eHASH_RESULT_DUPLICATE_KEYS;

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0007a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007c	52		 push	 edx
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _pKey$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 __tcscmp
  00086	83 c4 08	 add	 esp, 8
  00089	85 c0		 test	 eax, eax
  0008b	75 05		 jne	 SHORT $LN7@uniqueAddN
  0008d	83 c8 ff	 or	 eax, -1
  00090	eb 76		 jmp	 SHORT $LN1@uniqueAddN
$LN7@uniqueAddN:

; 162  : 	}

  00092	eb d0		 jmp	 SHORT $LN2@uniqueAddN
$LN3@uniqueAddN:

; 163  : 
; 164  : 	pNext->pNode.pKey = pKey;

  00094	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00097	8b 55 0c	 mov	 edx, DWORD PTR _pKey$[ebp]
  0009a	89 11		 mov	 DWORD PTR [ecx], edx

; 165  : 	pNext->pNode.value = pData;

  0009c	8b 45 08	 mov	 eax, DWORD PTR _pNext$[ebp]
  0009f	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  000a2	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 166  : 	pNext->next = NULL;

  000a5	8b 55 08	 mov	 edx, DWORD PTR _pNext$[ebp]
  000a8	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 167  : 	*pNextAddr = pNext;

  000af	8b 45 f8	 mov	 eax, DWORD PTR _pNextAddr$[ebp]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  000b5	89 08		 mov	 DWORD PTR [eax], ecx

; 168  : 
; 169  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  000b7	6b 55 f4 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c1	83 3c 11 00	 cmp	 DWORD PTR [ecx+edx], 0
  000c5	75 10		 jne	 SHORT $LN8@uniqueAddN
  000c7	6b 55 f4 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  000cb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d1	8b 45 f4	 mov	 eax, DWORD PTR _nHashNo$[ebp]
  000d4	89 04 11	 mov	 DWORD PTR [ecx+edx], eax
$LN8@uniqueAddN:

; 170  : 	m_pHashData[nHashNo].nElementCnt++;

  000d7	6b 4d f4 0c	 imul	 ecx, DWORD PTR _nHashNo$[ebp], 12
  000db	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000de	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e1	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  000e5	83 c1 01	 add	 ecx, 1
  000e8	6b 55 f4 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000f2	89 4c 10 04	 mov	 DWORD PTR [eax+edx+4], ecx

; 171  : 	m_nElementCount++;

  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fc	83 c2 01	 add	 edx, 1
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 172  : 	return nHashNo;

  00105	8b 45 f4	 mov	 eax, DWORD PTR _nHashNo$[ebp]
$LN1@uniqueAddN:

; 173  : }

  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	3b ec		 cmp	 ebp, esp
  0010d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 0c 00	 ret	 12			; 0000000cH
?uniqueAddNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z ENDP	; CHash::uniqueAddNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_nHashNo$ = -12						; size = 4
_pNextAddr$ = -8					; size = 4
_this$ = -4						; size = 4
_pNext$ = 8						; size = 4
_pKey$ = 12						; size = 4
_pData$ = 16						; size = 4
?addNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z PROC	; CHash::addNode
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	SThash_next **pNextAddr;
; 131  : 
; 132  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pKey$[ebp]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QAEIPAD@Z ; CHash::getHashNo
  0002a	89 45 f4	 mov	 DWORD PTR _nHashNo$[ebp], eax

; 133  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 55 f4	 mov	 edx, DWORD PTR _nHashNo$[ebp]
  00033	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00035	72 0a		 jb	 SHORT $LN5@addNode
  00037	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0003c	e9 ac 00 00 00	 jmp	 $LN1@addNode
$LN5@addNode:

; 134  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00041	83 7d 08 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00045	75 0a		 jne	 SHORT $LN6@addNode
  00047	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004c	e9 9c 00 00 00	 jmp	 $LN1@addNode
$LN6@addNode:

; 135  : 
; 136  : 	
; 137  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) {}

  00051	6b 45 f4 0c	 imul	 eax, DWORD PTR _nHashNo$[ebp], 12
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005b	8d 44 02 08	 lea	 eax, DWORD PTR [edx+eax+8]
  0005f	89 45 f8	 mov	 DWORD PTR _pNextAddr$[ebp], eax
  00062	eb 0b		 jmp	 SHORT $LN4@addNode
$LN2@addNode:
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _pNextAddr$[ebp]
  00067	8b 11		 mov	 edx, DWORD PTR [ecx]
  00069	83 c2 08	 add	 edx, 8
  0006c	89 55 f8	 mov	 DWORD PTR _pNextAddr$[ebp], edx
$LN4@addNode:
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _pNextAddr$[ebp]
  00072	83 38 00	 cmp	 DWORD PTR [eax], 0
  00075	74 02		 je	 SHORT $LN3@addNode
  00077	eb eb		 jmp	 SHORT $LN2@addNode
$LN3@addNode:

; 138  : 	pNext->pNode.pKey = pKey;

  00079	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0007c	8b 55 0c	 mov	 edx, DWORD PTR _pKey$[ebp]
  0007f	89 11		 mov	 DWORD PTR [ecx], edx

; 139  : 	pNext->pNode.value = pData;

  00081	8b 45 08	 mov	 eax, DWORD PTR _pNext$[ebp]
  00084	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  00087	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 140  : 	pNext->next = NULL;

  0008a	8b 55 08	 mov	 edx, DWORD PTR _pNext$[ebp]
  0008d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 141  : 	*pNextAddr = pNext;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _pNextAddr$[ebp]
  00097	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 142  : 
; 143  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  0009c	6b 55 f4 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a6	83 3c 11 00	 cmp	 DWORD PTR [ecx+edx], 0
  000aa	75 10		 jne	 SHORT $LN7@addNode
  000ac	6b 55 f4 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  000b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b6	8b 45 f4	 mov	 eax, DWORD PTR _nHashNo$[ebp]
  000b9	89 04 11	 mov	 DWORD PTR [ecx+edx], eax
$LN7@addNode:

; 144  : 	m_pHashData[nHashNo].nElementCnt++;

  000bc	6b 4d f4 0c	 imul	 ecx, DWORD PTR _nHashNo$[ebp], 12
  000c0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000c6	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  000ca	83 c1 01	 add	 ecx, 1
  000cd	6b 55 f4 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  000d1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d7	89 4c 10 04	 mov	 DWORD PTR [eax+edx+4], ecx

; 145  : 	m_nElementCount++;

  000db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e1	83 c2 01	 add	 edx, 1
  000e4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 146  : 	return nHashNo;

  000ea	8b 45 f4	 mov	 eax, DWORD PTR _nHashNo$[ebp]
$LN1@addNode:

; 147  : }

  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 0c 00	 ret	 12			; 0000000cH
?addNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z ENDP	; CHash::addNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_pNext$ = -8						; size = 4
_this$ = -4						; size = 4
_nHashNo$ = 8						; size = 4
_pKey$ = 12						; size = 4
_pData$ = 16						; size = 4
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@IPADPAX@Z PROC ; CHash::setValue
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 	SThash_next *pNext;
; 113  : 
; 114  : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00017	6b 45 08 0c	 imul	 eax, DWORD PTR _nHashNo$[ebp], 12
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00021	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00025	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax
  00028	eb 09		 jmp	 SHORT $LN4@setValue
$LN2@setValue:
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0002d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00030	89 55 f8	 mov	 DWORD PTR _pNext$[ebp], edx
$LN4@setValue:
  00033	83 7d f8 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00037	74 25		 je	 SHORT $LN3@setValue

; 115  : 	{
; 116  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  00039	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	51		 push	 ecx
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _pKey$[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 __tcscmp
  00048	83 c4 08	 add	 esp, 8
  0004b	85 c0		 test	 eax, eax
  0004d	75 0d		 jne	 SHORT $LN5@setValue

; 117  : 		{
; 118  : 			pNext->pNode.value = pData;

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00052	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 119  : 			return eHASH_RESULT_SUCESS;

  00058	33 c0		 xor	 eax, eax
  0005a	eb 07		 jmp	 SHORT $LN1@setValue
$LN5@setValue:

; 120  : 		}
; 121  : 	}

  0005c	eb cc		 jmp	 SHORT $LN2@setValue
$LN3@setValue:

; 122  : 	return eHASH_RESULT_NOT_FOUND;

  0005e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
$LN1@setValue:

; 123  : }

  00063	83 c4 08	 add	 esp, 8
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 0c 00	 ret	 12			; 0000000cH
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@IPADPAX@Z ENDP ; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_pNode$ = -8						; size = 4
_this$ = -4						; size = 4
_pKey$ = 8						; size = 4
_pData$ = 12						; size = 4
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@PADPAX@Z PROC	; CHash::setValue
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 	STHash_Node *pNode = hashLookup(pKey);

  00017	8b 45 08	 mov	 eax, DWORD PTR _pKey$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z ; CHash::hashLookup
  00023	89 45 f8	 mov	 DWORD PTR _pNode$[ebp], eax

; 103  : 	if (pNode) {

  00026	83 7d f8 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  0002a	74 0d		 je	 SHORT $LN2@setValue

; 104  : 		pNode->value = pData;

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0002f	8b 55 0c	 mov	 edx, DWORD PTR _pData$[ebp]
  00032	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 105  : 		return eHASH_RESULT_SUCESS;

  00035	33 c0		 xor	 eax, eax
  00037	eb 05		 jmp	 SHORT $LN1@setValue
$LN2@setValue:

; 106  : 	}
; 107  : 	return eHASH_RESULT_NOT_FOUND;

  00039	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
$LN1@setValue:

; 108  : }

  0003e	83 c4 08	 add	 esp, 8
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@PADPAX@Z ENDP	; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_nHashNo$ = -12						; size = 4
_pNext$ = -8						; size = 4
_this$ = -4						; size = 4
_pStr$ = 8						; size = 4
_prevNext$ = 12						; size = 4
?getNode@CHash@@QAEPAUSThash_next@@PADPAPAU2@@Z PROC	; CHash::getNode
; _this$ = ecx

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 87   : 	SThash_next *pNext;
; 88   : 	HASH_TYPE nHashNo = getHashNo(pStr);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pStr$[ebp]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QAEIPAD@Z ; CHash::getHashNo
  0002a	89 45 f4	 mov	 DWORD PTR _nHashNo$[ebp], eax

; 89   : 
; 90   : 	prevNext = &m_pHashData[nHashNo].pNext;

  0002d	6b 4d f4 0c	 imul	 ecx, DWORD PTR _nHashNo$[ebp], 12
  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	8d 4c 08 08	 lea	 ecx, DWORD PTR [eax+ecx+8]
  0003b	89 4d 0c	 mov	 DWORD PTR _prevNext$[ebp], ecx

; 91   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  0003e	6b 55 f4 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00048	8b 54 11 08	 mov	 edx, DWORD PTR [ecx+edx+8]
  0004c	89 55 f8	 mov	 DWORD PTR _pNext$[ebp], edx
  0004f	eb 09		 jmp	 SHORT $LN4@getNode
$LN2@getNode:
  00051	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00054	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00057	89 4d f8	 mov	 DWORD PTR _pNext$[ebp], ecx
$LN4@getNode:
  0005a	83 7d f8 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  0005e	74 26		 je	 SHORT $LN3@getNode

; 92   : 	{
; 93   : 		if (_tcscmp(pStr, pNext->pNode.pKey) == 0) return pNext;

  00060	8b 55 f8	 mov	 edx, DWORD PTR _pNext$[ebp]
  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	50		 push	 eax
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _pStr$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 __tcscmp
  0006f	83 c4 08	 add	 esp, 8
  00072	85 c0		 test	 eax, eax
  00074	75 05		 jne	 SHORT $LN5@getNode
  00076	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00079	eb 0d		 jmp	 SHORT $LN1@getNode
$LN5@getNode:

; 94   : 		prevNext = &(pNext->next);

  0007b	8b 55 f8	 mov	 edx, DWORD PTR _pNext$[ebp]
  0007e	83 c2 08	 add	 edx, 8
  00081	89 55 0c	 mov	 DWORD PTR _prevNext$[ebp], edx

; 95   : 	}

  00084	eb cb		 jmp	 SHORT $LN2@getNode
$LN3@getNode:

; 96   : 
; 97   : 	return NULL;

  00086	33 c0		 xor	 eax, eax
$LN1@getNode:

; 98   : }

  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?getNode@CHash@@QAEPAUSThash_next@@PADPAPAU2@@Z ENDP	; CHash::getNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_nHashNo$ = -8						; size = 4
_this$ = -4						; size = 4
_pStr$ = 8						; size = 4
?getNext@CHash@@QAEPAUSThash_next@@PAD@Z PROC		; CHash::getNext
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 	HASH_TYPE nHashNo = getHashNo(pStr);

  00017	8b 45 08	 mov	 eax, DWORD PTR _pStr$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QAEIPAD@Z ; CHash::getHashNo
  00023	89 45 f8	 mov	 DWORD PTR _nHashNo$[ebp], eax

; 82   : 	return m_pHashData[nHashNo].pNext;

  00026	6b 4d f8 0c	 imul	 ecx, DWORD PTR _nHashNo$[ebp], 12
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00030	8b 44 08 08	 mov	 eax, DWORD PTR [eax+ecx+8]

; 83   : }

  00034	83 c4 08	 add	 esp, 8
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?getNext@CHash@@QAEPAUSThash_next@@PAD@Z ENDP		; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nHashKey$ = 8						; size = 4
?getNext@CHash@@QAEPAUSThash_next@@I@Z PROC		; CHash::getNext
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 73   : 	if (nHashKey >= m_nMaxCount) return NULL;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _nHashKey$[ebp]
  00014	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00016	72 04		 jb	 SHORT $LN2@getNext
  00018	33 c0		 xor	 eax, eax
  0001a	eb 0e		 jmp	 SHORT $LN1@getNext
$LN2@getNext:

; 74   : 
; 75   : 	return m_pHashData[nHashKey].pNext;

  0001c	6b 55 08 0c	 imul	 edx, DWORD PTR _nHashKey$[ebp], 12
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00026	8b 44 11 08	 mov	 eax, DWORD PTR [ecx+edx+8]
$LN1@getNext:

; 76   : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?getNext@CHash@@QAEPAUSThash_next@@I@Z ENDP		; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_pNext$ = -8						; size = 4
_this$ = -4						; size = 4
_nHashNo$ = 8						; size = 4
_pKey$ = 12						; size = 4
?hashLookup@CHash@@QAEPAUSTHash_Node@@IPAD@Z PROC	; CHash::hashLookup
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 	SThash_next *pNext;
; 61   : 	if(nHashNo >= m_nMaxCount) return NULL;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _nHashNo$[ebp]
  0001d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0001f	72 04		 jb	 SHORT $LN5@hashLookup
  00021	33 c0		 xor	 eax, eax
  00023	eb 41		 jmp	 SHORT $LN1@hashLookup
$LN5@hashLookup:

; 62   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00025	6b 55 08 0c	 imul	 edx, DWORD PTR _nHashNo$[ebp], 12
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002f	8b 54 11 08	 mov	 edx, DWORD PTR [ecx+edx+8]
  00033	89 55 f8	 mov	 DWORD PTR _pNext$[ebp], edx
  00036	eb 09		 jmp	 SHORT $LN4@hashLookup
$LN2@hashLookup:
  00038	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  0003b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003e	89 4d f8	 mov	 DWORD PTR _pNext$[ebp], ecx
$LN4@hashLookup:
  00041	83 7d f8 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  00045	74 1d		 je	 SHORT $LN3@hashLookup

; 63   : 	{
; 64   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  00047	8b 55 f8	 mov	 edx, DWORD PTR _pNext$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	50		 push	 eax
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _pKey$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 __tcscmp
  00056	83 c4 08	 add	 esp, 8
  00059	85 c0		 test	 eax, eax
  0005b	75 05		 jne	 SHORT $LN6@hashLookup

; 65   : 			return &pNext->pNode;

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00060	eb 04		 jmp	 SHORT $LN1@hashLookup
$LN6@hashLookup:

; 66   : 	}

  00062	eb d4		 jmp	 SHORT $LN2@hashLookup
$LN3@hashLookup:

; 67   : 
; 68   : 	return NULL;

  00064	33 c0		 xor	 eax, eax
$LN1@hashLookup:

; 69   : 
; 70   : }

  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
?hashLookup@CHash@@QAEPAUSTHash_Node@@IPAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_nHashNo$ = -12						; size = 4
_pNext$ = -8						; size = 4
_this$ = -4						; size = 4
_pKey$ = 8						; size = 4
?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z PROC	; CHash::hashLookup
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   : 	SThash_next *pNext;
; 45   : 	HASH_TYPE nHashNo = getHashNo(pKey);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pKey$[ebp]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?getHashNo@CHash@@QAEIPAD@Z ; CHash::getHashNo
  0002a	89 45 f4	 mov	 DWORD PTR _nHashNo$[ebp], eax

; 46   : 	if(nHashNo >= m_nMaxCount) return NULL;

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 55 f4	 mov	 edx, DWORD PTR _nHashNo$[ebp]
  00033	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00035	72 04		 jb	 SHORT $LN5@hashLookup
  00037	33 c0		 xor	 eax, eax
  00039	eb 41		 jmp	 SHORT $LN1@hashLookup
$LN5@hashLookup:

; 47   : 
; 48   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  0003b	6b 45 f4 0c	 imul	 eax, DWORD PTR _nHashNo$[ebp], 12
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00045	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00049	89 45 f8	 mov	 DWORD PTR _pNext$[ebp], eax
  0004c	eb 09		 jmp	 SHORT $LN4@hashLookup
$LN2@hashLookup:
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00051	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00054	89 55 f8	 mov	 DWORD PTR _pNext$[ebp], edx
$LN4@hashLookup:
  00057	83 7d f8 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  0005b	74 1d		 je	 SHORT $LN3@hashLookup

; 49   : 	{
; 50   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR _pKey$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 __tcscmp
  0006c	83 c4 08	 add	 esp, 8
  0006f	85 c0		 test	 eax, eax
  00071	75 05		 jne	 SHORT $LN6@hashLookup

; 51   : 			return &pNext->pNode;

  00073	8b 45 f8	 mov	 eax, DWORD PTR _pNext$[ebp]
  00076	eb 04		 jmp	 SHORT $LN1@hashLookup
$LN6@hashLookup:

; 52   : 	}

  00078	eb d4		 jmp	 SHORT $LN2@hashLookup
$LN3@hashLookup:

; 53   : 
; 54   : 	return NULL;

  0007a	33 c0		 xor	 eax, eax
$LN1@hashLookup:

; 55   : 
; 56   : }

  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_key$ = -16						; size = 4
_i$ = -12						; size = 4
_nLen$ = -8						; size = 4
_this$ = -4						; size = 4
_pStr$ = 8						; size = 4
?getHashNo@CHash@@QAEIPAD@Z PROC			; CHash::getHashNo
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _pStr$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _strlen
  00023	83 c4 04	 add	 esp, 4
  00026	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _nLen$[ebp]
  0002c	89 4d f0	 mov	 DWORD PTR _key$[ebp], ecx

; 35   : 	for(i=0; i < nLen; i++) {

  0002f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00036	eb 09		 jmp	 SHORT $LN4@getHashNo
$LN2@getHashNo:
  00038	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN4@getHashNo:
  00041	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00044	3b 45 f8	 cmp	 eax, DWORD PTR _nLen$[ebp]
  00047	73 19		 jae	 SHORT $LN3@getHashNo

; 36   : 		key += (key << 4) + (int)pStr[i];

  00049	8b 4d f0	 mov	 ecx, DWORD PTR _key$[ebp]
  0004c	c1 e1 04	 shl	 ecx, 4
  0004f	8b 55 08	 mov	 edx, DWORD PTR _pStr$[ebp]
  00052	03 55 f4	 add	 edx, DWORD PTR _i$[ebp]
  00055	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00058	03 45 f0	 add	 eax, DWORD PTR _key$[ebp]
  0005b	03 c1		 add	 eax, ecx
  0005d	89 45 f0	 mov	 DWORD PTR _key$[ebp], eax

; 37   : 	}

  00060	eb d6		 jmp	 SHORT $LN2@getHashNo
$LN3@getHashNo:

; 38   : 	key = key % m_nMaxCount;

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8b 45 f0	 mov	 eax, DWORD PTR _key$[ebp]
  00068	33 d2		 xor	 edx, edx
  0006a	f7 31		 div	 DWORD PTR [ecx]
  0006c	89 55 f0	 mov	 DWORD PTR _key$[ebp], edx

; 39   : 	return key;

  0006f	8b 45 f0	 mov	 eax, DWORD PTR _key$[ebp]

; 40   : }

  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?getHashNo@CHash@@QAEIPAD@Z ENDP			; CHash::getHashNo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@CHash@@QAEXXZ PROC				; CHash::clear
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 	memset(m_pHashData, 0, sizeof(m_pHashData));

  0000e	6a 04		 push	 4
  00010	6a 00		 push	 0
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memset
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28   : }

  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?clear@CHash@@QAEXXZ ENDP				; CHash::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CHash@@QAE@XZ PROC					; CHash::~CHash
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	if(m_pHashData) {

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00016	74 23		 je	 SHORT $LN3@CHash

; 20   : 		free(m_pHashData);

  00018	8b f4		 mov	 esi, esp
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00027	83 c4 04	 add	 esp, 4
  0002a	3b f4		 cmp	 esi, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 21   : 		m_pHashData = NULL;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN3@CHash:

; 22   : 	}
; 23   : }

  0003b	5e		 pop	 esi
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??1CHash@@QAE@XZ ENDP					; CHash::~CHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comhash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_max$ = 8						; size = 4
??0CHash@@QAE@I@Z PROC					; CHash::CHash
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 11   : 	// TODO m_nMaxCount 를 2의 제곱으로 조정한다.
; 12   : 	m_nMaxCount = max;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _max$[ebp]
  00015	89 08		 mov	 DWORD PTR [eax], ecx

; 13   : 	m_nElementCount = 0;

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 14   : 	m_pHashData = (SThash_value *)calloc(m_nMaxCount, sizeof(SThash_value));

  00021	8b f4		 mov	 esi, esp
  00023	6a 0c		 push	 12			; 0000000cH
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00031	83 c4 08	 add	 esp, 8
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 15   : }

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	5e		 pop	 esi
  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
??0CHash@@QAE@I@Z ENDP					; CHash::CHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcscmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcscmp PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
__tcscmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsncpy PROC						; COMDAT

; 1542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR __Dst$[ebp]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1546 : #pragma warning(pop)
; 1547 : }

  00022	5e		 pop	 esi
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
__tcsncpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00014	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00019	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 __vsprintf_l
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	6a ff		 push	 -1
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	83 ca 01	 or	 edx, 1
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	50		 push	 eax
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00040	83 c4 1c	 add	 esp, 28			; 0000001cH
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  0004d	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00051	7d 09		 jge	 SHORT $LN3@vsnprintf_
  00053	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  0005a	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
