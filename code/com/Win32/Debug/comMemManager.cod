; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comMemManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?gs_pMMgr@@3PAVCMemManager@@A			; gs_pMMgr
PUBLIC	?g_szSystemError@@3PADA				; g_szSystemError
PUBLIC	?g_szMessage@@3PADA				; g_szMessage
_BSS	SEGMENT
?gs_pMMgr@@3PAVCMemManager@@A DD 01H DUP (?)		; gs_pMMgr
?g_szSystemError@@3PADA DB 0400H DUP (?)		; g_szSystemError
?g_szMessage@@3PADA DB 080H DUP (?)			; g_szMessage
_BSS	ENDS
CONST	SEGMENT
$SG44628 DB	'getStrToInt parsing FAIL!!! cUnit[%c]', 0aH, 00H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	??_GCBufPool@@QAEPAXI@Z				; CBufPool::`scalar deleting destructor'
PUBLIC	??0CMemManager@@QAE@XZ				; CMemManager::CMemManager
PUBLIC	??1CMemManager@@QAE@XZ				; CMemManager::~CMemManager
PUBLIC	?init@CMemManager@@QAEXPAUSTBufConf@@@Z		; CMemManager::init
PUBLIC	?init@CMemManager@@QAEHPADH@Z			; CMemManager::init
PUBLIC	?alloc@CMemManager@@QAE_NXZ			; CMemManager::alloc
PUBLIC	?delBuf@CMemManager@@QAEXPADH@Z			; CMemManager::delBuf
PUBLIC	?delBufByIndex@CMemManager@@QAEXPADH@Z		; CMemManager::delBufByIndex
PUBLIC	?getStrToInt@CMemManager@@QAEHPAD@Z		; CMemManager::getStrToInt
PUBLIC	?__newBuf@CMemManager@@AAEPADHI@Z		; CMemManager::__newBuf
PUBLIC	?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PAX@Z		; OBJ_DELETE
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__atoi:PROC
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??3@YAXPAXABUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	??0CBufPool@@QAE@XZ:PROC			; CBufPool::CBufPool
EXTRN	??1CBufPool@@QAE@XZ:PROC			; CBufPool::~CBufPool
EXTRN	?alloc@CBufPool@@QAE_NHH@Z:PROC			; CBufPool::alloc
EXTRN	?newMem@CBufPool@@QAEPADXZ:PROC			; CBufPool::newMem
EXTRN	?delMem@CBufPool@@QAEXPAD@Z:PROC		; CBufPool::delMem
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
xdata$x	SEGMENT
__unwindtable$?alloc@CMemManager@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?alloc@CMemManager@@QAE_NXZ$0
__ehfuncinfo$?alloc@CMemManager@@QAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?alloc@CMemManager@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
tv78 = -20						; size = 4
tv68 = -16						; size = 4
tv64 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_type$ = 8						; size = 4
_p$ = 12						; size = 4
?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PAX@Z PROC		; OBJ_DELETE

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 151  : 	switch (type) {

  0001b	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00021	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  00024	83 e9 02	 sub	 ecx, 2
  00027	89 4d f4	 mov	 DWORD PTR tv64[ebp], ecx
  0002a	83 7d f4 03	 cmp	 DWORD PTR tv64[ebp], 3
  0002e	0f 87 a3 00 00
	00		 ja	 $LN1@OBJ_DELETE
  00034	8b 55 f4	 mov	 edx, DWORD PTR tv64[ebp]
  00037	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN15@OBJ_DELETE[edx*4]
$LN4@OBJ_DELETE:

; 152  : 	case eAlloc_Type_new		: delete p; break;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00041	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00044	6a 00		 push	 0
  00046	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004f	83 c4 08	 add	 esp, 8
  00052	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00056	75 09		 jne	 SHORT $LN11@OBJ_DELETE
  00058	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0005f	eb 0d		 jmp	 SHORT $LN12@OBJ_DELETE
$LN11@OBJ_DELETE:
  00061	c7 45 0c 23 81
	00 00		 mov	 DWORD PTR _p$[ebp], 33059 ; 00008123H
  00068	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0006b	89 55 f0	 mov	 DWORD PTR tv68[ebp], edx
$LN12@OBJ_DELETE:
  0006e	eb 67		 jmp	 SHORT $LN1@OBJ_DELETE
$LN5@OBJ_DELETE:

; 153  : 	case eAlloc_Type_alloc		: free(p); break;

  00070	8b f4		 mov	 esi, esp
  00072	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0007c	83 c4 04	 add	 esp, 4
  0007f	3b f4		 cmp	 esi, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	eb 4f		 jmp	 SHORT $LN1@OBJ_DELETE
$LN6@OBJ_DELETE:

; 154  : 	case eAlloc_Type_BufPool	: gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _strlen
  00091	83 c4 04	 add	 esp, 4
  00094	83 c0 01	 add	 eax, 1
  00097	50		 push	 eax
  00098	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0009b	52		 push	 edx
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000a2	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
  000a7	eb 2e		 jmp	 SHORT $LN1@OBJ_DELETE
$LN7@OBJ_DELETE:

; 155  : 	case eAlloc_Type_newArray	: delete[] p; break;

  000a9	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  000ac	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  000af	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000b8	83 c4 04	 add	 esp, 4
  000bb	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  000bf	75 09		 jne	 SHORT $LN13@OBJ_DELETE
  000c1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  000c8	eb 0d		 jmp	 SHORT $LN1@OBJ_DELETE
$LN13@OBJ_DELETE:
  000ca	c7 45 0c 23 81
	00 00		 mov	 DWORD PTR _p$[ebp], 33059 ; 00008123H
  000d1	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  000d4	89 55 ec	 mov	 DWORD PTR tv78[ebp], edx
$LN1@OBJ_DELETE:

; 156  : 	case eAlloc_Type_none		: break;
; 157  : 	case eAlloc_Type_MemPool	: break;
; 158  : 	}
; 159  : }

  000d7	5e		 pop	 esi
  000d8	83 c4 14	 add	 esp, 20			; 00000014H
  000db	3b ec		 cmp	 ebp, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
  000e6	66 90		 npad	 2
$LN15@OBJ_DELETE:
  000e8	00 00 00 00	 DD	 $LN4@OBJ_DELETE
  000ec	00 00 00 00	 DD	 $LN5@OBJ_DELETE
  000f0	00 00 00 00	 DD	 $LN6@OBJ_DELETE
  000f4	00 00 00 00	 DD	 $LN7@OBJ_DELETE
?OBJ_DELETE@@YAXW4E_ALLOC_TYPE@@PAX@Z ENDP		; OBJ_DELETE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
_p$1 = -8						; size = 4
_this$ = -4						; size = 4
_nIdx$ = 8						; size = 4
_size$ = 12						; size = 4
?__newBuf@CMemManager@@AAEPADHI@Z PROC			; CMemManager::__newBuf
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 126  : 	if (IDX_BUF_2m < nIdx || !m_pBufList[nIdx]) {

  00018	83 7d 08 15	 cmp	 DWORD PTR _nIdx$[ebp], 21 ; 00000015H
  0001c	7f 0c		 jg	 SHORT $LN3@newBuf
  0001e	8b 45 08	 mov	 eax, DWORD PTR _nIdx$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00028	75 3a		 jne	 SHORT $LN2@newBuf
$LN3@newBuf:

; 127  : 		if (m_nOverMaxIdx < nIdx) m_nOverMaxIdx = nIdx;

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00033	3b 45 08	 cmp	 eax, DWORD PTR _nIdx$[ebp]
  00036	7d 0c		 jge	 SHORT $LN4@newBuf
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 55 08	 mov	 edx, DWORD PTR _nIdx$[ebp]
  0003e	89 91 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], edx
$LN4@newBuf:

; 128  : 		char *p = (char *)calloc(1, size);

  00044	8b f4		 mov	 esi, esp
  00046	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00049	50		 push	 eax
  0004a	6a 01		 push	 1
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00052	83 c4 08	 add	 esp, 8
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	89 45 f8	 mov	 DWORD PTR _p$1[ebp], eax

; 129  : /*		if (p) {
; 130  : 			gs_cLogger.DebugLog(LEVEL_TRACE, "overIdx:%d, overSize:%lld calloc address[%p]", m_nOverMaxIdx, size, p);
; 131  : 		}
; 132  : 		else {
; 133  : 			gs_cLogger.DebugLog(LEVEL_ERROR, "calloc has Failed");
; 134  : 		}	*/	
; 135  : 		return p;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _p$1[ebp]
  00062	eb 0e		 jmp	 SHORT $LN1@newBuf
$LN2@newBuf:

; 136  : 	}
; 137  : 
; 138  : 	return m_pBufList[nIdx]->newMem();

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0006d	e8 00 00 00 00	 call	 ?newMem@CBufPool@@QAEPADXZ ; CBufPool::newMem
$LN1@newBuf:

; 139  : }

  00072	5e		 pop	 esi
  00073	83 c4 08	 add	 esp, 8
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
?__newBuf@CMemManager@@AAEPADHI@Z ENDP			; CMemManager::__newBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
tv79 = -68						; size = 4
_nRes$ = -64						; size = 4
_i$ = -60						; size = 4
_cUnit$ = -53						; size = 1
_szNum$ = -48						; size = 32
_pPos$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pData$ = 8						; size = 4
?getStrToInt@CMemManager@@QAEHPAD@Z PROC		; CMemManager::getStrToInt
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d bc	 lea	 edi, DWORD PTR [ebp-68]
  0000c	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 	TCHAR *pPos = pData;

  00026	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00029	89 45 f4	 mov	 DWORD PTR _pPos$[ebp], eax

; 49   : 	TCHAR szNum[32], cUnit = 0;

  0002c	c6 45 cb 00	 mov	 BYTE PTR _cUnit$[ebp], 0

; 50   : 	int i = 0, nRes=0;

  00030	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00037	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _nRes$[ebp], 0
$LN2@getStrToIn:

; 51   : 	while (*pPos) {

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00041	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00044	85 d2		 test	 edx, edx
  00046	74 40		 je	 SHORT $LN3@getStrToIn

; 52   : 		if ('0' <= *pPos && *pPos <= '9') szNum[i++] = *pPos;

  00048	8b 45 f4	 mov	 eax, DWORD PTR _pPos$[ebp]
  0004b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004e	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00051	7c 22		 jl	 SHORT $LN6@getStrToIn
  00053	8b 55 f4	 mov	 edx, DWORD PTR _pPos$[ebp]
  00056	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00059	83 f8 39	 cmp	 eax, 57			; 00000039H
  0005c	7f 17		 jg	 SHORT $LN6@getStrToIn
  0005e	8b 4d c4	 mov	 ecx, DWORD PTR _i$[ebp]
  00061	8b 55 f4	 mov	 edx, DWORD PTR _pPos$[ebp]
  00064	8a 02		 mov	 al, BYTE PTR [edx]
  00066	88 44 0d d0	 mov	 BYTE PTR _szNum$[ebp+ecx], al
  0006a	8b 4d c4	 mov	 ecx, DWORD PTR _i$[ebp]
  0006d	83 c1 01	 add	 ecx, 1
  00070	89 4d c4	 mov	 DWORD PTR _i$[ebp], ecx
  00073	eb 08		 jmp	 SHORT $LN7@getStrToIn
$LN6@getStrToIn:

; 53   : 		else cUnit = *pPos;

  00075	8b 55 f4	 mov	 edx, DWORD PTR _pPos$[ebp]
  00078	8a 02		 mov	 al, BYTE PTR [edx]
  0007a	88 45 cb	 mov	 BYTE PTR _cUnit$[ebp], al
$LN7@getStrToIn:

; 54   : 		pPos++;

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00080	83 c1 01	 add	 ecx, 1
  00083	89 4d f4	 mov	 DWORD PTR _pPos$[ebp], ecx

; 55   : 	}

  00086	eb b6		 jmp	 SHORT $LN2@getStrToIn
$LN3@getStrToIn:

; 56   : 	nRes = _ttoi(szNum);

  00088	8b f4		 mov	 esi, esp
  0008a	8d 55 d0	 lea	 edx, DWORD PTR _szNum$[ebp]
  0008d	52		 push	 edx
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00094	83 c4 04	 add	 esp, 4
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	89 45 c0	 mov	 DWORD PTR _nRes$[ebp], eax

; 57   : 	if (cUnit) {

  000a1	0f be 45 cb	 movsx	 eax, BYTE PTR _cUnit$[ebp]
  000a5	85 c0		 test	 eax, eax
  000a7	74 63		 je	 SHORT $LN8@getStrToIn

; 58   : 		switch (cUnit) {

  000a9	0f be 4d cb	 movsx	 ecx, BYTE PTR _cUnit$[ebp]
  000ad	89 4d bc	 mov	 DWORD PTR tv79[ebp], ecx
  000b0	8b 55 bc	 mov	 edx, DWORD PTR tv79[ebp]
  000b3	83 ea 47	 sub	 edx, 71			; 00000047H
  000b6	89 55 bc	 mov	 DWORD PTR tv79[ebp], edx
  000b9	83 7d bc 26	 cmp	 DWORD PTR tv79[ebp], 38	; 00000026H
  000bd	77 3b		 ja	 SHORT $LN12@getStrToIn
  000bf	8b 45 bc	 mov	 eax, DWORD PTR tv79[ebp]
  000c2	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN14@getStrToIn[eax]
  000c9	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN18@getStrToIn[ecx*4]
$LN9@getStrToIn:

; 59   : 		case 'k': case 'K': nRes = nRes * 1024; break;

  000d0	8b 55 c0	 mov	 edx, DWORD PTR _nRes$[ebp]
  000d3	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  000d6	89 55 c0	 mov	 DWORD PTR _nRes$[ebp], edx
  000d9	eb 31		 jmp	 SHORT $LN8@getStrToIn
$LN10@getStrToIn:

; 60   : 		case 'm': case 'M': nRes = nRes * 1024 * 1024; break;

  000db	8b 45 c0	 mov	 eax, DWORD PTR _nRes$[ebp]
  000de	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  000e1	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  000e4	89 45 c0	 mov	 DWORD PTR _nRes$[ebp], eax
  000e7	eb 23		 jmp	 SHORT $LN8@getStrToIn
$LN11@getStrToIn:

; 61   : 		case 'g': case 'G': nRes = nRes * 1024 * 1024 * 1024; break;

  000e9	8b 4d c0	 mov	 ecx, DWORD PTR _nRes$[ebp]
  000ec	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  000ef	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  000f2	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  000f5	89 4d c0	 mov	 DWORD PTR _nRes$[ebp], ecx
  000f8	eb 12		 jmp	 SHORT $LN8@getStrToIn
$LN12@getStrToIn:

; 62   : 		default: printf("getStrToInt parsing FAIL!!! cUnit[%c]\n", cUnit);

  000fa	0f be 55 cb	 movsx	 edx, BYTE PTR _cUnit$[ebp]
  000fe	52		 push	 edx
  000ff	68 00 00 00 00	 push	 OFFSET $SG44628
  00104	e8 00 00 00 00	 call	 _printf
  00109	83 c4 08	 add	 esp, 8
$LN8@getStrToIn:

; 63   : 		}
; 64   : 	}
; 65   : 	return nRes;

  0010c	8b 45 c0	 mov	 eax, DWORD PTR _nRes$[ebp]

; 66   : }

  0010f	52		 push	 edx
  00110	8b cd		 mov	 ecx, ebp
  00112	50		 push	 eax
  00113	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@getStrToIn
  00119	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0011e	58		 pop	 eax
  0011f	5a		 pop	 edx
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00125	33 cd		 xor	 ecx, ebp
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	83 c4 44	 add	 esp, 68			; 00000044H
  0012f	3b ec		 cmp	 ebp, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 04 00	 ret	 4
$LN17@getStrToIn:
  0013c	01 00 00 00	 DD	 1
  00140	00 00 00 00	 DD	 $LN16@getStrToIn
$LN16@getStrToIn:
  00144	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00148	20 00 00 00	 DD	 32			; 00000020H
  0014c	00 00 00 00	 DD	 $LN15@getStrToIn
$LN15@getStrToIn:
  00150	73		 DB	 115			; 00000073H
  00151	7a		 DB	 122			; 0000007aH
  00152	4e		 DB	 78			; 0000004eH
  00153	75		 DB	 117			; 00000075H
  00154	6d		 DB	 109			; 0000006dH
  00155	00		 DB	 0
  00156	66 90		 npad	 2
$LN18@getStrToIn:
  00158	00 00 00 00	 DD	 $LN11@getStrToIn
  0015c	00 00 00 00	 DD	 $LN9@getStrToIn
  00160	00 00 00 00	 DD	 $LN10@getStrToIn
  00164	00 00 00 00	 DD	 $LN12@getStrToIn
$LN14@getStrToIn:
  00168	00		 DB	 0
  00169	03		 DB	 3
  0016a	03		 DB	 3
  0016b	03		 DB	 3
  0016c	01		 DB	 1
  0016d	03		 DB	 3
  0016e	02		 DB	 2
  0016f	03		 DB	 3
  00170	03		 DB	 3
  00171	03		 DB	 3
  00172	03		 DB	 3
  00173	03		 DB	 3
  00174	03		 DB	 3
  00175	03		 DB	 3
  00176	03		 DB	 3
  00177	03		 DB	 3
  00178	03		 DB	 3
  00179	03		 DB	 3
  0017a	03		 DB	 3
  0017b	03		 DB	 3
  0017c	03		 DB	 3
  0017d	03		 DB	 3
  0017e	03		 DB	 3
  0017f	03		 DB	 3
  00180	03		 DB	 3
  00181	03		 DB	 3
  00182	03		 DB	 3
  00183	03		 DB	 3
  00184	03		 DB	 3
  00185	03		 DB	 3
  00186	03		 DB	 3
  00187	03		 DB	 3
  00188	00		 DB	 0
  00189	03		 DB	 3
  0018a	03		 DB	 3
  0018b	03		 DB	 3
  0018c	01		 DB	 1
  0018d	03		 DB	 3
  0018e	02		 DB	 2
?getStrToInt@CMemManager@@QAEHPAD@Z ENDP		; CMemManager::getStrToInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pBuf$ = 8						; size = 4
_nIdx$ = 12						; size = 4
?delBufByIndex@CMemManager@@QAEXPADH@Z PROC		; CMemManager::delBufByIndex
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 144  : 	if (IDX_BUF_2m < nIdx || !m_pBufList[nIdx]) { if (pBuf) free(pBuf); return; }

  0000f	83 7d 0c 15	 cmp	 DWORD PTR _nIdx$[ebp], 21 ; 00000015H
  00013	7f 0c		 jg	 SHORT $LN3@delBufByIn
  00015	8b 45 0c	 mov	 eax, DWORD PTR _nIdx$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0001f	75 1e		 jne	 SHORT $LN2@delBufByIn
$LN3@delBufByIn:
  00021	83 7d 08 00	 cmp	 DWORD PTR _pBuf$[ebp], 0
  00025	74 16		 je	 SHORT $LN4@delBufByIn
  00027	8b f4		 mov	 esi, esp
  00029	8b 55 08	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0002c	52		 push	 edx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@delBufByIn:
  0003d	eb 1e		 jmp	 SHORT $LN1@delBufByIn
$LN2@delBufByIn:

; 145  : 	if(m_pBufList[nIdx]) m_pBufList[nIdx]->delMem(pBuf);

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _nIdx$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00049	74 12		 je	 SHORT $LN1@delBufByIn
  0004b	8b 55 08	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _nIdx$[ebp]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00058	e8 00 00 00 00	 call	 ?delMem@CBufPool@@QAEXPAD@Z ; CBufPool::delMem
$LN1@delBufByIn:

; 146  : }

  0005d	5e		 pop	 esi
  0005e	83 c4 04	 add	 esp, 4
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
?delBufByIndex@CMemManager@@QAEXPADH@Z ENDP		; CMemManager::delBufByIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QAEXPADH@Z
_TEXT	SEGMENT
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_pBuf$ = 8						; size = 4
_nSize$ = 12						; size = 4
?delBuf@CMemManager@@QAEXPADH@Z PROC			; CMemManager::delBuf, COMDAT
; _this$ = ecx

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	8b 45 0c	 mov	 eax, DWORD PTR _nSize$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?delBuf@CMemManager@@QAEXPADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
tv157 = -56						; size = 4
tv133 = -52						; size = 4
tv82 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
_i$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?alloc@CMemManager@@QAE_NXZ PROC			; CMemManager::alloc
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?alloc@CMemManager@@QAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  00019	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	int i;
; 91   : 	for (i = IDX_BUF_2; i < IDX_BUF_MAX; i++)

  0003a	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00041	eb 09		 jmp	 SHORT $LN4@alloc
$LN2@alloc:
  00043	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00046	83 c0 01	 add	 eax, 1
  00049	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@alloc:
  0004c	83 7d ec 16	 cmp	 DWORD PTR _i$[ebp], 22	; 00000016H
  00050	0f 8d 16 01 00
	00		 jge	 $LN3@alloc

; 92   : 	{
; 93   : 		if (!m_stConfig.nMaxList[i]) continue;

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00059	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	83 7c 8a 58 00	 cmp	 DWORD PTR [edx+ecx*4+88], 0
  00061	75 02		 jne	 SHORT $LN5@alloc
  00063	eb de		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 94   : 
; 95   : 		if (m_pBufList[i]) {

  00065	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0006f	74 3b		 je	 SHORT $LN6@alloc

; 96   : 			delete m_pBufList[i];

  00071	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00074	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00077	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0007a	89 4d e4	 mov	 DWORD PTR $T6[ebp], ecx
  0007d	8b 55 e4	 mov	 edx, DWORD PTR $T6[ebp]
  00080	89 55 e8	 mov	 DWORD PTR $T7[ebp], edx
  00083	83 7d e8 00	 cmp	 DWORD PTR $T7[ebp], 0
  00087	74 0f		 je	 SHORT $LN10@alloc
  00089	6a 01		 push	 1
  0008b	8b 4d e8	 mov	 ecx, DWORD PTR $T7[ebp]
  0008e	e8 00 00 00 00	 call	 ??_GCBufPool@@QAEPAXI@Z
  00093	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  00096	eb 07		 jmp	 SHORT $LN11@alloc
$LN10@alloc:
  00098	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN11@alloc:

; 97   : 			m_pBufList[i] = NULL;

  0009f	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
$LN6@alloc:

; 98   : 		}
; 99   : 		m_pBufList[i] = new (std::nothrow) CBufPool();

  000ac	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  000b1	6a 20		 push	 32			; 00000020H
  000b3	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  000b8	83 c4 08	 add	 esp, 8
  000bb	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c5	83 7d dc 00	 cmp	 DWORD PTR $T4[ebp], 0
  000c9	74 0d		 je	 SHORT $LN12@alloc
  000cb	8b 4d dc	 mov	 ecx, DWORD PTR $T4[ebp]
  000ce	e8 00 00 00 00	 call	 ??0CBufPool@@QAE@XZ	; CBufPool::CBufPool
  000d3	89 45 cc	 mov	 DWORD PTR tv133[ebp], eax
  000d6	eb 07		 jmp	 SHORT $LN13@alloc
$LN12@alloc:
  000d8	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN13@alloc:
  000df	8b 55 cc	 mov	 edx, DWORD PTR tv133[ebp]
  000e2	89 55 e0	 mov	 DWORD PTR $T5[ebp], edx
  000e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ec	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000ef	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	8b 55 e0	 mov	 edx, DWORD PTR $T5[ebp]
  000f5	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 100  : 		if (m_pBufList[i]) {

  000f8	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000fb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00102	74 63		 je	 SHORT $LN7@alloc

; 101  : 			if (!m_pBufList[i]->alloc(i, m_stConfig.nMaxList[i])) {

  00104	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00107	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	8b 4c 90 58	 mov	 ecx, DWORD PTR [eax+edx*4+88]
  0010e	51		 push	 ecx
  0010f	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00112	52		 push	 edx
  00113	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00116	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  0011c	e8 00 00 00 00	 call	 ?alloc@CBufPool@@QAE_NHH@Z ; CBufPool::alloc
  00121	0f b6 d0	 movzx	 edx, al
  00124	85 d2		 test	 edx, edx
  00126	75 3f		 jne	 SHORT $LN7@alloc

; 102  : 				delete m_pBufList[i];

  00128	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00131	89 55 d4	 mov	 DWORD PTR $T2[ebp], edx
  00134	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00137	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
  0013a	83 7d d8 00	 cmp	 DWORD PTR $T3[ebp], 0
  0013e	74 0f		 je	 SHORT $LN14@alloc
  00140	6a 01		 push	 1
  00142	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
  00145	e8 00 00 00 00	 call	 ??_GCBufPool@@QAEPAXI@Z
  0014a	89 45 c8	 mov	 DWORD PTR tv157[ebp], eax
  0014d	eb 07		 jmp	 SHORT $LN15@alloc
$LN14@alloc:
  0014f	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv157[ebp], 0
$LN15@alloc:

; 103  : 				m_pBufList[i] = NULL;

  00156	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00159	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0015c	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0

; 104  : 				return false;

  00163	32 c0		 xor	 al, al
  00165	eb 07		 jmp	 SHORT $LN1@alloc
$LN7@alloc:

; 105  : 			}
; 106  : 		}
; 107  : 	}

  00167	e9 d7 fe ff ff	 jmp	 $LN2@alloc
$LN3@alloc:

; 108  : 	return true;

  0016c	b0 01		 mov	 al, 1
$LN1@alloc:

; 109  : 
; 110  : }

  0016e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00171	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00178	59		 pop	 ecx
  00179	5f		 pop	 edi
  0017a	83 c4 38	 add	 esp, 56			; 00000038H
  0017d	3b ec		 cmp	 ebp, esp
  0017f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?alloc@CMemManager@@QAE_NXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00005	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXABUnothrow_t@std@@@Z ; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$?alloc@CMemManager@@QAE_NXZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?alloc@CMemManager@@QAE_NXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?alloc@CMemManager@@QAE_NXZ ENDP			; CMemManager::alloc
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
_nIdx$ = -12						; size = 4
_nSize$ = -8						; size = 4
_this$ = -4						; size = 4
_pStrSize$ = 8						; size = 4
_nCount$ = 12						; size = 4
?init@CMemManager@@QAEHPADH@Z PROC			; CMemManager::init
; _this$ = ecx

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 	int nSize = getStrToInt(pStrSize);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pStrSize$[ebp]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?getStrToInt@CMemManager@@QAEHPAD@Z ; CMemManager::getStrToInt
  0002a	89 45 f8	 mov	 DWORD PTR _nSize$[ebp], eax

; 80   : 	int nIdx;
; 81   : 	if (nSize) {

  0002d	83 7d f8 00	 cmp	 DWORD PTR _nSize$[ebp], 0
  00031	74 26		 je	 SHORT $LN2@init

; 82   : 		nIdx = getIndex(nSize);

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f4	 mov	 DWORD PTR _nIdx$[ebp], eax

; 83   : 		m_stConfig.nMaxList[nIdx] += nCount;

  00042	8b 55 f4	 mov	 edx, DWORD PTR _nIdx$[ebp]
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 4c 90 58	 mov	 ecx, DWORD PTR [eax+edx*4+88]
  0004c	03 4d 0c	 add	 ecx, DWORD PTR _nCount$[ebp]
  0004f	8b 55 f4	 mov	 edx, DWORD PTR _nIdx$[ebp]
  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	89 4c 90 58	 mov	 DWORD PTR [eax+edx*4+88], ecx
$LN2@init:

; 84   : 	}
; 85   : 	return nSize;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _nSize$[ebp]

; 86   : }

  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?init@CMemManager@@QAEHPADH@Z ENDP			; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_pConf$ = 8						; size = 4
?init@CMemManager@@QAEXPAUSTBufConf@@@Z PROC		; CMemManager::init
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 	int i;
; 71   : 	for (i = 0; i < IDX_BUF_MAX; i++)

  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@init
$LN2@init:
  00020	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@init:
  00029	83 7d f8 16	 cmp	 DWORD PTR _i$[ebp], 22	; 00000016H
  0002d	7d 1f		 jge	 SHORT $LN1@init

; 72   : 	{
; 73   : 		m_stConfig.nMaxList[i] += pConf->nMaxList[i];

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 44 8a 58	 mov	 eax, DWORD PTR [edx+ecx*4+88]
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0003c	8b 55 08	 mov	 edx, DWORD PTR _pConf$[ebp]
  0003f	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	89 44 8a 58	 mov	 DWORD PTR [edx+ecx*4+88], eax

; 74   : 	}

  0004c	eb d2		 jmp	 SHORT $LN2@init
$LN1@init:

; 75   : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?init@CMemManager@@QAEXPAUSTBufConf@@@Z ENDP		; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
tv77 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
??1CMemManager@@QAE@XZ PROC				; CMemManager::~CMemManager
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 36   : 	int i =  0;

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 37   : 	for (i = IDX_BUF_2; i < IDX_BUF_MAX; i++) {

  00024	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0002b	eb 09		 jmp	 SHORT $LN4@CMemManage
$LN2@CMemManage:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CMemManage:
  00036	83 7d f8 16	 cmp	 DWORD PTR _i$[ebp], 22	; 00000016H
  0003a	7d 49		 jge	 SHORT $LN6@CMemManage

; 38   : 		if (m_pBufList[i]) {

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  00046	74 3b		 je	 SHORT $LN5@CMemManage

; 39   : 			delete m_pBufList[i]; m_pBufList[i] = 0;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00051	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
  00054	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00057	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  0005a	83 7d f4 00	 cmp	 DWORD PTR $T2[ebp], 0
  0005e	74 0f		 je	 SHORT $LN7@CMemManage
  00060	6a 01		 push	 1
  00062	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  00065	e8 00 00 00 00	 call	 ??_GCBufPool@@QAEPAXI@Z
  0006a	89 45 ec	 mov	 DWORD PTR tv77[ebp], eax
  0006d	eb 07		 jmp	 SHORT $LN8@CMemManage
$LN7@CMemManage:
  0006f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN8@CMemManage:
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00079	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0
$LN5@CMemManage:

; 40   : 		}
; 41   : 	}

  00083	eb a8		 jmp	 SHORT $LN2@CMemManage
$LN6@CMemManage:

; 42   : 
; 43   : 
; 44   : }

  00085	83 c4 14	 add	 esp, 20			; 00000014H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??1CMemManager@@QAE@XZ ENDP				; CMemManager::~CMemManager
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\commemmanager.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
??0CMemManager@@QAE@XZ PROC				; CMemManager::CMemManager
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 10   : 	m_nOverMaxIdx = 0;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0

; 11   : 	memset(m_pBufList, 0, sizeof(m_pBufList));

  00024	6a 58		 push	 88			; 00000058H
  00026	6a 00		 push	 0
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _memset
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12   : 	memset(&m_stConfig, 0, sizeof(STBufConf));

  00034	6a 58		 push	 88			; 00000058H
  00036	6a 00		 push	 0
  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	83 c2 58	 add	 edx, 88			; 00000058H
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _memset
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13   : 	int i;
; 14   : 
; 15   : 	m_stConfig.nMaxList[IDX_BUF_2] = 256;

  00047	b8 04 00 00 00	 mov	 eax, 4
  0004c	c1 e0 00	 shl	 eax, 0
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	c7 44 01 58 00
	01 00 00	 mov	 DWORD PTR [ecx+eax+88], 256 ; 00000100H

; 16   : 	m_stConfig.nMaxList[IDX_BUF_4] = 256;

  0005a	ba 04 00 00 00	 mov	 edx, 4
  0005f	d1 e2		 shl	 edx, 1
  00061	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00064	c7 44 10 58 00
	01 00 00	 mov	 DWORD PTR [eax+edx+88], 256 ; 00000100H

; 17   : 	m_stConfig.nMaxList[IDX_BUF_8] = 2048;

  0006c	b9 04 00 00 00	 mov	 ecx, 4
  00071	6b d1 03	 imul	 edx, ecx, 3
  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	c7 44 10 58 00
	08 00 00	 mov	 DWORD PTR [eax+edx+88], 2048 ; 00000800H

; 18   : 	m_stConfig.nMaxList[IDX_BUF_16] = 2048;

  0007f	b9 04 00 00 00	 mov	 ecx, 4
  00084	c1 e1 02	 shl	 ecx, 2
  00087	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	c7 44 0a 58 00
	08 00 00	 mov	 DWORD PTR [edx+ecx+88], 2048 ; 00000800H

; 19   : 	for (i = IDX_BUF_32; i < IDX_BUF_16k; i++)

  00092	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _i$[ebp], 5
  00099	eb 09		 jmp	 SHORT $LN4@CMemManage
$LN2@CMemManage:
  0009b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009e	83 c0 01	 add	 eax, 1
  000a1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CMemManage:
  000a4	83 7d f8 0e	 cmp	 DWORD PTR _i$[ebp], 14	; 0000000eH
  000a8	7d 10		 jge	 SHORT $LN3@CMemManage

; 20   : 	{
; 21   : 		m_stConfig.nMaxList[i] = 64;

  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b0	c7 44 8a 58 40
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+88], 64 ; 00000040H

; 22   : 	}

  000b8	eb e1		 jmp	 SHORT $LN2@CMemManage
$LN3@CMemManage:

; 23   : 	for (i = IDX_BUF_16k; i < IDX_BUF_64k; i++)

  000ba	c7 45 f8 0e 00
	00 00		 mov	 DWORD PTR _i$[ebp], 14	; 0000000eH
  000c1	eb 09		 jmp	 SHORT $LN7@CMemManage
$LN5@CMemManage:
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c6	83 c0 01	 add	 eax, 1
  000c9	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@CMemManage:
  000cc	83 7d f8 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  000d0	7d 10		 jge	 SHORT $LN6@CMemManage

; 24   : 	{
; 25   : 		m_stConfig.nMaxList[i] = 4;

  000d2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	c7 44 8a 58 04
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+88], 4

; 26   : 	}

  000e0	eb e1		 jmp	 SHORT $LN5@CMemManage
$LN6@CMemManage:

; 27   : 	for (i = IDX_BUF_64k; i < IDX_BUF_512k; i++)

  000e2	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _i$[ebp], 16	; 00000010H
  000e9	eb 09		 jmp	 SHORT $LN10@CMemManage
$LN8@CMemManage:
  000eb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ee	83 c0 01	 add	 eax, 1
  000f1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@CMemManage:
  000f4	83 7d f8 13	 cmp	 DWORD PTR _i$[ebp], 19	; 00000013H
  000f8	7d 10		 jge	 SHORT $LN9@CMemManage

; 28   : 	{
; 29   : 		m_stConfig.nMaxList[i] = 2;

  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00100	c7 44 8a 58 02
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+88], 2

; 30   : 	}

  00108	eb e1		 jmp	 SHORT $LN8@CMemManage
$LN9@CMemManage:

; 31   : 	m_stConfig.nMaxList[IDX_BUF_1m] = 1;

  0010a	b8 04 00 00 00	 mov	 eax, 4
  0010f	6b c8 14	 imul	 ecx, eax, 20
  00112	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00115	c7 44 0a 58 01
	00 00 00	 mov	 DWORD PTR [edx+ecx+88], 1

; 32   : }

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00120	83 c4 08	 add	 esp, 8
  00123	3b ec		 cmp	 ebp, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
??0CMemManager@@QAE@XZ ENDP				; CMemManager::CMemManager
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GCBufPool@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBufPool@@QAEPAXI@Z PROC				; CBufPool::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CBufPool@@QAE@XZ	; CBufPool::~CBufPool
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 20		 push	 32			; 00000020H
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_GCBufPool@@QAEPAXI@Z ENDP				; CBufPool::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = -24						; size = 4
_$S1$ = -16						; size = 8
_m$ = -4						; size = 4
_s$ = 8							; size = 4
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _s$[ebp]
  00022	f2 0f 11 45 f0	 movsd	 QWORD PTR _$S1$[ebp], xmm0
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	c1 e0 00	 shl	 eax, 0
  0002f	8b 4c 05 f0	 mov	 ecx, DWORD PTR _$S1$[ebp+eax]
  00033	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00036	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0003c	89 4d fc	 mov	 DWORD PTR _m$[ebp], ecx
  0003f	ba 01 00 00 00	 mov	 edx, 1
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00047	d3 e2		 shl	 edx, cl
  00049	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	2b c2		 sub	 eax, edx
  0004e	23 45 08	 and	 eax, DWORD PTR _s$[ebp]
  00051	74 09		 je	 SHORT $LN3@getIndex
  00053	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  0005c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@getIndex:
  00063	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00066	03 45 e8	 add	 eax, DWORD PTR tv73[ebp]
  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@getIndex
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN7@getIndex:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN6@getIndex
$LN6@getIndex:
  00088	f0 ff ff ff	 DD	 -16			; fffffff0H
  0008c	08 00 00 00	 DD	 8
  00090	00 00 00 00	 DD	 $LN5@getIndex
$LN5@getIndex:
  00094	24		 DB	 36			; 00000024H
  00095	53		 DB	 83			; 00000053H
  00096	31		 DB	 49			; 00000031H
  00097	00		 DB	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00015	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  0001a	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001d	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	8b f4		 mov	 esi, esp
  0002c	6a 01		 push	 1
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 __vfprintf_l
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 955  :     __crt_va_end(_ArgList);

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 956  :     return _Result;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 957  : }

  00054	5e		 pop	 esi
  00055	83 c4 08	 add	 esp, 8
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
