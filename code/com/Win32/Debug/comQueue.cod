; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comQueue.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG44628 DB	'[%p] calloc has Failed', 0aH, 00H
$SG44631 DB	'[%p] ################### realloc success m_nLast[%d] m_n'
	DB	'Max[%d] nMaxCount[%d]', 0aH, 00H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	??1abstract_critical_section@common@@UAE@XZ	; common::abstract_critical_section::~abstract_critical_section
PUBLIC	??0abstract_critical_section@common@@QAE@XZ	; common::abstract_critical_section::abstract_critical_section
PUBLIC	??_Gabstract_critical_section@common@@UAEPAXI@Z	; common::abstract_critical_section::`scalar deleting destructor'
PUBLIC	??0critical_section@win32@common@@QAE@XZ	; common::win32::critical_section::critical_section
PUBLIC	??1critical_section@win32@common@@UAE@XZ	; common::win32::critical_section::~critical_section
PUBLIC	?enter@critical_section@win32@common@@UAE_N_N@Z	; common::win32::critical_section::enter
PUBLIC	?leave@critical_section@win32@common@@UAEXXZ	; common::win32::critical_section::leave
PUBLIC	??_Gcritical_section@win32@common@@UAEPAXI@Z	; common::win32::critical_section::`scalar deleting destructor'
PUBLIC	??0win_atomic@win32@common@@QAE@XZ		; common::win32::win_atomic::win_atomic
PUBLIC	??1win_atomic@win32@common@@QAE@XZ		; common::win32::win_atomic::~win_atomic
PUBLIC	?getCount@win_atomic@win32@common@@QAEHXZ	; common::win32::win_atomic::getCount
PUBLIC	?init@win_atomic@win32@common@@QAEXXZ		; common::win32::win_atomic::init
PUBLIC	?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z ; common::win32::win_atomic::atomic_compare_exchange
PUBLIC	?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z		; ISABLETODELETE
PUBLIC	??0CQueueS@@QAE@XZ				; CQueueS::CQueueS
PUBLIC	??1CQueueS@@QAE@XZ				; CQueueS::~CQueueS
PUBLIC	?alloc@CQueueS@@QAE_NHW4E_ALLOC_TYPE@@@Z	; CQueueS::alloc
PUBLIC	?realloc@CQueueS@@QAE_NH_N@Z			; CQueueS::realloc
PUBLIC	?push@CQueueS@@QAE_NPAX@Z			; CQueueS::push
PUBLIC	?pop@CQueueS@@QAEPAXXZ				; CQueueS::pop
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?delBuf@CMemManager@@QAEXPADH@Z			; CMemManager::delBuf
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7abstract_critical_section@common@@6B@	; common::abstract_critical_section::`vftable'
PUBLIC	??_7critical_section@win32@common@@6B@		; common::win32::critical_section::`vftable'
PUBLIC	??_R4abstract_critical_section@common@@6B@	; common::abstract_critical_section::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVabstract_critical_section@common@@@8	; common::abstract_critical_section `RTTI Type Descriptor'
PUBLIC	??_R3abstract_critical_section@common@@8	; common::abstract_critical_section::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2abstract_critical_section@common@@8	; common::abstract_critical_section::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@abstract_critical_section@common@@8 ; common::abstract_critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4critical_section@win32@common@@6B@		; common::win32::critical_section::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcritical_section@win32@common@@@8	; common::win32::critical_section `RTTI Type Descriptor'
PUBLIC	??_R3critical_section@win32@common@@8		; common::win32::critical_section::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2critical_section@win32@common@@8		; common::win32::critical_section::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@critical_section@win32@common@@8	; common::win32::critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__InterlockedCompareExchange@12:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__TryEnterCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	??_Eabstract_critical_section@common@@UAEPAXI@Z:PROC ; common::abstract_critical_section::`vector deleting destructor'
EXTRN	??_Ecritical_section@win32@common@@UAEPAXI@Z:PROC ; common::win32::critical_section::`vector deleting destructor'
EXTRN	_initSpinLock@4:PROC
EXTRN	_acquireSpinLock@4:PROC
EXTRN	_releaseSpinLock@4:PROC
EXTRN	?delBufByIndex@CMemManager@@QAEXPADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PAVCMemManager@@A:DWORD		; gs_pMMgr
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@critical_section@win32@common@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@critical_section@win32@common@@8 DD FLAT:??_R0?AVcritical_section@win32@common@@@8 ; common::win32::critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3critical_section@win32@common@@8
rdata$r	ENDS
;	COMDAT ??_R2critical_section@win32@common@@8
rdata$r	SEGMENT
??_R2critical_section@win32@common@@8 DD FLAT:??_R1A@?0A@EA@critical_section@win32@common@@8 ; common::win32::critical_section::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@abstract_critical_section@common@@8
rdata$r	ENDS
;	COMDAT ??_R3critical_section@win32@common@@8
rdata$r	SEGMENT
??_R3critical_section@win32@common@@8 DD 00H		; common::win32::critical_section::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2critical_section@win32@common@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcritical_section@win32@common@@@8
data$r	SEGMENT
??_R0?AVcritical_section@win32@common@@@8 DD FLAT:??_7type_info@@6B@ ; common::win32::critical_section `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcritical_section@win32@common@@', 00H
data$r	ENDS
;	COMDAT ??_R4critical_section@win32@common@@6B@
rdata$r	SEGMENT
??_R4critical_section@win32@common@@6B@ DD 00H		; common::win32::critical_section::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcritical_section@win32@common@@@8
	DD	FLAT:??_R3critical_section@win32@common@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@abstract_critical_section@common@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@abstract_critical_section@common@@8 DD FLAT:??_R0?AVabstract_critical_section@common@@@8 ; common::abstract_critical_section::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3abstract_critical_section@common@@8
rdata$r	ENDS
;	COMDAT ??_R2abstract_critical_section@common@@8
rdata$r	SEGMENT
??_R2abstract_critical_section@common@@8 DD FLAT:??_R1A@?0A@EA@abstract_critical_section@common@@8 ; common::abstract_critical_section::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3abstract_critical_section@common@@8
rdata$r	SEGMENT
??_R3abstract_critical_section@common@@8 DD 00H		; common::abstract_critical_section::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2abstract_critical_section@common@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVabstract_critical_section@common@@@8
data$r	SEGMENT
??_R0?AVabstract_critical_section@common@@@8 DD FLAT:??_7type_info@@6B@ ; common::abstract_critical_section `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVabstract_critical_section@common@@', 00H
data$r	ENDS
;	COMDAT ??_R4abstract_critical_section@common@@6B@
rdata$r	SEGMENT
??_R4abstract_critical_section@common@@6B@ DD 00H	; common::abstract_critical_section::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVabstract_critical_section@common@@@8
	DD	FLAT:??_R3abstract_critical_section@common@@8
rdata$r	ENDS
;	COMDAT ??_7critical_section@win32@common@@6B@
CONST	SEGMENT
??_7critical_section@win32@common@@6B@ DD FLAT:??_R4critical_section@win32@common@@6B@ ; common::win32::critical_section::`vftable'
	DD	FLAT:??_Ecritical_section@win32@common@@UAEPAXI@Z
	DD	FLAT:?enter@critical_section@win32@common@@UAE_N_N@Z
	DD	FLAT:?leave@critical_section@win32@common@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7abstract_critical_section@common@@6B@
CONST	SEGMENT
??_7abstract_critical_section@common@@6B@ DD FLAT:??_R4abstract_critical_section@common@@6B@ ; common::abstract_critical_section::`vftable'
	DD	FLAT:??_Eabstract_critical_section@common@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CQueueS@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CQueueS@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CQueueS@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CQueueS@@QAE@XZ$2
__ehfuncinfo$??1CQueueS@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$??0CQueueS@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CQueueS@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QAEXPADH@Z
_TEXT	SEGMENT
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_pBuf$ = 8						; size = 4
_nSize$ = 12						; size = 4
?delBuf@CMemManager@@QAEXPADH@Z PROC			; CMemManager::delBuf, COMDAT
; _this$ = ecx

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	8b 45 0c	 mov	 eax, DWORD PTR _nSize$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?delBuf@CMemManager@@QAEXPADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = -24						; size = 4
_$S1$ = -16						; size = 8
_m$ = -4						; size = 4
_s$ = 8							; size = 4
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _s$[ebp]
  00022	f2 0f 11 45 f0	 movsd	 QWORD PTR _$S1$[ebp], xmm0
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	c1 e0 00	 shl	 eax, 0
  0002f	8b 4c 05 f0	 mov	 ecx, DWORD PTR _$S1$[ebp+eax]
  00033	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00036	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0003c	89 4d fc	 mov	 DWORD PTR _m$[ebp], ecx
  0003f	ba 01 00 00 00	 mov	 edx, 1
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00047	d3 e2		 shl	 edx, cl
  00049	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	2b c2		 sub	 eax, edx
  0004e	23 45 08	 and	 eax, DWORD PTR _s$[ebp]
  00051	74 09		 je	 SHORT $LN3@getIndex
  00053	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  0005c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@getIndex:
  00063	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00066	03 45 e8	 add	 eax, DWORD PTR tv73[ebp]
  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@getIndex
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN7@getIndex:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN6@getIndex
$LN6@getIndex:
  00088	f0 ff ff ff	 DD	 -16			; fffffff0H
  0008c	08 00 00 00	 DD	 8
  00090	00 00 00 00	 DD	 $LN5@getIndex
$LN5@getIndex:
  00094	24		 DB	 36			; 00000024H
  00095	53		 DB	 83			; 00000053H
  00096	31		 DB	 49			; 00000031H
  00097	00		 DB	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comqueue.cpp
_TEXT	SEGMENT
_res$ = -8						; size = 4
_this$ = -4						; size = 4
?pop@CQueueS@@QAEPAXXZ PROC				; CQueueS::pop
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	void* res;
; 131  : 	SPIN_LOCK_ENTER(&m_cLockPop);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 c0 34	 add	 eax, 52			; 00000034H
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _acquireSpinLock@4

; 132  : 	res = m_pArray[m_nFront];

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00031	89 55 f8	 mov	 DWORD PTR _res$[ebp], edx

; 133  : 	if (res) {

  00034	83 7d f8 00	 cmp	 DWORD PTR _res$[ebp], 0
  00038	74 5e		 je	 SHORT $LN2@pop

; 134  : 		m_pArray[m_nFront] = 0;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0

; 135  : 		//printf("[%p] m_nFront[%d] nMax[%d]\n", m_pArray, m_nFront, nMax);
; 136  : 		m_nFront++;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00052	83 c2 01	 add	 edx, 1
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 137  : 		if (m_nOldMax) {

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00062	74 1a		 je	 SHORT $LN4@pop

; 138  : 			if(m_nFront == m_nOldMax) m_nFront = 0;

  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0006d	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00070	75 0a		 jne	 SHORT $LN6@pop
  00072	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00075	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
$LN6@pop:

; 139  : 		}

  0007c	eb 18		 jmp	 SHORT $LN5@pop
$LN4@pop:

; 140  : 		else if (m_nFront == m_nMax) m_nFront = 0;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00087	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0008a	75 0a		 jne	 SHORT $LN5@pop
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN5@pop:

; 141  : 	}

  00096	eb 45		 jmp	 SHORT $LN3@pop
$LN2@pop:

; 142  : 	else if (m_nOldMax) {

  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0009f	74 3c		 je	 SHORT $LN3@pop

; 143  : 		//nTmp = m_nFront; nTmp2 = m_nOldMax;
; 144  : 		res = m_pArray[m_nOldMax]; 

  000a1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ac	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  000af	89 45 f8	 mov	 DWORD PTR _res$[ebp], eax

; 145  : 		m_pArray[m_nOldMax] = 0;

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0

; 146  : 		//printf("[%p] m_nFront[%d] m_nOldMax[%d]\n", m_pArray, m_nFront, m_nOldMax);
; 147  : 		m_nFront = m_nOldMax+1;

  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000ca	83 c0 01	 add	 eax, 1
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 148  : 		m_nOldMax = 0;

  000d3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
$LN3@pop:

; 149  : 	}
; 150  : 	SPIN_LOCK_LEAVE(&m_cLockPop);

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	83 c0 34	 add	 eax, 52			; 00000034H
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _releaseSpinLock@4

; 151  : 	//if (0 <= nTmp) {
; 152  : 	//	gs_cLogger.DebugLog(LEVEL_INFO, "m_nFront[%d] m_nOldMax[%d]", nTmp, nTmp2);
; 153  : 	//}
; 154  : 	return res;

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _res$[ebp]

; 155  : }

  000ec	83 c4 08	 add	 esp, 8
  000ef	3b ec		 cmp	 ebp, esp
  000f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
?pop@CQueueS@@QAEPAXXZ ENDP				; CQueueS::pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comqueue.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pData$ = 8						; size = 4
?push@CQueueS@@QAE_NPAX@Z PROC				; CQueueS::push
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : 	if (m_nRealloc.getCount()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00015	e8 00 00 00 00	 call	 ?getCount@win_atomic@win32@common@@QAEHXZ ; common::win32::win_atomic::getCount
  0001a	85 c0		 test	 eax, eax
  0001c	74 3b		 je	 SHORT $LN2@push

; 96   : 		m_CS.enter();

  0001e	8b f4		 mov	 esi, esp
  00020	6a 01		 push	 1
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 18	 add	 ecx, 24			; 00000018H
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	ff d0		 call	 eax
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 97   : 		m_CS.leave();

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 18	 add	 ecx, 24			; 00000018H
  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00046	8b f4		 mov	 esi, esp
  00048	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0004b	ff d2		 call	 edx
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	e9 9a 00 00 00	 jmp	 $LN3@push
$LN2@push:

; 98   : 	}
; 99   : 	else if(m_pArray[m_nLast]) {

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00068	0f 84 85 00 00
	00		 je	 $LN3@push

; 100  : 		if (m_nRealloc.atomic_compare_exchange(1, 0)) {

  0006e	6a 00		 push	 0
  00070	6a 01		 push	 1
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00078	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z ; common::win32::win_atomic::atomic_compare_exchange
  0007d	85 c0		 test	 eax, eax
  0007f	74 38		 je	 SHORT $LN5@push

; 101  : 			m_CS.enter();

  00081	8b f4		 mov	 esi, esp
  00083	6a 01		 push	 1
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 18	 add	 ecx, 24			; 00000018H
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00091	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00094	ff d2		 call	 edx
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 102  : 			m_CS.leave();

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	83 c1 18	 add	 ecx, 24			; 00000018H
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000a9	8b f4		 mov	 esi, esp
  000ab	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ae	ff d0		 call	 eax
  000b0	3b f4		 cmp	 esi, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 103  : 		}
; 104  : 		else {

  000b7	eb 3a		 jmp	 SHORT $LN3@push
$LN5@push:

; 105  : 			m_CS.enter();

  000b9	8b f4		 mov	 esi, esp
  000bb	6a 01		 push	 1
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	83 c1 18	 add	 ecx, 24			; 00000018H
  000c3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c6	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000cc	ff d2		 call	 edx
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 106  : 			if (!realloc(m_nMax << 1)) {

  000d5	6a 00		 push	 0
  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000dd	d1 e1		 shl	 ecx, 1
  000df	51		 push	 ecx
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?realloc@CQueueS@@QAE_NH_N@Z ; CQueueS::realloc
  000e8	0f b6 d0	 movzx	 edx, al
  000eb	85 d2		 test	 edx, edx
  000ed	75 04		 jne	 SHORT $LN3@push

; 107  : 				return false;

  000ef	32 c0		 xor	 al, al
  000f1	eb 52		 jmp	 SHORT $LN1@push
$LN3@push:

; 108  : 			}
; 109  : 		}
; 110  : 	}
; 111  : 
; 112  : 	SPIN_LOCK_ENTER(&m_cLockPush);

  000f3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	83 c0 14	 add	 eax, 20			; 00000014H
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _acquireSpinLock@4

; 113  : 	//if (m_pArray[m_nLast]) {
; 114  : 	//	//nTmp = m_nLast; nTmp2 = m_nMax;
; 115  : 	//	printf("[%p] Already data Set! m_nLast[%d] nMax[%d]\n", m_pArray, m_nLast, m_nMax);
; 116  : 	//}
; 117  : 	m_pArray[m_nLast] = pData;

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00105	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  0010d	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 118  : 	m_nLast++;

  00110	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00116	83 c2 01	 add	 edx, 1
  00119	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 119  : 	if (m_nLast == m_nMax) m_nLast = 0;

  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00125	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00128	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0012b	75 0a		 jne	 SHORT $LN8@push
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN8@push:

; 120  : 	//printf("[%p] m_nLast[%d] nMax[%d]\n", m_pArray, nTmp, m_nMax);
; 121  : 	SPIN_LOCK_LEAVE(&m_cLockPush);

  00137	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0013a	83 c2 14	 add	 edx, 20			; 00000014H
  0013d	52		 push	 edx
  0013e	e8 00 00 00 00	 call	 _releaseSpinLock@4

; 122  : 	//if (0 <= nTmp) {
; 123  : 	//	gs_cLogger.DebugLog(LEVEL_ERROR, "Already data Set! m_nLast[%d] nMax[%d]", nTmp, nTmp2);
; 124  : 	//}
; 125  : 	return true;

  00143	b0 01		 mov	 al, 1
$LN1@push:

; 126  : }

  00145	5e		 pop	 esi
  00146	83 c4 04	 add	 esp, 4
  00149	3b ec		 cmp	 ebp, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c2 04 00	 ret	 4
?push@CQueueS@@QAE_NPAX@Z ENDP				; CQueueS::push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comqueue.cpp
_TEXT	SEGMENT
_oldPtr$ = -12						; size = 4
_newPtr$ = -8						; size = 4
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
_bInit$ = 12						; size = 1
?realloc@CQueueS@@QAE_NH_N@Z PROC			; CQueueS::realloc
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 	void** newPtr, **oldPtr = m_pArray;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 4d f4	 mov	 DWORD PTR _oldPtr$[ebp], ecx

; 65   : 	newPtr = (void **)calloc(nMaxCount, sizeof(void*));

  00027	8b f4		 mov	 esi, esp
  00029	6a 04		 push	 4
  0002b	8b 55 08	 mov	 edx, DWORD PTR _nMaxCount$[ebp]
  0002e	52		 push	 edx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00035	83 c4 08	 add	 esp, 8
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	89 45 f8	 mov	 DWORD PTR _newPtr$[ebp], eax

; 66   : 	if (!newPtr) {

  00042	83 7d f8 00	 cmp	 DWORD PTR _newPtr$[ebp], 0
  00046	75 3f		 jne	 SHORT $LN2@realloc

; 67   : 		printf("[%p] calloc has Failed\n", m_pArray);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	68 00 00 00 00	 push	 OFFSET $SG44628
  00053	e8 00 00 00 00	 call	 _printf
  00058	83 c4 08	 add	 esp, 8

; 68   : 		m_nRealloc.init();

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00061	e8 00 00 00 00	 call	 ?init@win_atomic@win32@common@@QAEXXZ ; common::win32::win_atomic::init

; 69   : 		m_CS.leave();

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 18	 add	 ecx, 24			; 00000018H
  0006c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00072	8b f4		 mov	 esi, esp
  00074	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00077	ff d2		 call	 edx
  00079	3b f4		 cmp	 esi, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 70   : 		return false;

  00080	32 c0		 xor	 al, al
  00082	e9 fa 00 00 00	 jmp	 $LN1@realloc
$LN2@realloc:

; 71   : 	}
; 72   : 	if (bInit) {

  00087	0f b6 45 0c	 movzx	 eax, BYTE PTR _bInit$[ebp]
  0008b	85 c0		 test	 eax, eax
  0008d	74 2d		 je	 SHORT $LN3@realloc

; 73   : 		m_pArray = newPtr;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 55 f8	 mov	 edx, DWORD PTR _newPtr$[ebp]
  00095	89 11		 mov	 DWORD PTR [ecx], edx

; 74   : 		m_nMax = nMaxCount;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _nMaxCount$[ebp]
  0009d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 75   : 		memset(m_pArray, 0, nMaxCount * sizeof(void*));

  000a0	8b 55 08	 mov	 edx, DWORD PTR _nMaxCount$[ebp]
  000a3	c1 e2 02	 shl	 edx, 2
  000a6	52		 push	 edx
  000a7	6a 00		 push	 0
  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _memset
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 	}
; 77   : 	else {

  000b7	e9 82 00 00 00	 jmp	 $LN4@realloc
$LN3@realloc:

; 78   : 		memcpy(newPtr, m_pArray, m_nMax * sizeof(void*));

  000bc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000bf	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000c2	c1 e0 02	 shl	 eax, 2
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cb	52		 push	 edx
  000cc	8b 45 f8	 mov	 eax, DWORD PTR _newPtr$[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _memcpy
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   : 		printf("[%p] ################### realloc success m_nLast[%d] m_nMax[%d] nMaxCount[%d]\n", m_pArray, m_nLast, m_nMax, nMaxCount);

  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _nMaxCount$[ebp]
  000db	51		 push	 ecx
  000dc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000df	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000e2	50		 push	 eax
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e9	52		 push	 edx
  000ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ef	51		 push	 ecx
  000f0	68 00 00 00 00	 push	 OFFSET $SG44631
  000f5	e8 00 00 00 00	 call	 _printf
  000fa	83 c4 14	 add	 esp, 20			; 00000014H

; 80   : 		SPIN_LOCK_ENTER(&m_cLockPop);

  000fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00100	83 c2 34	 add	 edx, 52			; 00000034H
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 _acquireSpinLock@4

; 81   : 		m_pArray = newPtr;

  00109	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _newPtr$[ebp]
  0010f	89 08		 mov	 DWORD PTR [eax], ecx

; 82   : 		m_nLast = m_nMax;

  00111	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00117	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0011a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 83   : 		m_nMax = nMaxCount;

  0011d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00120	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  00123	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 84   : 		SPIN_LOCK_LEAVE(&m_cLockPop);

  00126	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	83 c1 34	 add	 ecx, 52			; 00000034H
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 _releaseSpinLock@4

; 85   : 		m_nOldMax = m_nLast;

  00132	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00135	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013b	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
$LN4@realloc:

; 86   : 	}
; 87   : 	m_nRealloc.init();

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00144	e8 00 00 00 00	 call	 ?init@win_atomic@win32@common@@QAEXXZ ; common::win32::win_atomic::init

; 88   : 	m_CS.leave();

  00149	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	83 c1 18	 add	 ecx, 24			; 00000018H
  0014f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00152	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00155	8b f4		 mov	 esi, esp
  00157	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0015a	ff d2		 call	 edx
  0015c	3b f4		 cmp	 esi, esp
  0015e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 89   : 	if(oldPtr) free(oldPtr);

  00163	83 7d f4 00	 cmp	 DWORD PTR _oldPtr$[ebp], 0
  00167	74 16		 je	 SHORT $LN5@realloc
  00169	8b f4		 mov	 esi, esp
  0016b	8b 45 f4	 mov	 eax, DWORD PTR _oldPtr$[ebp]
  0016e	50		 push	 eax
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00175	83 c4 04	 add	 esp, 4
  00178	3b f4		 cmp	 esi, esp
  0017a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@realloc:

; 90   : 	return true;

  0017f	b0 01		 mov	 al, 1
$LN1@realloc:

; 91   : }

  00181	5e		 pop	 esi
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH
  00185	3b ec		 cmp	 ebp, esp
  00187	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 08 00	 ret	 8
?realloc@CQueueS@@QAE_NH_N@Z ENDP			; CQueueS::realloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comqueue.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
_type$ = 12						; size = 4
?alloc@CQueueS@@QAE_NHW4E_ALLOC_TYPE@@@Z PROC		; CQueueS::alloc
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 	m_pArray = (void **)calloc(nMaxCount, sizeof(void*));

  0000f	8b f4		 mov	 esi, esp
  00011	6a 04		 push	 4
  00013	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0001d	83 c4 08	 add	 esp, 8
  00020	3b f4		 cmp	 esi, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	89 01		 mov	 DWORD PTR [ecx], eax

; 50   : 	if (m_pArray == 0) {

  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00032	75 04		 jne	 SHORT $LN2@alloc

; 51   : 		//gs_cLogger.DebugLog(LEVEL_ERROR, "m_pArray calloc ERROR nMaxCount[%d]", nMaxCount);
; 52   : 		return false;

  00034	32 c0		 xor	 al, al
  00036	eb 14		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 53   : 	}
; 54   : 
; 55   : 	m_nMax = nMaxCount;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _nMaxCount$[ebp]
  0003e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 56   : 	m_nObjAllocType = type;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00047	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 57   : 	//gs_cLogger.PutLogQueue(LEVEL_INFO, _T("CQueue<T>::alloc nMaxCount[%d]"), nMaxCount);
; 58   : 	return true;

  0004a	b0 01		 mov	 al, 1
$LN1@alloc:

; 59   : }

  0004c	5e		 pop	 esi
  0004d	83 c4 04	 add	 esp, 4
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?alloc@CQueueS@@QAE_NHW4E_ALLOC_TYPE@@@Z ENDP		; CQueueS::alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comqueue.cpp
_TEXT	SEGMENT
tv133 = -44						; size = 4
tv91 = -40						; size = 4
tv87 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_i$ = -24						; size = 4
_p$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CQueueS@@QAE@XZ PROC					; CQueueS::~CQueueS
; _this$ = ecx

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CQueueS@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001d	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00020	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00023	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00026	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00029	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00037	33 c5		 xor	 eax, ebp
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00043	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 20   : 	if (!m_pArray) return;

  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004c	75 05		 jne	 SHORT $LN7@CQueueS
  0004e	e9 38 01 00 00	 jmp	 $LN1@CQueueS
$LN7@CQueueS:

; 21   : 
; 22   : 	void *p;
; 23   : 	int i;
; 24   : 	if (ISABLETODELETE(m_nObjAllocType)) {

  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0005f	83 c4 04	 add	 esp, 4
  00062	0f b6 c0	 movzx	 eax, al
  00065	85 c0		 test	 eax, eax
  00067	0f 84 fd 00 00
	00		 je	 $LN8@CQueueS

; 25   : 		for (i = 0; i < m_nMax; i++) {

  0006d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00074	eb 09		 jmp	 SHORT $LN4@CQueueS
$LN2@CQueueS:
  00076	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  00079	83 c1 01	 add	 ecx, 1
  0007c	89 4d e8	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@CQueueS:
  0007f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00082	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00085	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00088	0f 8d dc 00 00
	00		 jge	 $LN8@CQueueS

; 26   : 			p = m_pArray[i];

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8b 11		 mov	 edx, DWORD PTR [ecx]
  00093	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00096	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00099	89 4d ec	 mov	 DWORD PTR _p$[ebp], ecx

; 27   : 			if (p) {

  0009c	83 7d ec 00	 cmp	 DWORD PTR _p$[ebp], 0
  000a0	0f 84 bf 00 00
	00		 je	 $LN9@CQueueS

; 28   : 				switch (m_nObjAllocType) {

  000a6	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000ac	89 45 dc	 mov	 DWORD PTR tv87[ebp], eax
  000af	8b 4d dc	 mov	 ecx, DWORD PTR tv87[ebp]
  000b2	83 e9 02	 sub	 ecx, 2
  000b5	89 4d dc	 mov	 DWORD PTR tv87[ebp], ecx
  000b8	83 7d dc 03	 cmp	 DWORD PTR tv87[ebp], 3
  000bc	0f 87 a3 00 00
	00		 ja	 $LN9@CQueueS
  000c2	8b 55 dc	 mov	 edx, DWORD PTR tv87[ebp]
  000c5	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN22@CQueueS[edx*4]
$LN10@CQueueS:

; 29   : 				case eAlloc_Type_new:	delete p; break;

  000cc	8b 45 ec	 mov	 eax, DWORD PTR _p$[ebp]
  000cf	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  000d2	6a 00		 push	 0
  000d4	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000dd	83 c4 08	 add	 esp, 8
  000e0	83 7d e4 00	 cmp	 DWORD PTR $T3[ebp], 0
  000e4	75 09		 jne	 SHORT $LN17@CQueueS
  000e6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  000ed	eb 0d		 jmp	 SHORT $LN18@CQueueS
$LN17@CQueueS:
  000ef	c7 45 ec 23 81
	00 00		 mov	 DWORD PTR _p$[ebp], 33059 ; 00008123H
  000f6	8b 55 ec	 mov	 edx, DWORD PTR _p$[ebp]
  000f9	89 55 d8	 mov	 DWORD PTR tv91[ebp], edx
$LN18@CQueueS:
  000fc	eb 67		 jmp	 SHORT $LN9@CQueueS
$LN11@CQueueS:

; 30   : 				case eAlloc_Type_alloc:	free(p); break;

  000fe	8b f4		 mov	 esi, esp
  00100	8b 45 ec	 mov	 eax, DWORD PTR _p$[ebp]
  00103	50		 push	 eax
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0010a	83 c4 04	 add	 esp, 4
  0010d	3b f4		 cmp	 esi, esp
  0010f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00114	eb 4f		 jmp	 SHORT $LN9@CQueueS
$LN12@CQueueS:

; 31   : 				case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00116	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  00119	51		 push	 ecx
  0011a	e8 00 00 00 00	 call	 _strlen
  0011f	83 c4 04	 add	 esp, 4
  00122	83 c0 01	 add	 eax, 1
  00125	50		 push	 eax
  00126	8b 55 ec	 mov	 edx, DWORD PTR _p$[ebp]
  00129	52		 push	 edx
  0012a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00130	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
  00135	eb 2e		 jmp	 SHORT $LN9@CQueueS
$LN13@CQueueS:

; 32   : 				case eAlloc_Type_newArray:	delete[] p; break;

  00137	8b 45 ec	 mov	 eax, DWORD PTR _p$[ebp]
  0013a	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  0013d	8b 4d e0	 mov	 ecx, DWORD PTR $T2[ebp]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00146	83 c4 04	 add	 esp, 4
  00149	83 7d e0 00	 cmp	 DWORD PTR $T2[ebp], 0
  0014d	75 09		 jne	 SHORT $LN19@CQueueS
  0014f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
  00156	eb 0d		 jmp	 SHORT $LN9@CQueueS
$LN19@CQueueS:
  00158	c7 45 ec 23 81
	00 00		 mov	 DWORD PTR _p$[ebp], 33059 ; 00008123H
  0015f	8b 55 ec	 mov	 edx, DWORD PTR _p$[ebp]
  00162	89 55 d4	 mov	 DWORD PTR tv133[ebp], edx
$LN9@CQueueS:

; 33   : 				case eAlloc_Type_none: break;
; 34   : 				case eAlloc_Type_MemPool: break;
; 35   : 				}
; 36   : 			}
; 37   : 		}			

  00165	e9 0c ff ff ff	 jmp	 $LN2@CQueueS
$LN8@CQueueS:

; 38   : 	}
; 39   : 	free(m_pArray);

  0016a	8b f4		 mov	 esi, esp
  0016c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0016f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00171	51		 push	 ecx
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00178	83 c4 04	 add	 esp, 4
  0017b	3b f4		 cmp	 esi, esp
  0017d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 40   : 	m_pArray = 0;

  00182	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00185	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN1@CQueueS:

; 41   : 	SPIN_LOCK_DESTROY(&m_cLockPush);
; 42   : 	SPIN_LOCK_DESTROY(&m_cLockPop);
; 43   : }

  0018b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018e	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00191	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
  00196	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	83 c1 34	 add	 ecx, 52			; 00000034H
  0019c	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	83 c1 18	 add	 ecx, 24			; 00000018H
  001a7	e8 00 00 00 00	 call	 ??1critical_section@win32@common@@UAE@XZ ; common::win32::critical_section::~critical_section
  001ac	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	83 c1 14	 add	 ecx, 20			; 00000014H
  001b2	e8 00 00 00 00	 call	 ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
  001b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c1	59		 pop	 ecx
  001c2	5e		 pop	 esi
  001c3	83 c4 2c	 add	 esp, 44			; 0000002cH
  001c6	3b ec		 cmp	 ebp, esp
  001c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c3		 ret	 0
  001d1	0f 1f 00	 npad	 3
$LN22@CQueueS:
  001d4	00 00 00 00	 DD	 $LN10@CQueueS
  001d8	00 00 00 00	 DD	 $LN11@CQueueS
  001dc	00 00 00 00	 DD	 $LN12@CQueueS
  001e0	00 00 00 00	 DD	 $LN13@CQueueS
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1CQueueS@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CQueueS@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CQueueS@@QAE@XZ ENDP					; CQueueS::~CQueueS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comqueue.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CQueueS@@QAE@XZ PROC					; CQueueS::CQueueS
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CQueueS@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 14	 add	 ecx, 20			; 00000014H
  00033	e8 00 00 00 00	 call	 ??0win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::win_atomic
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 18	 add	 ecx, 24			; 00000018H
  00045	e8 00 00 00 00	 call	 ??0critical_section@win32@common@@QAE@XZ ; common::win32::critical_section::critical_section
  0004a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 34	 add	 ecx, 52			; 00000034H
  00054	e8 00 00 00 00	 call	 ??0win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::win_atomic
  00059	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0005d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00063	e8 00 00 00 00	 call	 ??0win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::win_atomic

; 7    : 	memset(g_szMessage, 0, LEN_MEM_MESSAGE);

  00068	68 80 00 00 00	 push	 128			; 00000080H
  0006d	6a 00		 push	 0
  0006f	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00074	e8 00 00 00 00	 call	 _memset
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8    : 	m_pArray = NULL;

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 9    : 	m_nMax = 0;

  00085	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 10   : 	m_nFront = 0;

  0008f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00092	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 11   : 	m_nLast = 0;

  00099	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 12   : 	SPIN_LOCK_INIT(&m_cLockPush);

  000a3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	83 c1 14	 add	 ecx, 20			; 00000014H
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 _initSpinLock@4

; 13   : 	SPIN_LOCK_INIT(&m_cLockPop);

  000af	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	83 c2 34	 add	 edx, 52			; 00000034H
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 _initSpinLock@4

; 14   : 	m_nOldMax = 0;

  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 15   : }

  000c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	83 c4 10	 add	 esp, 16			; 00000010H
  000dd	3b ec		 cmp	 ebp, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CQueueS@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	e9 00 00 00 00	 jmp	 ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
__unwindfunclet$??0CQueueS@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 18	 add	 ecx, 24			; 00000018H
  00011	e9 00 00 00 00	 jmp	 ??1critical_section@win32@common@@UAE@XZ ; common::win32::critical_section::~critical_section
__unwindfunclet$??0CQueueS@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 34	 add	 ecx, 52			; 00000034H
  0001c	e9 00 00 00 00	 jmp	 ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
__ehhandler$??0CQueueS@@QAE@XZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CQueueS@@QAE@XZ
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CQueueS@@QAE@XZ ENDP					; CQueueS::CQueueS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z PROC		; ISABLETODELETE, COMDAT

; 247  : inline bool ISABLETODELETE(E_ALLOC_TYPE e) { if (eAlloc_Type_MemPool < e) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 08 01	 cmp	 DWORD PTR _e$[ebp], 1
  00007	7e 04		 jle	 SHORT $LN2@ISABLETODE
  00009	b0 01		 mov	 al, 1
  0000b	eb 02		 jmp	 SHORT $LN1@ISABLETODE
$LN2@ISABLETODE:
  0000d	32 c0		 xor	 al, al
$LN1@ISABLETODE:
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ENDP		; ISABLETODELETE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nExchange$ = 8						; size = 4
_nComperand$ = 12					; size = 4
?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z PROC ; common::win32::win_atomic::atomic_compare_exchange, COMDAT
; _this$ = ecx

; 99   : 	inline int atomic_compare_exchange(int nExchange, int nComperand) {return (int)InterlockedCompareExchange(&m_count, nExchange, nComperand);} // return long

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b f4		 mov	 esi, esp
  00011	8b 45 0c	 mov	 eax, DWORD PTR _nComperand$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _nExchange$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	52		 push	 edx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedCompareExchange@12
  00023	3b f4		 cmp	 esi, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z ENDP ; common::win32::win_atomic::atomic_compare_exchange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?init@win_atomic@win32@common@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?init@win_atomic@win32@common@@QAEXXZ PROC		; common::win32::win_atomic::init, COMDAT
; _this$ = ecx

; 94   : 	inline void init() { m_count = 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?init@win_atomic@win32@common@@QAEXXZ ENDP		; common::win32::win_atomic::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?getCount@win_atomic@win32@common@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@win_atomic@win32@common@@QAEHXZ PROC		; common::win32::win_atomic::getCount, COMDAT
; _this$ = ecx

; 91   : 	inline int getCount() { return (int)m_count; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?getCount@win_atomic@win32@common@@QAEHXZ ENDP		; common::win32::win_atomic::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1win_atomic@win32@common@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1win_atomic@win32@common@@QAE@XZ PROC			; common::win32::win_atomic::~win_atomic, COMDAT
; _this$ = ecx

; 88   : 	~win_atomic() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??1win_atomic@win32@common@@QAE@XZ ENDP			; common::win32::win_atomic::~win_atomic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0win_atomic@win32@common@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0win_atomic@win32@common@@QAE@XZ PROC			; common::win32::win_atomic::win_atomic, COMDAT
; _this$ = ecx

; 87   : 	win_atomic() {m_count = 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0win_atomic@win32@common@@QAE@XZ ENDP			; common::win32::win_atomic::win_atomic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gcritical_section@win32@common@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gcritical_section@win32@common@@UAEPAXI@Z PROC	; common::win32::critical_section::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1critical_section@win32@common@@UAE@XZ ; common::win32::critical_section::~critical_section
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 1c		 push	 28			; 0000001cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gcritical_section@win32@common@@UAEPAXI@Z ENDP	; common::win32::critical_section::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?leave@critical_section@win32@common@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?leave@critical_section@win32@common@@UAEXXZ PROC	; common::win32::critical_section::leave, COMDAT
; _this$ = ecx

; 55   : 	void leave() { LeaveCriticalSection(&m_cs);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	8b f4		 mov	 esi, esp
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	5e		 pop	 esi
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?leave@critical_section@win32@common@@UAEXXZ ENDP	; common::win32::critical_section::leave
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?enter@critical_section@win32@common@@UAE_N_N@Z
_TEXT	SEGMENT
tv72 = -9						; size = 1
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_bWait$ = 8						; size = 1
?enter@critical_section@win32@common@@UAE_N_N@Z PROC	; common::win32::critical_section::enter, COMDAT
; _this$ = ecx

; 39   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 	     BOOL	bRet = TRUE;

  0001f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1

; 41   : 
; 42   : 	     if (bWait) 

  00026	0f b6 45 08	 movzx	 eax, BYTE PTR _bWait$[ebp]
  0002a	85 c0		 test	 eax, eax
  0002c	74 18		 je	 SHORT $LN2@enter

; 43   : 		     EnterCriticalSection(&m_cs);

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 04	 add	 ecx, 4
  00034	8b f4		 mov	 esi, esp
  00036	51		 push	 ecx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 44   : 	     else

  00044	eb 19		 jmp	 SHORT $LN3@enter
$LN2@enter:

; 45   :     #if(_WIN32_WINNT >= 0x0400)
; 46   : 		     bRet = TryEnterCriticalSection(&m_cs);

  00046	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00049	83 c2 04	 add	 edx, 4
  0004c	8b f4		 mov	 esi, esp
  0004e	52		 push	 edx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TryEnterCriticalSection@4
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	89 45 f8	 mov	 DWORD PTR _bRet$[ebp], eax
$LN3@enter:

; 47   :     #else
; 48   : 		    EnterCriticalSection(&m_cs);
; 49   :     #endif
; 50   : 
; 51   : 	     return (bRet)?true:false;

  0005f	83 7d f8 00	 cmp	 DWORD PTR _bRet$[ebp], 0
  00063	74 06		 je	 SHORT $LN5@enter
  00065	c6 45 f7 01	 mov	 BYTE PTR tv72[ebp], 1
  00069	eb 04		 jmp	 SHORT $LN6@enter
$LN5@enter:
  0006b	c6 45 f7 00	 mov	 BYTE PTR tv72[ebp], 0
$LN6@enter:
  0006f	8a 45 f7	 mov	 al, BYTE PTR tv72[ebp]

; 52   : 
; 53   : 	} 

  00072	5e		 pop	 esi
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
?enter@critical_section@win32@common@@UAE_N_N@Z ENDP	; common::win32::critical_section::enter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1critical_section@win32@common@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1critical_section@win32@common@@UAE@XZ PROC		; common::win32::critical_section::~critical_section, COMDAT
; _this$ = ecx

; 36   : 	virtual ~critical_section() { DeleteCriticalSection(&m_cs);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7critical_section@win32@common@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	8b f4		 mov	 esi, esp
  00020	51		 push	 ecx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??1abstract_critical_section@common@@UAE@XZ ; common::abstract_critical_section::~abstract_critical_section
  00036	5e		 pop	 esi
  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??1critical_section@win32@common@@UAE@XZ ENDP		; common::win32::critical_section::~critical_section
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0critical_section@win32@common@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0critical_section@win32@common@@QAE@XZ PROC		; common::win32::critical_section::critical_section, COMDAT
; _this$ = ecx

; 35   : 	critical_section() { InitializeCriticalSection(&m_cs); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0abstract_critical_section@common@@QAE@XZ
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7critical_section@win32@common@@6B@
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 04	 add	 ecx, 4
  00026	8b f4		 mov	 esi, esp
  00028	51		 push	 ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5e		 pop	 esi
  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??0critical_section@win32@common@@QAE@XZ ENDP		; common::win32::critical_section::critical_section
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gabstract_critical_section@common@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gabstract_critical_section@common@@UAEPAXI@Z PROC	; common::abstract_critical_section::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1abstract_critical_section@common@@UAE@XZ ; common::abstract_critical_section::~abstract_critical_section
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 04		 push	 4
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gabstract_critical_section@common@@UAEPAXI@Z ENDP	; common::abstract_critical_section::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0abstract_critical_section@common@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0abstract_critical_section@common@@QAE@XZ PROC	; common::abstract_critical_section::abstract_critical_section, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7abstract_critical_section@common@@6B@
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0abstract_critical_section@common@@QAE@XZ ENDP	; common::abstract_critical_section::abstract_critical_section
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\abstract_mtsync.h
;	COMDAT ??1abstract_critical_section@common@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1abstract_critical_section@common@@UAE@XZ PROC	; common::abstract_critical_section::~abstract_critical_section, COMDAT
; _this$ = ecx

; 61   : 	virtual ~abstract_critical_section() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7abstract_critical_section@common@@6B@
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1abstract_critical_section@common@@UAE@XZ ENDP	; common::abstract_critical_section::~abstract_critical_section
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00015	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  0001a	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001d	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	8b f4		 mov	 esi, esp
  0002c	6a 01		 push	 1
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 __vfprintf_l
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 955  :     __crt_va_end(_ArgList);

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 956  :     return _Result;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 957  : }

  00054	5e		 pop	 esi
  00055	83 c4 08	 add	 esp, 8
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
