; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comList.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG44637 DB	'm_nMaxCount[%d]', 00H
$SG44638 DB	'CSList::__alloc', 00H
$SG44659 DB	'i[%d] m_nLast[%d] m_nCurCount[%d]', 00H
	ORG $+2
$SG44660 DB	'CSList::add', 00H
$SG44681 DB	' i[%d] m_nLast[%d] m_nCurCount[%d]', 00H
	ORG $+1
$SG44682 DB	'CSList::push_back', 00H
	ORG $+2
$SG44708 DB	' del FAIL! i[%d] m_nMax[%d]', 00H
$SG44709 DB	'CSList::del', 00H
$SG44723 DB	'i[%d] m_nMax[%d]', 00H
	ORG $+3
$SG44724 DB	'CSList::del', 00H
CONST	ENDS
PUBLIC	?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z		; ISABLETODELETE
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?delBuf@CMemManager@@QAEXPADH@Z			; CMemManager::delBuf
PUBLIC	??0CSList@@QAE@XZ				; CSList::CSList
PUBLIC	??1CSList@@QAE@XZ				; CSList::~CSList
PUBLIC	?clear@CSList@@QAEXXZ				; CSList::clear
PUBLIC	?add@CSList@@QAE_NPAXPAH@Z			; CSList::add
PUBLIC	?push_back@CSList@@QAE_NPAXPAH@Z		; CSList::push_back
PUBLIC	?del@CSList@@QAE_NPAX_N@Z			; CSList::del
PUBLIC	?del@CSList@@QAE_NH_N@Z				; CSList::del
PUBLIC	?getNext@CSList@@QAEPAXPAH@Z			; CSList::getNext
PUBLIC	?__alloc@CSList@@AAEHH@Z			; CSList::__alloc
PUBLIC	?_DEL@CSList@@AAEXH@Z				; CSList::_DEL
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	?delBufByIndex@CMemManager@@QAEXPADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	?__debugLog@CLogger@@QAAXHPBDH0ZZ:PROC		; CLogger::__debugLog
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?gs_pMMgr@@3PAVCMemManager@@A:DWORD		; gs_pMMgr
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
xdata$x	SEGMENT
__ehfuncinfo$??1CSList@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?_DEL@CSList@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?_DEL@CSList@@AAEXH@Z PROC				; CSList::_DEL, COMDAT
; _this$ = ecx

; 60   : 	inline void _DEL(int i) { m_pArray[i] = 0; m_nUse--; m_nDelIdx = i; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00016	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	83 e9 01	 sub	 ecx, 1
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00032	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_DEL@CSList@@AAEXH@Z ENDP				; CSList::_DEL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
_pList$ = -8						; size = 4
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
?__alloc@CSList@@AAEHH@Z PROC				; CSList::__alloc
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 	if (nMaxCount <= m_nMax) return m_nMax;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _nMaxCount$[ebp]
  0001e	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00021	7f 0b		 jg	 SHORT $LN2@alloc
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00029	e9 8b 00 00 00	 jmp	 $LN1@alloc
$LN2@alloc:

; 68   : 	void** pList = (void**)calloc(nMaxCount, sizeof(void*));

  0002e	8b f4		 mov	 esi, esp
  00030	6a 04		 push	 4
  00032	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0003c	83 c4 08	 add	 esp, 8
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	89 45 f8	 mov	 DWORD PTR _pList$[ebp], eax

; 69   : 	if (!pList) {

  00049	83 7d f8 00	 cmp	 DWORD PTR _pList$[ebp], 0
  0004d	75 23		 jne	 SHORT $LN3@alloc

; 70   : 		gs_cLogger.DebugLog(LEVEL_ERROR, _T("m_nMaxCount[%d]"), nMaxCount);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _nMaxCount$[ebp]
  00052	51		 push	 ecx
  00053	68 00 00 00 00	 push	 OFFSET $SG44637
  00058	6a 46		 push	 70			; 00000046H
  0005a	68 00 00 00 00	 push	 OFFSET $SG44638
  0005f	6a 05		 push	 5
  00061	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00066	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0006b	83 c4 18	 add	 esp, 24			; 00000018H

; 71   : 		return 0;

  0006e	33 c0		 xor	 eax, eax
  00070	eb 47		 jmp	 SHORT $LN1@alloc
$LN3@alloc:

; 72   : 	}
; 73   : 	//_stprintf(g_szMessage, _T("CList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 74   : 	if (m_pArray) {

  00072	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00075	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00078	74 34		 je	 SHORT $LN4@alloc

; 75   : 		memcpy(pList, m_pArray, m_nMax * sizeof(void*));

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00080	c1 e1 02	 shl	 ecx, 2
  00083	51		 push	 ecx
  00084	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 02		 mov	 eax, DWORD PTR [edx]
  00089	50		 push	 eax
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _pList$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _memcpy
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 		free(m_pArray);

  00096	8b f4		 mov	 esi, esp
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000a4	83 c4 04	 add	 esp, 4
  000a7	3b f4		 cmp	 esi, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@alloc:

; 77   : 	}
; 78   : 	m_pArray = pList;

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	8b 55 f8	 mov	 edx, DWORD PTR _pList$[ebp]
  000b4	89 11		 mov	 DWORD PTR [ecx], edx

; 79   : 	return nMaxCount;

  000b6	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
$LN1@alloc:

; 80   : }

  000b9	5e		 pop	 esi
  000ba	83 c4 08	 add	 esp, 8
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 04 00	 ret	 4
?__alloc@CSList@@AAEHH@Z ENDP				; CSList::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?getNext@CSList@@QAEPAXPAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pIdx$ = 8						; size = 4
?getNext@CSList@@QAEPAXPAH@Z PROC			; CSList::getNext, COMDAT
; _this$ = ecx

; 35   : 	inline void* getNext(int *pIdx) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 36   : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000e	eb 0d		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  00010	8b 45 08	 mov	 eax, DWORD PTR _pIdx$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	83 c1 01	 add	 ecx, 1
  00018	8b 55 08	 mov	 edx, DWORD PTR _pIdx$[ebp]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx
$LN4@getNext:
  0001d	8b 45 08	 mov	 eax, DWORD PTR _pIdx$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00028	7d 21		 jge	 SHORT $LN3@getNext

; 37   : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002a	8b 45 08	 mov	 eax, DWORD PTR _pIdx$[ebp]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00038	74 0f		 je	 SHORT $LN5@getNext
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pIdx$[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00047	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 38   : 		}

  00049	eb c5		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 39   : 		return NULL;

  0004b	33 c0		 xor	 eax, eax
$LN1@getNext:

; 40   : 	}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?getNext@CSList@@QAEPAXPAH@Z ENDP			; CSList::getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
tv81 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_bDeepDelete$ = 12					; size = 1
?del@CSList@@QAE_NH_N@Z PROC				; CSList::del
; _this$ = ecx

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : 	if (!ISINCLUDE(i, m_nMax)) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0002b	83 c4 08	 add	 esp, 8
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	75 30		 jne	 SHORT $LN4@del

; 180  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "i[%d] m_nMax[%d]", i, m_nMax);

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET $SG44723
  00045	68 b4 00 00 00	 push	 180			; 000000b4H
  0004a	68 00 00 00 00	 push	 OFFSET $SG44724
  0004f	6a 05		 push	 5
  00051	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00056	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0005b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 181  : 		return false;

  0005e	32 c0		 xor	 al, al
  00060	e9 c9 00 00 00	 jmp	 $LN1@del
$LN4@del:

; 182  : 	}
; 183  : 	if (bDeepDelete) {

  00065	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bDeepDelete$[ebp]
  00069	85 c9		 test	 ecx, ecx
  0006b	0f 84 af 00 00
	00		 je	 $LN5@del

; 184  : 		switch (m_nObjAllocType) {

  00071	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00074	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00077	89 45 f0	 mov	 DWORD PTR tv81[ebp], eax
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR tv81[ebp]
  0007d	83 e9 02	 sub	 ecx, 2
  00080	89 4d f0	 mov	 DWORD PTR tv81[ebp], ecx
  00083	83 7d f0 03	 cmp	 DWORD PTR tv81[ebp], 3
  00087	0f 87 93 00 00
	00		 ja	 $LN5@del
  0008d	8b 55 f0	 mov	 edx, DWORD PTR tv81[ebp]
  00090	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN13@del[edx*4]
$LN6@del:

; 185  : 		case eAlloc_Type_new:	delete m_pArray[i]; break;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  0009f	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000a2	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  000a5	6a 00		 push	 0
  000a7	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b0	83 c4 08	 add	 esp, 8
  000b3	eb 6b		 jmp	 SHORT $LN5@del
$LN7@del:

; 186  : 		case eAlloc_Type_alloc:	free(m_pArray[i]); break;

  000b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ba	8b f4		 mov	 esi, esp
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  000bf	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  000c2	52		 push	 edx
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000c9	83 c4 04	 add	 esp, 4
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	eb 4b		 jmp	 SHORT $LN5@del
$LN8@del:

; 187  : 		case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)m_pArray[i], STRING_SIZE((TCHAR *)m_pArray[i])); break;

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  000dd	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _strlen
  000e6	83 c4 04	 add	 esp, 4
  000e9	83 c0 01	 add	 eax, 1
  000ec	50		 push	 eax
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  000f5	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  000f8	51		 push	 ecx
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000ff	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
  00104	eb 1a		 jmp	 SHORT $LN5@del
$LN9@del:

; 188  : 		case eAlloc_Type_newArray:	delete[] m_pArray[i]; break;

  00106	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00109	8b 02		 mov	 eax, DWORD PTR [edx]
  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0010e	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00111	89 55 f4	 mov	 DWORD PTR $T1[ebp], edx
  00114	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0011d	83 c4 04	 add	 esp, 4
$LN5@del:

; 189  : 		case eAlloc_Type_none: break;
; 190  : 		case eAlloc_Type_MemPool: break;
; 191  : 		}
; 192  : 	}
; 193  : 	_DEL(i);

  00120	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00123	51		 push	 ecx
  00124	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	e8 00 00 00 00	 call	 ?_DEL@CSList@@AAEXH@Z	; CSList::_DEL

; 194  : //	_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 195  : 	return true;

  0012c	b0 01		 mov	 al, 1
$LN1@del:

; 196  : }

  0012e	5e		 pop	 esi
  0012f	83 c4 10	 add	 esp, 16			; 00000010H
  00132	3b ec		 cmp	 ebp, esp
  00134	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 08 00	 ret	 8
  0013f	90		 npad	 1
$LN13@del:
  00140	00 00 00 00	 DD	 $LN6@del
  00144	00 00 00 00	 DD	 $LN7@del
  00148	00 00 00 00	 DD	 $LN8@del
  0014c	00 00 00 00	 DD	 $LN9@del
?del@CSList@@QAE_NH_N@Z ENDP				; CSList::del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
tv88 = -28						; size = 4
tv78 = -24						; size = 4
tv74 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_bDeepDelete$ = 12					; size = 1
?del@CSList@@QAE_NPAX_N@Z PROC				; CSList::del
; _this$ = ecx

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00012	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00015	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00018	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00021	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 155  : 	int i;
; 156  : 	for (i = 0; i < m_nMax; i++) {

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN4@del
$LN2@del:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@del:
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0003c	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0003f	0f 8d f4 00 00
	00		 jge	 $LN3@del

; 157  : 		if (m_pArray[i] == p) {

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0004d	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00050	3b 45 08	 cmp	 eax, DWORD PTR _p$[ebp]
  00053	0f 85 db 00 00
	00		 jne	 $LN7@del

; 158  : 			if (bDeepDelete) {

  00059	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bDeepDelete$[ebp]
  0005d	85 c9		 test	 ecx, ecx
  0005f	0f 84 bf 00 00
	00		 je	 $LN8@del

; 159  : 				switch (m_nObjAllocType) {

  00065	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00068	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006b	89 45 ec	 mov	 DWORD PTR tv74[ebp], eax
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR tv74[ebp]
  00071	83 e9 02	 sub	 ecx, 2
  00074	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  00077	83 7d ec 03	 cmp	 DWORD PTR tv74[ebp], 3
  0007b	0f 87 a3 00 00
	00		 ja	 $LN8@del
  00081	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  00084	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN20@del[edx*4]
$LN9@del:

; 160  : 				case eAlloc_Type_new:	delete p; break;

  0008b	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0008e	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  00091	6a 00		 push	 0
  00093	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0009c	83 c4 08	 add	 esp, 8
  0009f	83 7d f4 00	 cmp	 DWORD PTR $T2[ebp], 0
  000a3	75 09		 jne	 SHORT $LN16@del
  000a5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  000ac	eb 0d		 jmp	 SHORT $LN17@del
$LN16@del:
  000ae	c7 45 08 23 81
	00 00		 mov	 DWORD PTR _p$[ebp], 33059 ; 00008123H
  000b5	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000b8	89 55 e8	 mov	 DWORD PTR tv78[ebp], edx
$LN17@del:
  000bb	eb 67		 jmp	 SHORT $LN8@del
$LN10@del:

; 161  : 				case eAlloc_Type_alloc:	free(p); break;

  000bd	8b f4		 mov	 esi, esp
  000bf	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000c2	50		 push	 eax
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000c9	83 c4 04	 add	 esp, 4
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	eb 4f		 jmp	 SHORT $LN8@del
$LN11@del:

; 162  : 				case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _strlen
  000de	83 c4 04	 add	 esp, 4
  000e1	83 c0 01	 add	 eax, 1
  000e4	50		 push	 eax
  000e5	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000e8	52		 push	 edx
  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000ef	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
  000f4	eb 2e		 jmp	 SHORT $LN8@del
$LN12@del:

; 163  : 				case eAlloc_Type_newArray:	delete[] p; break;

  000f6	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000f9	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  000fc	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00105	83 c4 04	 add	 esp, 4
  00108	83 7d f0 00	 cmp	 DWORD PTR $T1[ebp], 0
  0010c	75 09		 jne	 SHORT $LN18@del
  0010e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
  00115	eb 0d		 jmp	 SHORT $LN8@del
$LN18@del:
  00117	c7 45 08 23 81
	00 00		 mov	 DWORD PTR _p$[ebp], 33059 ; 00008123H
  0011e	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00121	89 55 e4	 mov	 DWORD PTR tv88[ebp], edx
$LN8@del:

; 164  : 				case eAlloc_Type_none: break;
; 165  : 				case eAlloc_Type_MemPool: break;
; 166  : 				}
; 167  : 			}
; 168  : 			_DEL(i);

  00124	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00127	50		 push	 eax
  00128	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	e8 00 00 00 00	 call	 ?_DEL@CSList@@AAEXH@Z	; CSList::_DEL

; 169  : //			_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 170  : 			return true;

  00130	b0 01		 mov	 al, 1
  00132	eb 30		 jmp	 SHORT $LN1@del
$LN7@del:

; 171  : 		}
; 172  : 	}

  00134	e9 f4 fe ff ff	 jmp	 $LN2@del
$LN3@del:

; 173  : 	gs_cLogger.DebugLog(LEVEL_ERROR, " del FAIL! i[%d] m_nMax[%d]", i, m_nMax);

  00139	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0013f	52		 push	 edx
  00140	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00143	50		 push	 eax
  00144	68 00 00 00 00	 push	 OFFSET $SG44708
  00149	68 ad 00 00 00	 push	 173			; 000000adH
  0014e	68 00 00 00 00	 push	 OFFSET $SG44709
  00153	6a 05		 push	 5
  00155	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0015a	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0015f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 174  : 	return false;

  00162	32 c0		 xor	 al, al
$LN1@del:

; 175  : }

  00164	5e		 pop	 esi
  00165	83 c4 1c	 add	 esp, 28			; 0000001cH
  00168	3b ec		 cmp	 ebp, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 08 00	 ret	 8
  00175	0f 1f 00	 npad	 3
$LN20@del:
  00178	00 00 00 00	 DD	 $LN9@del
  0017c	00 00 00 00	 DD	 $LN10@del
  00180	00 00 00 00	 DD	 $LN11@del
  00184	00 00 00 00	 DD	 $LN12@del
?del@CSList@@QAE_NPAX_N@Z ENDP				; CSList::del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
_i$ = -12						; size = 4
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_Obj$ = 8						; size = 4
_pIdx$ = 12						; size = 4
?push_back@CSList@@QAE_NPAXPAH@Z PROC			; CSList::push_back
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 	int nIdx, i;
; 121  : 
; 122  : 	if (m_nUse >= m_nMax) {

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00027	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0002a	7c 3f		 jl	 SHORT $LN5@push_back

; 123  : 		if (!__alloc(m_nMax + UNIT_ADD_SIZE)) return false;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00032	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00035	51		 push	 ecx
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__alloc@CSList@@AAEHH@Z ; CSList::__alloc
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN6@push_back
  00042	32 c0		 xor	 al, al
  00044	e9 0b 01 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 124  : 		nIdx = m_nMax;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004f	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax

; 125  : 		m_nMax += UNIT_ADD_SIZE;

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00058	83 c2 0a	 add	 edx, 10			; 0000000aH
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 126  : 		goto ADD_SUCCESS;

  00061	e9 b2 00 00 00	 jmp	 $ADD_SUCCESS$15
  00066	e9 ad 00 00 00	 jmp	 $ADD_SUCCESS$15
$LN5@push_back:

; 127  : 	}
; 128  : 
; 129  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  0007a	75 13		 jne	 SHORT $LN8@push_back
  0007c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00082	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00085	e9 8e 00 00 00	 jmp	 $ADD_SUCCESS$15
  0008a	e9 89 00 00 00	 jmp	 $ADD_SUCCESS$15
$LN8@push_back:

; 130  : 
; 131  : 	nIdx = m_nLast;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00095	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 132  : 	for (i = 0; i < m_nMax; i++)

  00098	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0009f	eb 09		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  000a1	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000a4	83 c0 01	 add	 eax, 1
  000a7	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@push_back:
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000b0	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000b3	7d 2f		 jge	 SHORT $LN3@push_back

; 133  : 	{
; 134  : 		if (nIdx >= m_nMax) nIdx = 0;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000bb	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  000be	7c 07		 jl	 SHORT $LN10@push_back
  000c0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nIdx$[ebp], 0
$LN10@push_back:

; 135  : 		if (!m_pArray[nIdx]) {

  000c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	8b 02		 mov	 eax, DWORD PTR [edx]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000cf	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000d3	75 04		 jne	 SHORT $LN11@push_back

; 136  : 			goto ADD_SUCCESS;

  000d5	eb 41		 jmp	 SHORT $ADD_SUCCESS$15
  000d7	eb 3f		 jmp	 SHORT $ADD_SUCCESS$15
$LN11@push_back:

; 137  : 		}
; 138  : 		nIdx++;

  000d9	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  000dc	83 c2 01	 add	 edx, 1
  000df	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 139  : 	}

  000e2	eb bd		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 140  : 	gs_cLogger.DebugLog(LEVEL_ERROR, " i[%d] m_nLast[%d] m_nCurCount[%d]", nIdx, m_nLast, m_nUse);

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ea	51		 push	 ecx
  000eb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ee	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000f1	50		 push	 eax
  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000f5	51		 push	 ecx
  000f6	68 00 00 00 00	 push	 OFFSET $SG44681
  000fb	68 8c 00 00 00	 push	 140			; 0000008cH
  00100	68 00 00 00 00	 push	 OFFSET $SG44682
  00105	6a 05		 push	 5
  00107	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0010c	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00111	83 c4 20	 add	 esp, 32			; 00000020H

; 141  : 	return false;

  00114	32 c0		 xor	 al, al
  00116	eb 3c		 jmp	 SHORT $LN1@push_back
$ADD_SUCCESS$15:

; 142  : 
; 143  : ADD_SUCCESS:
; 144  : 	m_nUse++;

  00118	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0011b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011e	83 c0 01	 add	 eax, 1
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 	m_pArray[nIdx] = Obj;

  00127	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012a	8b 02		 mov	 eax, DWORD PTR [edx]
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  0012f	8b 55 08	 mov	 edx, DWORD PTR _Obj$[ebp]
  00132	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 146  : 	m_nLast++;

  00135	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00138	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013b	83 c1 01	 add	 ecx, 1
  0013e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00141	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 147  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 148  : 	if (pIdx) *pIdx = nIdx;

  00144	83 7d 0c 00	 cmp	 DWORD PTR _pIdx$[ebp], 0
  00148	74 08		 je	 SHORT $LN13@push_back
  0014a	8b 45 0c	 mov	 eax, DWORD PTR _pIdx$[ebp]
  0014d	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00150	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@push_back:

; 149  : 	return true;

  00152	b0 01		 mov	 al, 1
$LN1@push_back:

; 150  : }

  00154	83 c4 0c	 add	 esp, 12			; 0000000cH
  00157	3b ec		 cmp	 ebp, esp
  00159	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
?push_back@CSList@@QAE_NPAXPAH@Z ENDP			; CSList::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
_i$ = -12						; size = 4
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_Obj$ = 8						; size = 4
_pIdx$ = 12						; size = 4
?add@CSList@@QAE_NPAXPAH@Z PROC				; CSList::add
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 	int nIdx, i;
; 85   : 
; 86   : 	if (m_nUse >= m_nMax) {

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00027	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0002a	7c 3f		 jl	 SHORT $LN5@add

; 87   : 		if (!__alloc(m_nMax + UNIT_ADD_SIZE)) {

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00032	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00035	51		 push	 ecx
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__alloc@CSList@@AAEHH@Z ; CSList::__alloc
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN6@add

; 88   : 			return false;

  00042	32 c0		 xor	 al, al
  00044	e9 08 01 00 00	 jmp	 $LN1@add
$LN6@add:

; 89   : 		}
; 90   : 		nIdx = m_nMax;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004f	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax

; 91   : 		m_nMax += UNIT_ADD_SIZE;

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00058	83 c2 0a	 add	 edx, 10			; 0000000aH
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 92   : 		goto ADD_SUCCESS;

  00061	e9 af 00 00 00	 jmp	 $ADD_SUCCESS$15
  00066	e9 aa 00 00 00	 jmp	 $ADD_SUCCESS$15
$LN5@add:

; 93   : 	}
; 94   : 
; 95   : 	if (!m_pArray[m_nDelIdx]) { nIdx = m_nDelIdx; goto ADD_SUCCESS; }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  0007a	75 13		 jne	 SHORT $LN8@add
  0007c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00082	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00085	e9 8b 00 00 00	 jmp	 $ADD_SUCCESS$15
  0008a	e9 86 00 00 00	 jmp	 $ADD_SUCCESS$15
$LN8@add:

; 96   : 
; 97   : 	nIdx = m_nLast;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00095	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 98   : 	for (i = 0; i < m_nMax; i++)

  00098	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0009f	eb 09		 jmp	 SHORT $LN4@add
$LN2@add:
  000a1	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000a4	83 c0 01	 add	 eax, 1
  000a7	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@add:
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000b0	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000b3	7d 2f		 jge	 SHORT $LN3@add

; 99   : 	{
; 100  : 		if (nIdx >= m_nMax) nIdx = 0;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000bb	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  000be	7c 07		 jl	 SHORT $LN10@add
  000c0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nIdx$[ebp], 0
$LN10@add:

; 101  : 		if (!m_pArray[nIdx]) {

  000c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	8b 02		 mov	 eax, DWORD PTR [edx]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000cf	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000d3	75 04		 jne	 SHORT $LN11@add

; 102  : 			goto ADD_SUCCESS;

  000d5	eb 3e		 jmp	 SHORT $ADD_SUCCESS$15
  000d7	eb 3c		 jmp	 SHORT $ADD_SUCCESS$15
$LN11@add:

; 103  : 		}
; 104  : 		nIdx++;

  000d9	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  000dc	83 c2 01	 add	 edx, 1
  000df	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 105  : 	}

  000e2	eb bd		 jmp	 SHORT $LN2@add
$LN3@add:

; 106  : 	gs_cLogger.DebugLog(LEVEL_ERROR, _T("i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ea	51		 push	 ecx
  000eb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ee	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000f1	50		 push	 eax
  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000f5	51		 push	 ecx
  000f6	68 00 00 00 00	 push	 OFFSET $SG44659
  000fb	6a 6a		 push	 106			; 0000006aH
  000fd	68 00 00 00 00	 push	 OFFSET $SG44660
  00102	6a 05		 push	 5
  00104	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00109	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0010e	83 c4 20	 add	 esp, 32			; 00000020H

; 107  : 	return false;

  00111	32 c0		 xor	 al, al
  00113	eb 3c		 jmp	 SHORT $LN1@add
$ADD_SUCCESS$15:

; 108  : 
; 109  : ADD_SUCCESS:
; 110  : 	m_nUse++;

  00115	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00118	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011b	83 c0 01	 add	 eax, 1
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 111  : 	m_pArray[nIdx] = Obj;

  00124	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00127	8b 02		 mov	 eax, DWORD PTR [edx]
  00129	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  0012c	8b 55 08	 mov	 edx, DWORD PTR _Obj$[ebp]
  0012f	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 112  : 	m_nLast++;

  00132	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00135	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00138	83 c1 01	 add	 ecx, 1
  0013b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0013e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 113  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 114  : 	if (pIdx) *pIdx = nIdx;

  00141	83 7d 0c 00	 cmp	 DWORD PTR _pIdx$[ebp], 0
  00145	74 08		 je	 SHORT $LN13@add
  00147	8b 45 0c	 mov	 eax, DWORD PTR _pIdx$[ebp]
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  0014d	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@add:

; 115  : 	return true;

  0014f	b0 01		 mov	 al, 1
$LN1@add:

; 116  : }

  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
  00154	3b ec		 cmp	 ebp, esp
  00156	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 08 00	 ret	 8
?add@CSList@@QAE_NPAXPAH@Z ENDP				; CSList::add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
tv89 = -44						; size = 4
tv79 = -40						; size = 4
tv75 = -36						; size = 4
$T1 = -32						; size = 4
$T2 = -28						; size = 4
_p$3 = -24						; size = 4
_idx$4 = -16						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?clear@CSList@@QAEXXZ PROC				; CSList::clear
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000c	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	if (ISABLETODELETE(m_nObjAllocType)) {

  00026	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  00032	83 c4 04	 add	 esp, 4
  00035	0f b6 d0	 movzx	 edx, al
  00038	85 d2		 test	 edx, edx
  0003a	0f 84 fc 00 00
	00		 je	 $LN6@clear

; 43   : 		int idx = 0;

  00040	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _idx$4[ebp], 0

; 44   : 		void *p = getNext(&idx);

  00047	8d 45 f0	 lea	 eax, DWORD PTR _idx$4[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?getNext@CSList@@QAEPAXPAH@Z ; CSList::getNext
  00053	89 45 e8	 mov	 DWORD PTR _p$3[ebp], eax
$LN2@clear:

; 45   : 		while (p) {

  00056	83 7d e8 00	 cmp	 DWORD PTR _p$3[ebp], 0
  0005a	0f 84 dc 00 00
	00		 je	 $LN6@clear

; 46   : 			idx++;

  00060	8b 4d f0	 mov	 ecx, DWORD PTR _idx$4[ebp]
  00063	83 c1 01	 add	 ecx, 1
  00066	89 4d f0	 mov	 DWORD PTR _idx$4[ebp], ecx

; 47   : 			switch (m_nObjAllocType) {

  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006f	89 45 dc	 mov	 DWORD PTR tv75[ebp], eax
  00072	8b 4d dc	 mov	 ecx, DWORD PTR tv75[ebp]
  00075	83 e9 02	 sub	 ecx, 2
  00078	89 4d dc	 mov	 DWORD PTR tv75[ebp], ecx
  0007b	83 7d dc 03	 cmp	 DWORD PTR tv75[ebp], 3
  0007f	0f 87 a3 00 00
	00		 ja	 $LN4@clear
  00085	8b 55 dc	 mov	 edx, DWORD PTR tv75[ebp]
  00088	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN21@clear[edx*4]
$LN7@clear:

; 48   : 			case eAlloc_Type_new:	delete p; break;

  0008f	8b 45 e8	 mov	 eax, DWORD PTR _p$3[ebp]
  00092	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  00095	6a 00		 push	 0
  00097	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000a0	83 c4 08	 add	 esp, 8
  000a3	83 7d e4 00	 cmp	 DWORD PTR $T2[ebp], 0
  000a7	75 09		 jne	 SHORT $LN14@clear
  000a9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  000b0	eb 0d		 jmp	 SHORT $LN15@clear
$LN14@clear:
  000b2	c7 45 e8 23 81
	00 00		 mov	 DWORD PTR _p$3[ebp], 33059 ; 00008123H
  000b9	8b 55 e8	 mov	 edx, DWORD PTR _p$3[ebp]
  000bc	89 55 d8	 mov	 DWORD PTR tv79[ebp], edx
$LN15@clear:
  000bf	eb 67		 jmp	 SHORT $LN4@clear
$LN8@clear:

; 49   : 			case eAlloc_Type_alloc:	free(p); break;

  000c1	8b f4		 mov	 esi, esp
  000c3	8b 45 e8	 mov	 eax, DWORD PTR _p$3[ebp]
  000c6	50		 push	 eax
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000cd	83 c4 04	 add	 esp, 4
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d7	eb 4f		 jmp	 SHORT $LN4@clear
$LN9@clear:

; 50   : 			case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  000d9	8b 4d e8	 mov	 ecx, DWORD PTR _p$3[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _strlen
  000e2	83 c4 04	 add	 esp, 4
  000e5	83 c0 01	 add	 eax, 1
  000e8	50		 push	 eax
  000e9	8b 55 e8	 mov	 edx, DWORD PTR _p$3[ebp]
  000ec	52		 push	 edx
  000ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000f3	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
  000f8	eb 2e		 jmp	 SHORT $LN4@clear
$LN10@clear:

; 51   : 			case eAlloc_Type_newArray:	delete[] p; break;

  000fa	8b 45 e8	 mov	 eax, DWORD PTR _p$3[ebp]
  000fd	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  00100	8b 4d e0	 mov	 ecx, DWORD PTR $T1[ebp]
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00109	83 c4 04	 add	 esp, 4
  0010c	83 7d e0 00	 cmp	 DWORD PTR $T1[ebp], 0
  00110	75 09		 jne	 SHORT $LN16@clear
  00112	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  00119	eb 0d		 jmp	 SHORT $LN4@clear
$LN16@clear:
  0011b	c7 45 e8 23 81
	00 00		 mov	 DWORD PTR _p$3[ebp], 33059 ; 00008123H
  00122	8b 55 e8	 mov	 edx, DWORD PTR _p$3[ebp]
  00125	89 55 d4	 mov	 DWORD PTR tv89[ebp], edx
$LN4@clear:

; 52   : 			case eAlloc_Type_none: break;
; 53   : 			case eAlloc_Type_MemPool: break;
; 54   : 			}
; 55   : 			p = getNext(&idx);

  00128	8d 45 f0	 lea	 eax, DWORD PTR _idx$4[ebp]
  0012b	50		 push	 eax
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?getNext@CSList@@QAEPAXPAH@Z ; CSList::getNext
  00134	89 45 e8	 mov	 DWORD PTR _p$3[ebp], eax

; 56   : 		}

  00137	e9 1a ff ff ff	 jmp	 $LN2@clear
$LN6@clear:

; 57   : 	}
; 58   : 	memset(m_pArray, 0, sizeof(void *) * m_nMax);

  0013c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00142	c1 e2 02	 shl	 edx, 2
  00145	52		 push	 edx
  00146	6a 00		 push	 0
  00148	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 _memset
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH

; 59   : 	m_nUse = 0;

  00156	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00159	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 60   : 	m_nLast = 0;

  00160	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00163	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 61   : 	m_nDelIdx = 0;

  0016a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 62   : }

  00174	52		 push	 edx
  00175	8b cd		 mov	 ecx, ebp
  00177	50		 push	 eax
  00178	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@clear
  0017e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00183	58		 pop	 eax
  00184	5a		 pop	 edx
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	83 c4 2c	 add	 esp, 44			; 0000002cH
  00194	3b ec		 cmp	 ebp, esp
  00196	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
  0019f	90		 npad	 1
$LN20@clear:
  001a0	01 00 00 00	 DD	 1
  001a4	00 00 00 00	 DD	 $LN19@clear
$LN19@clear:
  001a8	f0 ff ff ff	 DD	 -16			; fffffff0H
  001ac	04 00 00 00	 DD	 4
  001b0	00 00 00 00	 DD	 $LN18@clear
$LN18@clear:
  001b4	69		 DB	 105			; 00000069H
  001b5	64		 DB	 100			; 00000064H
  001b6	78		 DB	 120			; 00000078H
  001b7	00		 DB	 0
$LN21@clear:
  001b8	00 00 00 00	 DD	 $LN7@clear
  001bc	00 00 00 00	 DD	 $LN8@clear
  001c0	00 00 00 00	 DD	 $LN9@clear
  001c4	00 00 00 00	 DD	 $LN10@clear
?clear@CSList@@QAEXXZ ENDP				; CSList::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
tv91 = -56						; size = 4
tv81 = -52						; size = 4
tv77 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
_p$4 = -36						; size = 4
_idx$5 = -28						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1CSList@@QAE@XZ PROC					; CSList::~CSList
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CSList@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  0001a	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	59		 pop	 ecx
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 17   : 	if (!m_pArray) return;

  0003e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 38 00	 cmp	 DWORD PTR [eax], 0
  00044	75 05		 jne	 SHORT $LN6@CSList
  00046	e9 37 01 00 00	 jmp	 $LN14@CSList
$LN6@CSList:

; 18   : 
; 19   : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  00057	83 c4 04	 add	 esp, 4
  0005a	0f b6 c0	 movzx	 eax, al
  0005d	85 c0		 test	 eax, eax
  0005f	0f 84 fc 00 00
	00		 je	 $LN7@CSList

; 20   : 		int idx = 0;

  00065	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _idx$5[ebp], 0

; 21   : 		void *p = getNext(&idx);

  0006c	8d 4d e4	 lea	 ecx, DWORD PTR _idx$5[ebp]
  0006f	51		 push	 ecx
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?getNext@CSList@@QAEPAXPAH@Z ; CSList::getNext
  00078	89 45 dc	 mov	 DWORD PTR _p$4[ebp], eax
$LN2@CSList:

; 22   : 		while (p) {

  0007b	83 7d dc 00	 cmp	 DWORD PTR _p$4[ebp], 0
  0007f	0f 84 dc 00 00
	00		 je	 $LN7@CSList

; 23   : 			idx++;

  00085	8b 55 e4	 mov	 edx, DWORD PTR _idx$5[ebp]
  00088	83 c2 01	 add	 edx, 1
  0008b	89 55 e4	 mov	 DWORD PTR _idx$5[ebp], edx

; 24   : 			switch (m_nObjAllocType) {

  0008e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00094	89 4d d0	 mov	 DWORD PTR tv77[ebp], ecx
  00097	8b 55 d0	 mov	 edx, DWORD PTR tv77[ebp]
  0009a	83 ea 02	 sub	 edx, 2
  0009d	89 55 d0	 mov	 DWORD PTR tv77[ebp], edx
  000a0	83 7d d0 03	 cmp	 DWORD PTR tv77[ebp], 3
  000a4	0f 87 a3 00 00
	00		 ja	 $LN4@CSList
  000aa	8b 45 d0	 mov	 eax, DWORD PTR tv77[ebp]
  000ad	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN23@CSList[eax*4]
$LN8@CSList:

; 25   : 			case eAlloc_Type_new:	delete p; break;

  000b4	8b 4d dc	 mov	 ecx, DWORD PTR _p$4[ebp]
  000b7	89 4d d8	 mov	 DWORD PTR $T3[ebp], ecx
  000ba	6a 00		 push	 0
  000bc	8b 55 d8	 mov	 edx, DWORD PTR $T3[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c5	83 c4 08	 add	 esp, 8
  000c8	83 7d d8 00	 cmp	 DWORD PTR $T3[ebp], 0
  000cc	75 09		 jne	 SHORT $LN15@CSList
  000ce	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  000d5	eb 0d		 jmp	 SHORT $LN16@CSList
$LN15@CSList:
  000d7	c7 45 dc 23 81
	00 00		 mov	 DWORD PTR _p$4[ebp], 33059 ; 00008123H
  000de	8b 45 dc	 mov	 eax, DWORD PTR _p$4[ebp]
  000e1	89 45 cc	 mov	 DWORD PTR tv81[ebp], eax
$LN16@CSList:
  000e4	eb 67		 jmp	 SHORT $LN4@CSList
$LN9@CSList:

; 26   : 			case eAlloc_Type_alloc:	free(p); break;

  000e6	8b f4		 mov	 esi, esp
  000e8	8b 4d dc	 mov	 ecx, DWORD PTR _p$4[ebp]
  000eb	51		 push	 ecx
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000f2	83 c4 04	 add	 esp, 4
  000f5	3b f4		 cmp	 esi, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fc	eb 4f		 jmp	 SHORT $LN4@CSList
$LN10@CSList:

; 27   : 			case eAlloc_Type_BufPool:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  000fe	8b 55 dc	 mov	 edx, DWORD PTR _p$4[ebp]
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 _strlen
  00107	83 c4 04	 add	 esp, 4
  0010a	83 c0 01	 add	 eax, 1
  0010d	50		 push	 eax
  0010e	8b 45 dc	 mov	 eax, DWORD PTR _p$4[ebp]
  00111	50		 push	 eax
  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00118	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
  0011d	eb 2e		 jmp	 SHORT $LN4@CSList
$LN11@CSList:

; 28   : 			case eAlloc_Type_newArray:	delete[] p; break;

  0011f	8b 4d dc	 mov	 ecx, DWORD PTR _p$4[ebp]
  00122	89 4d d4	 mov	 DWORD PTR $T2[ebp], ecx
  00125	8b 55 d4	 mov	 edx, DWORD PTR $T2[ebp]
  00128	52		 push	 edx
  00129	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0012e	83 c4 04	 add	 esp, 4
  00131	83 7d d4 00	 cmp	 DWORD PTR $T2[ebp], 0
  00135	75 09		 jne	 SHORT $LN17@CSList
  00137	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  0013e	eb 0d		 jmp	 SHORT $LN4@CSList
$LN17@CSList:
  00140	c7 45 dc 23 81
	00 00		 mov	 DWORD PTR _p$4[ebp], 33059 ; 00008123H
  00147	8b 45 dc	 mov	 eax, DWORD PTR _p$4[ebp]
  0014a	89 45 c8	 mov	 DWORD PTR tv91[ebp], eax
$LN4@CSList:

; 29   : 			case eAlloc_Type_none: break;
; 30   : 			case eAlloc_Type_MemPool: break;
; 31   : 			}
; 32   : 			p = getNext(&idx);

  0014d	8d 4d e4	 lea	 ecx, DWORD PTR _idx$5[ebp]
  00150	51		 push	 ecx
  00151	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	e8 00 00 00 00	 call	 ?getNext@CSList@@QAEPAXPAH@Z ; CSList::getNext
  00159	89 45 dc	 mov	 DWORD PTR _p$4[ebp], eax

; 33   : 		}

  0015c	e9 1a ff ff ff	 jmp	 $LN2@CSList
$LN7@CSList:

; 34   : 	}
; 35   : 
; 36   : 	free(m_pArray);

  00161	8b f4		 mov	 esi, esp
  00163	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00166	8b 02		 mov	 eax, DWORD PTR [edx]
  00168	50		 push	 eax
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0016f	83 c4 04	 add	 esp, 4
  00172	3b f4		 cmp	 esi, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 37   : 	m_pArray = 0;

  00179	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN14@CSList:

; 38   : }

  00182	52		 push	 edx
  00183	8b cd		 mov	 ecx, ebp
  00185	50		 push	 eax
  00186	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@CSList
  0018c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00191	58		 pop	 eax
  00192	5a		 pop	 edx
  00193	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00196	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019d	59		 pop	 ecx
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a3	33 cd		 xor	 ecx, ebp
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	83 c4 38	 add	 esp, 56			; 00000038H
  001ad	3b ec		 cmp	 ebp, esp
  001af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c3		 ret	 0
$LN22@CSList:
  001b8	01 00 00 00	 DD	 1
  001bc	00 00 00 00	 DD	 $LN21@CSList
$LN21@CSList:
  001c0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  001c4	04 00 00 00	 DD	 4
  001c8	00 00 00 00	 DD	 $LN19@CSList
$LN19@CSList:
  001cc	69		 DB	 105			; 00000069H
  001cd	64		 DB	 100			; 00000064H
  001ce	78		 DB	 120			; 00000078H
  001cf	00		 DB	 0
$LN23@CSList:
  001d0	00 00 00 00	 DD	 $LN8@CSList
  001d4	00 00 00 00	 DD	 $LN9@CSList
  001d8	00 00 00 00	 DD	 $LN10@CSList
  001dc	00 00 00 00	 DD	 $LN11@CSList
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1CSList@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CSList@@QAE@XZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CSList@@QAE@XZ ENDP					; CSList::~CSList
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlist.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSList@@QAE@XZ PROC					; CSList::CSList
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 7    : 	m_pArray = NULL;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 8    : 	m_nUse = 0;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 9    : 	m_nLast = 0;

  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 10   : 	m_nDelIdx = 0;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 11   : 	m_nMax = 0;

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 12   : 	m_nObjAllocType = eAlloc_Type_none;

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 13   : }

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??0CSList@@QAE@XZ ENDP					; CSList::CSList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QAEXPADH@Z
_TEXT	SEGMENT
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_pBuf$ = 8						; size = 4
_nSize$ = 12						; size = 4
?delBuf@CMemManager@@QAEXPADH@Z PROC			; CMemManager::delBuf, COMDAT
; _this$ = ecx

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	8b 45 0c	 mov	 eax, DWORD PTR _nSize$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?delBuf@CMemManager@@QAEXPADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = -24						; size = 4
_$S1$ = -16						; size = 8
_m$ = -4						; size = 4
_s$ = 8							; size = 4
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _s$[ebp]
  00022	f2 0f 11 45 f0	 movsd	 QWORD PTR _$S1$[ebp], xmm0
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	c1 e0 00	 shl	 eax, 0
  0002f	8b 4c 05 f0	 mov	 ecx, DWORD PTR _$S1$[ebp+eax]
  00033	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00036	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0003c	89 4d fc	 mov	 DWORD PTR _m$[ebp], ecx
  0003f	ba 01 00 00 00	 mov	 edx, 1
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00047	d3 e2		 shl	 edx, cl
  00049	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	2b c2		 sub	 eax, edx
  0004e	23 45 08	 and	 eax, DWORD PTR _s$[ebp]
  00051	74 09		 je	 SHORT $LN3@getIndex
  00053	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  0005c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@getIndex:
  00063	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00066	03 45 e8	 add	 eax, DWORD PTR tv73[ebp]
  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@getIndex
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN7@getIndex:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN6@getIndex
$LN6@getIndex:
  00088	f0 ff ff ff	 DD	 -16			; fffffff0H
  0008c	08 00 00 00	 DD	 8
  00090	00 00 00 00	 DD	 $LN5@getIndex
$LN5@getIndex:
  00094	24		 DB	 36			; 00000024H
  00095	53		 DB	 83			; 00000053H
  00096	31		 DB	 49			; 00000031H
  00097	00		 DB	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_max$ = 12						; size = 4
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 08 00	 cmp	 DWORD PTR _i$[ebp], 0
  00007	7c 0c		 jl	 SHORT $LN2@ISINCLUDE
  00009	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR _max$[ebp]
  0000f	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  00011	b0 01		 mov	 al, 1
  00013	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  00015	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z PROC		; ISABLETODELETE, COMDAT

; 247  : inline bool ISABLETODELETE(E_ALLOC_TYPE e) { if (eAlloc_Type_MemPool < e) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 08 01	 cmp	 DWORD PTR _e$[ebp], 1
  00007	7e 04		 jle	 SHORT $LN2@ISABLETODE
  00009	b0 01		 mov	 al, 1
  0000b	eb 02		 jmp	 SHORT $LN1@ISABLETODE
$LN2@ISABLETODE:
  0000d	32 c0		 xor	 al, al
$LN1@ISABLETODE:
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ENDP		; ISABLETODELETE
_TEXT	ENDS
END
