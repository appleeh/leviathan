; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comHash.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	??0CHash@@QAE@I@Z				; CHash::CHash
PUBLIC	??1CHash@@QAE@XZ				; CHash::~CHash
PUBLIC	?clear@CHash@@QAEXXZ				; CHash::clear
PUBLIC	?getHashNo@CHash@@QAEIPAD@Z			; CHash::getHashNo
PUBLIC	?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z	; CHash::hashLookup
PUBLIC	?hashLookup@CHash@@QAEPAUSTHash_Node@@IPAD@Z	; CHash::hashLookup
PUBLIC	?getNext@CHash@@QAEPAUSThash_next@@I@Z		; CHash::getNext
PUBLIC	?getNext@CHash@@QAEPAUSThash_next@@PAD@Z	; CHash::getNext
PUBLIC	?getNode@CHash@@QAEPAUSThash_next@@PADPAPAU2@@Z	; CHash::getNode
PUBLIC	?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@PADPAX@Z ; CHash::setValue
PUBLIC	?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@IPADPAX@Z ; CHash::setValue
PUBLIC	?addNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z	; CHash::addNode
PUBLIC	?uniqueAddNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z ; CHash::uniqueAddNode
PUBLIC	?getString@CHash@@QAEIPAD0I@Z			; CHash::getString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0CN@DINJJIKB@?$CFs?5hashMap?5key?5distribution?5m_nM@ ; `string'
PUBLIC	??_C@_0CD@CMLICHAP@?5?9?9?9?5m_pHashData?$FL?$CFd?$FN?5useCount?$FL?$CFd@ ; `string'
PUBLIC	??_C@_0CD@MOKDKAGF@?5m_nMaxCount?$FL?$CFd?$FN?5usedKeyCount?$FL?$CFd@ ; `string'
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp___mbscmp:PROC
EXTRN	__imp___mbsnbcpy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0CD@MOKDKAGF@?5m_nMaxCount?$FL?$CFd?$FN?5usedKeyCount?$FL?$CFd@
CONST	SEGMENT
??_C@_0CD@MOKDKAGF@?5m_nMaxCount?$FL?$CFd?$FN?5usedKeyCount?$FL?$CFd@ DB ' '
	DB	'm_nMaxCount[%d] usedKeyCount[%d]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CMLICHAP@?5?9?9?9?5m_pHashData?$FL?$CFd?$FN?5useCount?$FL?$CFd@
CONST	SEGMENT
??_C@_0CD@CMLICHAP@?5?9?9?9?5m_pHashData?$FL?$CFd?$FN?5useCount?$FL?$CFd@ DB ' '
	DB	'--- m_pHashData[%d] useCount[%d]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DINJJIKB@?$CFs?5hashMap?5key?5distribution?5m_nM@
CONST	SEGMENT
??_C@_0CN@DINJJIKB@?$CFs?5hashMap?5key?5distribution?5m_nM@ DB '%s hashMa'
	DB	'p key distribution m_nMaxCount[%d]', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comhash.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getString@CHash@@QAEIPAD0I@Z
_TEXT	SEGMENT
_pBuf$GSCopy$1$ = -4628					; size = 4
_this$GSCopy$1$ = -4624					; size = 4
tv345 = -4620						; size = 4
_nUseCount$1$ = -4616					; size = 4
_szBuf$ = -4612						; size = 4096
_szUnit$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_pTitle$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nBufMax$ = 16						; size = 4
?getString@CHash@@QAEIPAD0I@Z PROC			; CHash::getString, COMDAT
; _this$ = ecx

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 14 12 00 00	 mov	 eax, 4628		; 00001214H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _pTitle$[ebp]
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b f9		 mov	 edi, ecx

; 177  : 	/*
; 178  : 	TCHAR szBuf[128];
; 179  : 	size_t nSize[5];
; 180  : 	memset(nSize, 0, sizeof(nSize));
; 181  : 	int i, cnt = 0;
; 182  : 	nSize[cnt++] = sizeof(m_pHashData);
; 183  : 	nSize[cnt++] = sizeof(SThash_value);
; 184  : 	_stprintf(szBuf, _T("%s m_pHashData's size:%ul maxCount:%d, unitSize:%d\n"), pTitle, nSize[0], m_nMaxCount, nSize[1]);
; 185  : 	_tcscpy(pBuf, szBuf);
; 186  : 	for (i = 0; i < cnt; i++)
; 187  : 	{
; 188  : 		nSize[4] += nSize[i];
; 189  : 	}
; 190  : 	return nSize[4];
; 191  : 	*/
; 192  : 
; 193  : 	SThash_next *pNext;
; 194  : 	TCHAR szBuf[4096], szUnit[512];
; 195  : 	unsigned int i,j, nNextPos=0, nStrSize, nUseCount=0;

  0001f	c7 85 f8 ed ff
	ff 00 00 00 00	 mov	 DWORD PTR _nUseCount$1$[ebp], 0
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  0002c	89 bd f0 ed ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00032	89 8d ec ed ff
	ff		 mov	 DWORD PTR _pBuf$GSCopy$1$[ebp], ecx

; 196  : 
; 197  : 	_stprintf(szUnit, _T("%s hashMap key distribution m_nMaxCount[%d]\n"), pTitle, m_nMaxCount);

  00038	ff 37		 push	 DWORD PTR [edi]
  0003a	50		 push	 eax
  0003b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szUnit$[ebp]
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DINJJIKB@?$CFs?5hashMap?5key?5distribution?5m_nM@
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _sprintf

; 198  : 	nStrSize = (int)_tcslen(szUnit);

  0004c	8d b5 fc fd ff
	ff		 lea	 esi, DWORD PTR _szUnit$[ebp]
  00052	83 c4 10	 add	 esp, 16			; 00000010H
  00055	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL37@getString:
  00058	8a 06		 mov	 al, BYTE PTR [esi]
  0005a	46		 inc	 esi
  0005b	84 c0		 test	 al, al
  0005d	75 f9		 jne	 SHORT $LL37@getString
  0005f	2b f1		 sub	 esi, ecx

; 199  : 	_tcscpy(szBuf + nNextPos, szUnit);

  00061	33 c9		 xor	 ecx, ecx
$LL14@getString:
  00063	8a 84 0d fc fd
	ff ff		 mov	 al, BYTE PTR _szUnit$[ebp+ecx]
  0006a	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0006d	88 84 0d fb ed
	ff ff		 mov	 BYTE PTR _szBuf$[ebp+ecx-1], al
  00074	84 c0		 test	 al, al
  00076	75 eb		 jne	 SHORT $LL14@getString

; 201  : 
; 202  : 	for (i = 0; i < m_nMaxCount; i++)

  00078	33 db		 xor	 ebx, ebx
  0007a	39 1f		 cmp	 DWORD PTR [edi], ebx
  0007c	0f 86 b1 00 00
	00		 jbe	 $LN3@getString

; 200  : 	nNextPos += nStrSize;

  00082	33 d2		 xor	 edx, edx
  00084	89 95 f4 ed ff
	ff		 mov	 DWORD PTR tv345[ebp], edx
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@getString:

; 203  : 	{
; 204  : 		j = 0;
; 205  : 		for (pNext = m_pHashData[i].pNext; pNext != NULL; pNext = pNext->next) { j++; }

  00090	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00093	33 c9		 xor	 ecx, ecx
  00095	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00099	85 c0		 test	 eax, eax
  0009b	0f 84 80 00 00
	00		 je	 $LN2@getString
$LL7@getString:
  000a1	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a4	41		 inc	 ecx
  000a5	85 c0		 test	 eax, eax
  000a7	75 f8		 jne	 SHORT $LL7@getString

; 206  : 		if (j) {

  000a9	85 c9		 test	 ecx, ecx
  000ab	74 74		 je	 SHORT $LN2@getString

; 207  : 			_stprintf(szUnit, _T(" --- m_pHashData[%d] useCount[%d]\n"), i, j);

  000ad	51		 push	 ecx
  000ae	53		 push	 ebx
  000af	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szUnit$[ebp]
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@CMLICHAP@?5?9?9?9?5m_pHashData?$FL?$CFd?$FN?5useCount?$FL?$CFd@
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _sprintf

; 208  : 			nStrSize = (int)_tcslen(szUnit);

  000c0	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _szUnit$[ebp]
  000c6	83 c4 10	 add	 esp, 16			; 00000010H
  000c9	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000cc	0f 1f 40 00	 npad	 4
$LL38@getString:
  000d0	8a 01		 mov	 al, BYTE PTR [ecx]
  000d2	41		 inc	 ecx
  000d3	84 c0		 test	 al, al
  000d5	75 f9		 jne	 SHORT $LL38@getString
  000d7	2b ca		 sub	 ecx, edx

; 209  : 			if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  000d9	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  000dc	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000df	39 45 10	 cmp	 DWORD PTR _nBufMax$[ebp], eax
  000e2	0f 82 a7 00 00
	00		 jb	 $ENDPROC$41

; 210  : 			_tcscpy(szBuf+nNextPos, szUnit);

  000e8	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szUnit$[ebp]
  000ee	8b c8		 mov	 ecx, eax
  000f0	8d 95 fc ed ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  000f6	2b f1		 sub	 esi, ecx
  000f8	03 d6		 add	 edx, esi
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL15@getString:
  00100	8a 08		 mov	 cl, BYTE PTR [eax]
  00102	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00105	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  00109	84 c9		 test	 cl, cl
  0010b	75 f3		 jne	 SHORT $LL15@getString

; 211  : 			nNextPos += nStrSize;
; 212  : 
; 213  : 			nUseCount++;

  0010d	ff 85 f8 ed ff
	ff		 inc	 DWORD PTR _nUseCount$1$[ebp]
  00113	8b f7		 mov	 esi, edi
  00115	8b 95 f4 ed ff
	ff		 mov	 edx, DWORD PTR tv345[ebp]
  0011b	8b bd f0 ed ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN2@getString:

; 201  : 
; 202  : 	for (i = 0; i < m_nMaxCount; i++)

  00121	43		 inc	 ebx
  00122	83 c2 0c	 add	 edx, 12			; 0000000cH
  00125	89 95 f4 ed ff
	ff		 mov	 DWORD PTR tv345[ebp], edx
  0012b	3b 1f		 cmp	 ebx, DWORD PTR [edi]
  0012d	0f 82 5d ff ff
	ff		 jb	 $LL4@getString
$LN3@getString:

; 214  : 		}
; 215  : 	}
; 216  : 	_stprintf(szUnit, _T(" m_nMaxCount[%d] usedKeyCount[%d]\n"), m_nMaxCount, nUseCount);

  00133	ff b5 f8 ed ff
	ff		 push	 DWORD PTR _nUseCount$1$[ebp]
  00139	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szUnit$[ebp]
  0013f	ff 37		 push	 DWORD PTR [edi]
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@MOKDKAGF@?5m_nMaxCount?$FL?$CFd?$FN?5usedKeyCount?$FL?$CFd@
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _sprintf

; 217  : 	nStrSize = (int)_tcslen(szUnit);

  0014c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _szUnit$[ebp]
  00152	83 c4 10	 add	 esp, 16			; 00000010H
  00155	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL39@getString:
  00158	8a 01		 mov	 al, BYTE PTR [ecx]
  0015a	41		 inc	 ecx
  0015b	84 c0		 test	 al, al
  0015d	75 f9		 jne	 SHORT $LL39@getString
  0015f	2b ca		 sub	 ecx, edx

; 218  : 	if (nBufMax < nNextPos + nStrSize + 1) goto ENDPROC;

  00161	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  00164	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00167	39 45 10	 cmp	 DWORD PTR _nBufMax$[ebp], eax
  0016a	72 23		 jb	 SHORT $ENDPROC$41

; 219  : 	_tcscpy(szBuf + nNextPos, szUnit);

  0016c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _szUnit$[ebp]
  00172	8d 95 fc ed ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  00178	8b c1		 mov	 eax, ecx
  0017a	03 d6		 add	 edx, esi
  0017c	2b d0		 sub	 edx, eax
  0017e	66 90		 npad	 2
$LL16@getString:
  00180	8a 01		 mov	 al, BYTE PTR [ecx]
  00182	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00185	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00189	84 c0		 test	 al, al
  0018b	75 f3		 jne	 SHORT $LL16@getString

; 220  : 	nNextPos += nStrSize;

  0018d	8b f7		 mov	 esi, edi
$ENDPROC$41:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  0018f	8b bd ec ed ff
	ff		 mov	 edi, DWORD PTR _pBuf$GSCopy$1$[ebp]
  00195	8d 85 fc ed ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0019b	56		 push	 esi
  0019c	50		 push	 eax
  0019d	57		 push	 edi
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
; File e:\infinia-library-3.0\com\src\comhash.cpp

; 226  : }

  001a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  001a7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\infinia-library-3.0\com\src\comhash.cpp

; 224  : 	pBuf[nNextPos] = 0;

  001aa	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0

; 225  : 	return nNextPos;

  001ae	8b c6		 mov	 eax, esi

; 226  : }

  001b0	33 cd		 xor	 ecx, ebp
  001b2	5f		 pop	 edi
  001b3	5e		 pop	 esi
  001b4	5b		 pop	 ebx
  001b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c2 0c 00	 ret	 12			; 0000000cH
?getString@CHash@@QAEIPAD0I@Z ENDP			; CHash::getString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?uniqueAddNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv266 = 8						; size = 4
_pNext$ = 8						; size = 4
_nHashNo$1$ = 12					; size = 4
_pKey$ = 12						; size = 4
_pData$ = 16						; size = 4
?uniqueAddNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z PROC	; CHash::uniqueAddNode, COMDAT
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _pKey$[ebp]
  00008	8b d3		 mov	 edx, ebx
  0000a	56		 push	 esi

; 151  : {

  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	57		 push	 edi

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  0000f	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL28@uniqueAddN:
  00012	8a 02		 mov	 al, BYTE PTR [edx]
  00014	42		 inc	 edx
  00015	84 c0		 test	 al, al
  00017	75 f9		 jne	 SHORT $LL28@uniqueAddN
  00019	2b d1		 sub	 edx, ecx

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;
; 35   : 	for(i=0; i < nLen; i++) {

  0001b	be 00 00 00 00	 mov	 esi, 0
  00020	8b fa		 mov	 edi, edx
  00022	74 12		 je	 SHORT $LN12@uniqueAddN
$LL22@uniqueAddN:

; 36   : 		key += (key << 4) + (int)pStr[i];

  00024	0f be 0c 1e	 movsx	 ecx, BYTE PTR [esi+ebx]
  00028	8b c7		 mov	 eax, edi
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	46		 inc	 esi
  0002e	03 f8		 add	 edi, eax
  00030	03 f9		 add	 edi, ecx
  00032	3b f2		 cmp	 esi, edx
  00034	72 ee		 jb	 SHORT $LL22@uniqueAddN
$LN12@uniqueAddN:

; 37   : 	}
; 38   : 	key = key % m_nMaxCount;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00039	33 d2		 xor	 edx, edx
  0003b	8b c7		 mov	 eax, edi
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	f7 f1		 div	 ecx

; 152  : 	SThash_next **pNextAddr;
; 153  : 
; 154  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  00041	89 55 0c	 mov	 DWORD PTR _nHashNo$1$[ebp], edx

; 155  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  00044	3b d1		 cmp	 edx, ecx
  00046	72 0e		 jb	 SHORT $LN5@uniqueAddN
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0004f	5b		 pop	 ebx

; 173  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
$LN5@uniqueAddN:

; 156  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00056	8b 7d 08	 mov	 edi, DWORD PTR _pNext$[ebp]
  00059	85 ff		 test	 edi, edi
  0005b	75 0c		 jne	 SHORT $LN6@uniqueAddN
  0005d	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 173  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
$LN6@uniqueAddN:

; 157  : 
; 158  : 
; 159  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) 

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0006c	8d 34 52	 lea	 esi, DWORD PTR [edx+edx*2]
  0006f	c1 e6 02	 shl	 esi, 2
  00072	89 75 08	 mov	 DWORD PTR tv266[ebp], esi
  00075	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00078	83 c0 08	 add	 eax, 8
  0007b	03 f0		 add	 esi, eax
  0007d	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00080	74 20		 je	 SHORT $LN3@uniqueAddN
$LL4@uniqueAddN:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00082	ff 37		 push	 DWORD PTR [edi]
  00084	53		 push	 ebx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  0008b	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comhash.cpp

; 161  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0) return eHASH_RESULT_DUPLICATE_KEYS;

  0008e	85 c0		 test	 eax, eax
  00090	74 45		 je	 SHORT $LN19@uniqueAddN

; 157  : 
; 158  : 
; 159  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) 

  00092	8b 36		 mov	 esi, DWORD PTR [esi]
  00094	83 c6 08	 add	 esi, 8
  00097	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0009a	75 e6		 jne	 SHORT $LL4@uniqueAddN

; 161  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0) return eHASH_RESULT_DUPLICATE_KEYS;

  0009c	8b 55 0c	 mov	 edx, DWORD PTR _nHashNo$1$[ebp]
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN3@uniqueAddN:

; 162  : 	}
; 163  : 
; 164  : 	pNext->pNode.pKey = pKey;
; 165  : 	pNext->pNode.value = pData;

  000a2	8b 45 10	 mov	 eax, DWORD PTR _pData$[ebp]
  000a5	89 1f		 mov	 DWORD PTR [edi], ebx
  000a7	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 166  : 	pNext->next = NULL;

  000aa	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 167  : 	*pNextAddr = pNext;

  000b1	89 3e		 mov	 DWORD PTR [esi], edi

; 168  : 
; 169  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  000b3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000b6	8b 75 08	 mov	 esi, DWORD PTR tv266[ebp]
  000b9	83 3c 30 00	 cmp	 DWORD PTR [eax+esi], 0
  000bd	75 03		 jne	 SHORT $LN8@uniqueAddN
  000bf	89 14 30	 mov	 DWORD PTR [eax+esi], edx
$LN8@uniqueAddN:

; 170  : 	m_pHashData[nHashNo].nElementCnt++;

  000c2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000c5	5f		 pop	 edi
  000c6	ff 44 30 04	 inc	 DWORD PTR [eax+esi+4]

; 171  : 	m_nElementCount++;
; 172  : 	return nHashNo;

  000ca	8b c2		 mov	 eax, edx
  000cc	ff 41 04	 inc	 DWORD PTR [ecx+4]
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx

; 173  : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 0c 00	 ret	 12			; 0000000cH
$LN19@uniqueAddN:
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi

; 161  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0) return eHASH_RESULT_DUPLICATE_KEYS;

  000d9	83 c8 ff	 or	 eax, -1
  000dc	5b		 pop	 ebx

; 173  : }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 0c 00	 ret	 12			; 0000000cH
?uniqueAddNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z ENDP	; CHash::uniqueAddNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?addNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pNext$ = 8						; size = 4
tv267 = 12						; size = 4
_pKey$ = 12						; size = 4
_pData$ = 16						; size = 4
?addNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z PROC	; CHash::addNode, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _pKey$[ebp]
  00008	8b d3		 mov	 edx, ebx
  0000a	56		 push	 esi

; 129  : {

  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	57		 push	 edi

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  0000f	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL24@addNode:
  00012	8a 02		 mov	 al, BYTE PTR [edx]
  00014	42		 inc	 edx
  00015	84 c0		 test	 al, al
  00017	75 f9		 jne	 SHORT $LL24@addNode
  00019	2b d1		 sub	 edx, ecx

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;
; 35   : 	for(i=0; i < nLen; i++) {

  0001b	be 00 00 00 00	 mov	 esi, 0
  00020	8b fa		 mov	 edi, edx
  00022	74 12		 je	 SHORT $LN11@addNode
$LL18@addNode:

; 36   : 		key += (key << 4) + (int)pStr[i];

  00024	0f be 0c 1e	 movsx	 ecx, BYTE PTR [esi+ebx]
  00028	8b c7		 mov	 eax, edi
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	46		 inc	 esi
  0002e	03 f8		 add	 edi, eax
  00030	03 f9		 add	 edi, ecx
  00032	3b f2		 cmp	 esi, edx
  00034	72 ee		 jb	 SHORT $LL18@addNode
$LN11@addNode:

; 37   : 	}
; 38   : 	key = key % m_nMaxCount;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00039	33 d2		 xor	 edx, edx
  0003b	8b c7		 mov	 eax, edi
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	f7 f1		 div	 ecx

; 130  : 	SThash_next **pNextAddr;
; 131  : 
; 132  : 	HASH_TYPE nHashNo = getHashNo(pKey);

  00041	8b f2		 mov	 esi, edx

; 133  : 	if (nHashNo >= m_nMaxCount) return eHASH_RESULT_INVALID_KEY;

  00043	3b f1		 cmp	 esi, ecx
  00045	72 0e		 jb	 SHORT $LN5@addNode
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0004e	5b		 pop	 ebx

; 147  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
$LN5@addNode:

; 134  : 	if (!pNext) return eHASH_RESULT_EMPTY_NODE;

  00055	8b 55 08	 mov	 edx, DWORD PTR _pNext$[ebp]
  00058	85 d2		 test	 edx, edx
  0005a	75 0c		 jne	 SHORT $LN6@addNode
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00061	5b		 pop	 ebx

; 147  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
$LN6@addNode:

; 135  : 
; 136  : 	
; 137  : 	for (pNextAddr = &(m_pHashData[nHashNo].pNext); *pNextAddr != NULL; pNextAddr = &(*pNextAddr)->next) {}

  00068	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  0006b	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  0006e	c1 e1 02	 shl	 ecx, 2
  00071	89 4d 0c	 mov	 DWORD PTR tv267[ebp], ecx
  00074	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00077	83 c0 08	 add	 eax, 8
  0007a	03 c8		 add	 ecx, eax
  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	85 c0		 test	 eax, eax
  00080	74 09		 je	 SHORT $LN3@addNode
$LL4@addNode:
  00082	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00085	8b 01		 mov	 eax, DWORD PTR [ecx]
  00087	85 c0		 test	 eax, eax
  00089	75 f7		 jne	 SHORT $LL4@addNode
$LN3@addNode:

; 138  : 	pNext->pNode.pKey = pKey;
; 139  : 	pNext->pNode.value = pData;

  0008b	8b 45 10	 mov	 eax, DWORD PTR _pData$[ebp]
  0008e	89 1a		 mov	 DWORD PTR [edx], ebx
  00090	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 140  : 	pNext->next = NULL;

  00093	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 141  : 	*pNextAddr = pNext;

  0009a	89 11		 mov	 DWORD PTR [ecx], edx

; 142  : 
; 143  : 	if (!m_pHashData[nHashNo].nHashKey) m_pHashData[nHashNo].nHashKey = nHashNo;

  0009c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0009f	8b 4d 0c	 mov	 ecx, DWORD PTR tv267[ebp]
  000a2	83 3c 08 00	 cmp	 DWORD PTR [eax+ecx], 0
  000a6	75 03		 jne	 SHORT $LN7@addNode
  000a8	89 34 08	 mov	 DWORD PTR [eax+ecx], esi
$LN7@addNode:

; 144  : 	m_pHashData[nHashNo].nElementCnt++;

  000ab	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000ae	ff 44 08 04	 inc	 DWORD PTR [eax+ecx+4]

; 145  : 	m_nElementCount++;
; 146  : 	return nHashNo;

  000b2	8b c6		 mov	 eax, esi
  000b4	ff 47 04	 inc	 DWORD PTR [edi+4]
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 147  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 0c 00	 ret	 12			; 0000000cH
?addNode@CHash@@QAEHPAUSThash_next@@PADPAX@Z ENDP	; CHash::addNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@IPADPAX@Z
_TEXT	SEGMENT
_nHashNo$ = 8						; size = 4
_pKey$ = 12						; size = 4
_pData$ = 16						; size = 4
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@IPADPAX@Z PROC ; CHash::setValue, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 112  : 	SThash_next *pNext;
; 113  : 
; 114  : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00003	8b 45 08	 mov	 eax, DWORD PTR _nHashNo$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0000b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000e	57		 push	 edi
  0000f	8b 74 86 08	 mov	 esi, DWORD PTR [esi+eax*4+8]
  00013	85 f6		 test	 esi, esi
  00015	74 1c		 je	 SHORT $LN3@setValue
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _pKey$[ebp]
  0001a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___mbscmp
$LL4@setValue:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00020	ff 36		 push	 DWORD PTR [esi]
  00022	57		 push	 edi
  00023	ff d3		 call	 ebx
  00025	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comhash.cpp

; 116  : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  00028	85 c0		 test	 eax, eax
  0002a	74 13		 je	 SHORT $LN10@setValue

; 112  : 	SThash_next *pNext;
; 113  : 
; 114  : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  0002c	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002f	85 f6		 test	 esi, esi
  00031	75 ed		 jne	 SHORT $LL4@setValue
$LN3@setValue:
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 120  : 		}
; 121  : 	}
; 122  : 	return eHASH_RESULT_NOT_FOUND;

  00035	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003a	5b		 pop	 ebx

; 123  : }

  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
$LN10@setValue:

; 117  : 		{
; 118  : 			pNext->pNode.value = pData;

  0003f	8b 45 10	 mov	 eax, DWORD PTR _pData$[ebp]
  00042	5f		 pop	 edi
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 119  : 			return eHASH_RESULT_SUCESS;

  00046	33 c0		 xor	 eax, eax
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx

; 123  : }

  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@IPADPAX@Z ENDP ; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@PADPAX@Z
_TEXT	SEGMENT
_pKey$ = 8						; size = 4
_pData$ = 12						; size = 4
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@PADPAX@Z PROC	; CHash::setValue, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	STHash_Node *pNode = hashLookup(pKey);

  00003	ff 75 08	 push	 DWORD PTR _pKey$[ebp]
  00006	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z ; CHash::hashLookup

; 103  : 	if (pNode) {

  0000b	85 c0		 test	 eax, eax
  0000d	74 0c		 je	 SHORT $LN2@setValue

; 104  : 		pNode->value = pData;

  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 105  : 		return eHASH_RESULT_SUCESS;

  00015	33 c0		 xor	 eax, eax

; 108  : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN2@setValue:

; 106  : 	}
; 107  : 	return eHASH_RESULT_NOT_FOUND;

  0001b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 108  : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?setValue@CHash@@QAE?AW4HASH_RETURN_CODE@@PADPAX@Z ENDP	; CHash::setValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getNode@CHash@@QAEPAUSThash_next@@PADPAPAU2@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pStr$ = 8						; size = 4
_prevNext$ = 12						; size = 4
?getNode@CHash@@QAEPAUSThash_next@@PADPAPAU2@@Z PROC	; CHash::getNode, COMDAT
; _this$ = ecx

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pStr$[ebp]
  00008	8b d3		 mov	 edx, ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 86   : {

  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  0000f	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL25@getNode:
  00012	8a 02		 mov	 al, BYTE PTR [edx]
  00014	42		 inc	 edx
  00015	84 c0		 test	 al, al
  00017	75 f9		 jne	 SHORT $LL25@getNode
  00019	2b d6		 sub	 edx, esi

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;
; 35   : 	for(i=0; i < nLen; i++) {

  0001b	be 00 00 00 00	 mov	 esi, 0
  00020	8b fa		 mov	 edi, edx
  00022	74 15		 je	 SHORT $LN9@getNode
$LL19@getNode:

; 36   : 		key += (key << 4) + (int)pStr[i];

  00024	0f be 0c 1e	 movsx	 ecx, BYTE PTR [esi+ebx]
  00028	8b c7		 mov	 eax, edi
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	46		 inc	 esi
  0002e	03 f8		 add	 edi, eax
  00030	03 f9		 add	 edi, ecx
  00032	3b f2		 cmp	 esi, edx
  00034	72 ee		 jb	 SHORT $LL19@getNode
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN9@getNode:

; 37   : 	}
; 38   : 	key = key % m_nMaxCount;

  00039	33 d2		 xor	 edx, edx

; 87   : 	SThash_next *pNext;
; 88   : 	HASH_TYPE nHashNo = getHashNo(pStr);
; 89   : 
; 90   : 	prevNext = &m_pHashData[nHashNo].pNext;
; 91   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  0003b	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 38   : 	key = key % m_nMaxCount;

  0003e	8b c7		 mov	 eax, edi
  00040	f7 31		 div	 DWORD PTR [ecx]

; 87   : 	SThash_next *pNext;
; 88   : 	HASH_TYPE nHashNo = getHashNo(pStr);
; 89   : 
; 90   : 	prevNext = &m_pHashData[nHashNo].pNext;
; 91   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00042	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00045	8b 74 86 08	 mov	 esi, DWORD PTR [esi+eax*4+8]
  00049	85 f6		 test	 esi, esi
  0004b	74 19		 je	 SHORT $LN3@getNode
  0004d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___mbscmp
$LL4@getNode:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00053	ff 36		 push	 DWORD PTR [esi]
  00055	53		 push	 ebx
  00056	ff d7		 call	 edi
  00058	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comhash.cpp

; 93   : 		if (_tcscmp(pStr, pNext->pNode.pKey) == 0) return pNext;

  0005b	85 c0		 test	 eax, eax
  0005d	74 12		 je	 SHORT $LN16@getNode

; 87   : 	SThash_next *pNext;
; 88   : 	HASH_TYPE nHashNo = getHashNo(pStr);
; 89   : 
; 90   : 	prevNext = &m_pHashData[nHashNo].pNext;
; 91   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  0005f	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00062	85 f6		 test	 esi, esi
  00064	75 ed		 jne	 SHORT $LL4@getNode
$LN3@getNode:
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi

; 94   : 		prevNext = &(pNext->next);
; 95   : 	}
; 96   : 
; 97   : 	return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	5b		 pop	 ebx

; 98   : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
$LN16@getNode:
  00071	5f		 pop	 edi

; 93   : 		if (_tcscmp(pStr, pNext->pNode.pKey) == 0) return pNext;

  00072	8b c6		 mov	 eax, esi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx

; 98   : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 08 00	 ret	 8
?getNode@CHash@@QAEPAUSThash_next@@PADPAPAU2@@Z ENDP	; CHash::getNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getNext@CHash@@QAEPAUSThash_next@@PAD@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pStr$ = 8						; size = 4
?getNext@CHash@@QAEPAUSThash_next@@PAD@Z PROC		; CHash::getNext, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pStr$[ebp]
  00008	8b d3		 mov	 edx, ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 80   : {

  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  0000f	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL14@getNext:
  00012	8a 02		 mov	 al, BYTE PTR [edx]
  00014	42		 inc	 edx
  00015	84 c0		 test	 al, al
  00017	75 f9		 jne	 SHORT $LL14@getNext
  00019	2b d6		 sub	 edx, esi

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;
; 35   : 	for(i=0; i < nLen; i++) {

  0001b	be 00 00 00 00	 mov	 esi, 0
  00020	8b fa		 mov	 edi, edx
  00022	74 12		 je	 SHORT $LN5@getNext
$LL10@getNext:

; 36   : 		key += (key << 4) + (int)pStr[i];

  00024	0f be 0c 1e	 movsx	 ecx, BYTE PTR [esi+ebx]
  00028	8b c7		 mov	 eax, edi
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	46		 inc	 esi
  0002e	03 f8		 add	 edi, eax
  00030	03 f9		 add	 edi, ecx
  00032	3b f2		 cmp	 esi, edx
  00034	72 ee		 jb	 SHORT $LL10@getNext
$LN5@getNext:

; 37   : 	}
; 38   : 	key = key % m_nMaxCount;

  00036	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  00039	8b c7		 mov	 eax, edi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	f7 36		 div	 DWORD PTR [esi]

; 81   : 	HASH_TYPE nHashNo = getHashNo(pStr);
; 82   : 	return m_pHashData[nHashNo].pNext;

  00040	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00048	8b 44 88 08	 mov	 eax, DWORD PTR [eax+ecx*4+8]

; 83   : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?getNext@CHash@@QAEPAUSThash_next@@PAD@Z ENDP		; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getNext@CHash@@QAEPAUSThash_next@@I@Z
_TEXT	SEGMENT
_nHashKey$ = 8						; size = 4
?getNext@CHash@@QAEPAUSThash_next@@I@Z PROC		; CHash::getNext, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	if (nHashKey >= m_nMaxCount) return NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nHashKey$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000a	72 06		 jb	 SHORT $LN2@getNext
  0000c	33 c0		 xor	 eax, eax

; 76   : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
$LN2@getNext:

; 74   : 
; 75   : 	return m_pHashData[nHashKey].pNext;

  00012	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00015	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00018	8b 44 88 08	 mov	 eax, DWORD PTR [eax+ecx*4+8]

; 76   : }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?getNext@CHash@@QAEPAUSThash_next@@I@Z ENDP		; CHash::getNext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?hashLookup@CHash@@QAEPAUSTHash_Node@@IPAD@Z
_TEXT	SEGMENT
_nHashNo$ = 8						; size = 4
_pKey$ = 12						; size = 4
?hashLookup@CHash@@QAEPAUSTHash_Node@@IPAD@Z PROC	; CHash::hashLookup, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	SThash_next *pNext;
; 61   : 	if(nHashNo >= m_nMaxCount) return NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nHashNo$[ebp]
  00006	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00008	72 06		 jb	 SHORT $LN5@hashLookup
  0000a	33 c0		 xor	 eax, eax

; 69   : 
; 70   : }

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
$LN5@hashLookup:
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 62   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00012	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00015	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00018	57		 push	 edi
  00019	8b 74 86 08	 mov	 esi, DWORD PTR [esi+eax*4+8]
  0001d	85 f6		 test	 esi, esi
  0001f	74 22		 je	 SHORT $LN3@hashLookup
  00021	8b 7d 0c	 mov	 edi, DWORD PTR _pKey$[ebp]
  00024	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___mbscmp
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL4@hashLookup:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00030	ff 36		 push	 DWORD PTR [esi]
  00032	57		 push	 edi
  00033	ff d3		 call	 ebx
  00035	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comhash.cpp

; 64   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  00038	85 c0		 test	 eax, eax
  0003a	74 10		 je	 SHORT $LN11@hashLookup

; 62   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  0003c	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0003f	85 f6		 test	 esi, esi
  00041	75 ed		 jne	 SHORT $LL4@hashLookup
$LN3@hashLookup:
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 66   : 	}
; 67   : 
; 68   : 	return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	5b		 pop	 ebx

; 69   : 
; 70   : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN11@hashLookup:
  0004c	5f		 pop	 edi

; 65   : 			return &pNext->pNode;

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 69   : 
; 70   : }

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?hashLookup@CHash@@QAEPAUSTHash_Node@@IPAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pKey$ = 8						; size = 4
?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z PROC	; CHash::hashLookup, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pKey$[ebp]
  00008	8b d3		 mov	 edx, ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 43   : {

  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  0000f	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL26@hashLookup:
  00012	8a 02		 mov	 al, BYTE PTR [edx]
  00014	42		 inc	 edx
  00015	84 c0		 test	 al, al
  00017	75 f9		 jne	 SHORT $LL26@hashLookup
  00019	2b d6		 sub	 edx, esi

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;
; 35   : 	for(i=0; i < nLen; i++) {

  0001b	be 00 00 00 00	 mov	 esi, 0
  00020	8b fa		 mov	 edi, edx
  00022	74 12		 je	 SHORT $LN10@hashLookup
$LL20@hashLookup:

; 36   : 		key += (key << 4) + (int)pStr[i];

  00024	0f be 0c 1e	 movsx	 ecx, BYTE PTR [esi+ebx]
  00028	8b c7		 mov	 eax, edi
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	46		 inc	 esi
  0002e	03 f8		 add	 edi, eax
  00030	03 f9		 add	 edi, ecx
  00032	3b f2		 cmp	 esi, edx
  00034	72 ee		 jb	 SHORT $LL20@hashLookup
$LN10@hashLookup:

; 37   : 	}
; 38   : 	key = key % m_nMaxCount;

  00036	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  00039	33 d2		 xor	 edx, edx
  0003b	8b c7		 mov	 eax, edi
  0003d	f7 36		 div	 DWORD PTR [esi]

; 44   : 	SThash_next *pNext;
; 45   : 	HASH_TYPE nHashNo = getHashNo(pKey);
; 46   : 	if(nHashNo >= m_nMaxCount) return NULL;

  0003f	3b 16		 cmp	 edx, DWORD PTR [esi]
  00041	73 27		 jae	 SHORT $LN3@hashLookup

; 47   : 
; 48   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00043	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00046	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00049	8b 74 88 08	 mov	 esi, DWORD PTR [eax+ecx*4+8]
  0004d	85 f6		 test	 esi, esi
  0004f	74 19		 je	 SHORT $LN3@hashLookup
  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___mbscmp
$LL4@hashLookup:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00057	ff 36		 push	 DWORD PTR [esi]
  00059	53		 push	 ebx
  0005a	ff d7		 call	 edi
  0005c	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comhash.cpp

; 50   : 		if (_tcscmp(pKey, pNext->pNode.pKey) == 0)

  0005f	85 c0		 test	 eax, eax
  00061	74 12		 je	 SHORT $LN17@hashLookup

; 47   : 
; 48   : 	for (pNext = m_pHashData[nHashNo].pNext; pNext != NULL; pNext = pNext->next)

  00063	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00066	85 f6		 test	 esi, esi
  00068	75 ed		 jne	 SHORT $LL4@hashLookup
$LN3@hashLookup:
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 52   : 	}
; 53   : 
; 54   : 	return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	5b		 pop	 ebx

; 55   : 
; 56   : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
$LN17@hashLookup:
  00075	5f		 pop	 edi

; 51   : 			return &pNext->pNode;

  00076	8b c6		 mov	 eax, esi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx

; 55   : 
; 56   : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
?hashLookup@CHash@@QAEPAUSTHash_Node@@PAD@Z ENDP	; CHash::hashLookup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?getHashNo@CHash@@QAEIPAD@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pStr$ = 8						; size = 4
?getHashNo@CHash@@QAEIPAD@Z PROC			; CHash::getHashNo, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 32   : 	HASH_TYPE nLen = (HASH_TYPE)_tcslen(pStr);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pStr$[ebp]
  00008	8b d3		 mov	 edx, ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL12@getHashNo:
  00012	8a 02		 mov	 al, BYTE PTR [edx]
  00014	42		 inc	 edx
  00015	84 c0		 test	 al, al
  00017	75 f9		 jne	 SHORT $LL12@getHashNo
  00019	2b d6		 sub	 edx, esi

; 33   : 	HASH_TYPE i;
; 34   : 	HASH_TYPE key = nLen;
; 35   : 	for(i=0; i < nLen; i++) {

  0001b	be 00 00 00 00	 mov	 esi, 0
  00020	8b fa		 mov	 edi, edx
  00022	74 12		 je	 SHORT $LN3@getHashNo
$LL8@getHashNo:

; 36   : 		key += (key << 4) + (int)pStr[i];

  00024	0f be 0c 1e	 movsx	 ecx, BYTE PTR [esi+ebx]
  00028	8b c7		 mov	 eax, edi
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	46		 inc	 esi
  0002e	03 f8		 add	 edi, eax
  00030	03 f9		 add	 edi, ecx
  00032	3b f2		 cmp	 esi, edx
  00034	72 ee		 jb	 SHORT $LL8@getHashNo
$LN3@getHashNo:

; 37   : 	}
; 38   : 	key = key % m_nMaxCount;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00039	8b c7		 mov	 eax, edi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	f7 31		 div	 DWORD PTR [ecx]
  00041	5b		 pop	 ebx

; 39   : 	return key;

  00042	8b c2		 mov	 eax, edx

; 40   : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?getHashNo@CHash@@QAEIPAD@Z ENDP			; CHash::getHashNo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ?clear@CHash@@QAEXXZ
_TEXT	SEGMENT
?clear@CHash@@QAEXXZ PROC				; CHash::clear, COMDAT
; _this$ = ecx

; 27   : 	memset(m_pHashData, 0, sizeof(m_pHashData));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 28   : }

  00009	c3		 ret	 0
?clear@CHash@@QAEXXZ ENDP				; CHash::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ??1CHash@@QAE@XZ
_TEXT	SEGMENT
??1CHash@@QAE@XZ PROC					; CHash::~CHash, COMDAT
; _this$ = ecx

; 18   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 19   : 	if(m_pHashData) {

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	85 c0		 test	 eax, eax
  00008	74 11		 je	 SHORT $LN2@CHash

; 20   : 		free(m_pHashData);

  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00011	83 c4 04	 add	 esp, 4

; 21   : 		m_pHashData = NULL;

  00014	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@CHash:
  0001b	5e		 pop	 esi

; 22   : 	}
; 23   : }

  0001c	c3		 ret	 0
??1CHash@@QAE@XZ ENDP					; CHash::~CHash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comhash.cpp
;	COMDAT ??0CHash@@QAE@I@Z
_TEXT	SEGMENT
_max$ = 8						; size = 4
??0CHash@@QAE@I@Z PROC					; CHash::CHash, COMDAT
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11   : 	// TODO m_nMaxCount 를 2의 제곱으로 조정한다.
; 12   : 	m_nMaxCount = max;

  00003	8b 45 08	 mov	 eax, DWORD PTR _max$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 13   : 	m_nElementCount = 0;
; 14   : 	m_pHashData = (SThash_value *)calloc(m_nMaxCount, sizeof(SThash_value));

  00009	6a 0c		 push	 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	89 06		 mov	 DWORD PTR [esi], eax
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0001b	83 c4 08	 add	 esp, 8
  0001e	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 15   : }

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??0CHash@@QAE@I@Z ENDP					; CHash::CHash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcscmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcscmp PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbscmp
__tcscmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsncpy PROC						; COMDAT

; 1542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1546 : #pragma warning(pop)
; 1547 : }

  00003	5d		 pop	 ebp

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbsnbcpy
__tcsncpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00006	8d 4d 10	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000f	6a ff		 push	 -1
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
