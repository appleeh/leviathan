; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comBufPool.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_nSizeList@@3QBHB				; g_nSizeList
CONST	SEGMENT
?g_nSizeList@@3QBHB DD 01H				; g_nSizeList
	DD	02H
	DD	04H
	DD	08H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	02000H
	DD	03fdcH
	DD	08000H
	DD	010000H
	DD	020000H
	DD	040000H
	DD	080000H
	DD	0100000H
	DD	0200000H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	??0win_atomic@win32@common@@QAE@XZ		; common::win32::win_atomic::win_atomic
PUBLIC	??1win_atomic@win32@common@@QAE@XZ		; common::win32::win_atomic::~win_atomic
PUBLIC	??_Ewin_atomic@win32@common@@QAEPAXI@Z		; common::win32::win_atomic::`vector deleting destructor'
PUBLIC	??0CBufPool@@QAE@XZ				; CBufPool::CBufPool
PUBLIC	??1CBufPool@@QAE@XZ				; CBufPool::~CBufPool
PUBLIC	?clear@CBufPool@@QAEXXZ				; CBufPool::clear
PUBLIC	?alloc@CBufPool@@QAE_NHH@Z			; CBufPool::alloc
PUBLIC	?newMem@CBufPool@@QAEPADXZ			; CBufPool::newMem
PUBLIC	?delMem@CBufPool@@QAEXPAD@Z			; CBufPool::delMem
PUBLIC	?newMemList@CBufPool@@QAE_NH@Z			; CBufPool::newMemList
PUBLIC	?delMem@CBufPool@@QAEXPADH@Z			; CBufPool::delMem
PUBLIC	??0CSBufPool@@QAE@XZ				; CSBufPool::CSBufPool
PUBLIC	??1CSBufPool@@QAE@XZ				; CSBufPool::~CSBufPool
PUBLIC	?clear@CSBufPool@@QAEXXZ			; CSBufPool::clear
PUBLIC	?alloc@CSBufPool@@QAE_NHH@Z			; CSBufPool::alloc
PUBLIC	?destroy@CSBufPool@@QAEXXZ			; CSBufPool::destroy
PUBLIC	?newMem@CSBufPool@@QAEPADPAH@Z			; CSBufPool::newMem
PUBLIC	?delMem@CSBufPool@@QAE_NPAD@Z			; CSBufPool::delMem
PUBLIC	?delMemByIdx@CSBufPool@@QAE_NPADH@Z		; CSBufPool::delMemByIdx
PUBLIC	?newMemList@CSBufPool@@QAE_NH@Z			; CSBufPool::newMemList
PUBLIC	?delMem@CSBufPool@@QAE_NPADH@Z			; CSBufPool::delMem
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BB@FIAJCIIG@new?5m_nFlagArray?$AA@	; `string'
PUBLIC	??_C@_0BA@CIGGPOIC@CBufPool?3?3alloc?$AA@	; `string'
PUBLIC	??_C@_0P@NFKBPBIP@m_pChunk?5alloc?$AA@		; `string'
PUBLIC	??_C@_0BD@BKPJADOC@m_nFlagArray?5alloc?$AA@	; `string'
PUBLIC	??_C@_0BB@OFMJEEIE@CSBufPool?3?3alloc?$AA@	; `string'
PUBLIC	??_C@_0CC@EPBODHGM@mem?5allock?5list?5m_nAllocCount?$FL?$CFd@ ; `string'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	??_U@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??_V@YAXPAXABUnothrow_t@std@@@Z:PROC		; operator delete[]
EXTRN	__imp__InterlockedIncrement@4:PROC
EXTRN	__imp__InterlockedDecrement@4:PROC
EXTRN	__imp__InterlockedCompareExchange@12:PROC
EXTRN	?__debugLog@CLogger@@QAAXHPBDH0ZZ:PROC		; CLogger::__debugLog
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0CC@EPBODHGM@mem?5allock?5list?5m_nAllocCount?$FL?$CFd@
CONST	SEGMENT
??_C@_0CC@EPBODHGM@mem?5allock?5list?5m_nAllocCount?$FL?$CFd@ DB 'mem all'
	DB	'ock list m_nAllocCount[%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFMJEEIE@CSBufPool?3?3alloc?$AA@
CONST	SEGMENT
??_C@_0BB@OFMJEEIE@CSBufPool?3?3alloc?$AA@ DB 'CSBufPool::alloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BKPJADOC@m_nFlagArray?5alloc?$AA@
CONST	SEGMENT
??_C@_0BD@BKPJADOC@m_nFlagArray?5alloc?$AA@ DB 'm_nFlagArray alloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NFKBPBIP@m_pChunk?5alloc?$AA@
CONST	SEGMENT
??_C@_0P@NFKBPBIP@m_pChunk?5alloc?$AA@ DB 'm_pChunk alloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CIGGPOIC@CBufPool?3?3alloc?$AA@
CONST	SEGMENT
??_C@_0BA@CIGGPOIC@CBufPool?3?3alloc?$AA@ DB 'CBufPool::alloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FIAJCIIG@new?5m_nFlagArray?$AA@
CONST	SEGMENT
??_C@_0BB@FIAJCIIG@new?5m_nFlagArray?$AA@ DB 'new m_nFlagArray', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?alloc@CBufPool@@QAE_NHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?alloc@CBufPool@@QAE_NHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?alloc@CBufPool@@QAE_NHH@Z$1
__ehfuncinfo$?alloc@CBufPool@@QAE_NHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?alloc@CBufPool@@QAE_NHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CBufPool@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CBufPool@@QAE@XZ$0
__ehfuncinfo$??1CBufPool@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CBufPool@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ewin_atomic@win32@common@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?ISINCLUDE_ADDRESS@CSBufPool@@QAE_NPAD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ISINCLUDE_ADDRESS@CSBufPool@@QAE_NPAD@Z PROC		; CSBufPool::ISINCLUDE_ADDRESS, COMDAT
; _this$ = ecx

; 131  : 	inline bool ISINCLUDE_ADDRESS(char *p) { if (m_pChunk <= p && p <= m_pEnd) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	77 0b		 ja	 SHORT $LN2@ISINCLUDE_
  0000b	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0000e	77 06		 ja	 SHORT $LN2@ISINCLUDE_
  00010	b0 01		 mov	 al, 1
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@ISINCLUDE_:
  00016	32 c0		 xor	 al, al
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?ISINCLUDE_ADDRESS@CSBufPool@@QAE_NPAD@Z ENDP		; CSBufPool::ISINCLUDE_ADDRESS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CSBufPool@@QAE_NPADH@Z
_TEXT	SEGMENT
_pUsedMem$ = 8						; size = 4
_nCount$ = 12						; size = 4
?delMem@CSBufPool@@QAE_NPADH@Z PROC			; CSBufPool::delMem, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 366  : 	int nPos = (int)(pUsedMem - m_pChunk);

  00003	8b 55 08	 mov	 edx, DWORD PTR _pUsedMem$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  0000e	2b d6		 sub	 edx, esi

; 367  : 	int nIdx = nPos >> m_nShift;

  00010	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00013	8b c2		 mov	 eax, edx
  00015	d3 f8		 sar	 eax, cl

; 368  : 	int i;
; 369  : 
; 370  : 	if (pUsedMem != &m_pChunk[nPos]) return false;

  00017	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  0001a	39 4d 08	 cmp	 DWORD PTR _pUsedMem$[ebp], ecx
  0001d	74 09		 je	 SHORT $LN5@delMem
$LN14@delMem:
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	32 c0		 xor	 al, al
  00023	5b		 pop	 ebx

; 383  : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
$LN5@delMem:

; 371  : 	for (i = 0; i < nCount; i++)

  00028	33 f6		 xor	 esi, esi
  0002a	39 75 0c	 cmp	 DWORD PTR _nCount$[ebp], esi
  0002d	7e 2c		 jle	 SHORT $LN3@delMem
  0002f	90		 npad	 1
$LL4@delMem:

; 372  : 	{
; 373  : 		if (nIdx >= m_nAllocCount) return false;

  00030	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  00033	7d ea		 jge	 SHORT $LN14@delMem
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00035	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  00038	8b d0		 mov	 edx, eax
  0003a	c1 fa 03	 sar	 edx, 3
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 375  : 		if (isBitSet_flag(nIdx, m_nFlagArray))

  0003d	0f be 0c 17	 movsx	 ecx, BYTE PTR [edi+edx]
  00041	83 e1 07	 and	 ecx, 7
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00044	84 c8		 test	 cl, al
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 375  : 		if (isBitSet_flag(nIdx, m_nFlagArray))

  00046	74 0c		 je	 SHORT $LN7@delMem
; File e:\infinia-library-3.0\com\include\comtypes.h

; 315  : inline void bitClear_flag(int n, char *p) {  p[n >> 3] &= ~(n & 7); }

  00048	8a c8		 mov	 cl, al
  0004a	80 e1 07	 and	 cl, 7
  0004d	f6 d1		 not	 cl
  0004f	20 0c 3a	 and	 BYTE PTR [edx+edi], cl
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 378  : 			m_nUseCnt--;

  00052	ff 0b		 dec	 DWORD PTR [ebx]
$LN7@delMem:

; 379  : 		}
; 380  : 		nIdx++;

  00054	46		 inc	 esi
  00055	40		 inc	 eax
  00056	3b 75 0c	 cmp	 esi, DWORD PTR _nCount$[ebp]
  00059	7c d5		 jl	 SHORT $LL4@delMem
$LN3@delMem:
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 381  : 	}
; 382  : 	return true;

  0005d	b0 01		 mov	 al, 1
  0005f	5b		 pop	 ebx

; 383  : }

  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?delMem@CSBufPool@@QAE_NPADH@Z ENDP			; CSBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMemList@CSBufPool@@QAE_NH@Z
_TEXT	SEGMENT
_idx$2$ = -8						; size = 4
_this$1$ = -4						; size = 4
_nCount$ = 8						; size = 4
?newMemList@CSBufPool@@QAE_NH@Z PROC			; CSBufPool::newMemList, COMDAT
; _this$ = ecx

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 334  : 	int i;
; 335  : 	int idx = m_nUseCnt, nLastLoopCnt=0;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	8b d8		 mov	 ebx, eax
  00011	89 45 f8	 mov	 DWORD PTR _idx$2$[ebp], eax

; 336  : 
; 337  : 	if (m_nUseCnt == m_nAllocCount) return false;

  00014	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00017	75 0a		 jne	 SHORT $LN8@newMemList
  00019	5e		 pop	 esi
  0001a	32 c0		 xor	 al, al
  0001c	5b		 pop	 ebx

; 361  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN8@newMemList:

; 338  : 
; 339  : 	for (i = 0; i < nCount; i++) {

  00023	8b 55 08	 mov	 edx, DWORD PTR _nCount$[ebp]
  00026	57		 push	 edi
  00027	33 ff		 xor	 edi, edi
  00029	85 d2		 test	 edx, edx
  0002b	7e 2b		 jle	 SHORT $LN23@newMemList
  0002d	8b c1		 mov	 eax, ecx
  0002f	90		 npad	 1
$LL4@newMemList:

; 340  : 		if (idx >= m_nAllocCount) break;

  00030	3b 58 04	 cmp	 ebx, DWORD PTR [eax+4]
  00033	7d 1d		 jge	 SHORT $LN30@newMemList

; 341  : 		if (!isBitSet_flag(idx, m_nFlagArray))

  00035	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00038	8b d3		 mov	 edx, ebx
  0003a	c1 fa 03	 sar	 edx, 3
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 341  : 		if (!isBitSet_flag(idx, m_nFlagArray))

  0003d	0f be 0c 0a	 movsx	 ecx, BYTE PTR [edx+ecx]
  00041	8b 55 08	 mov	 edx, DWORD PTR _nCount$[ebp]
  00044	83 e1 07	 and	 ecx, 7
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00047	84 cb		 test	 cl, bl
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 341  : 		if (!isBitSet_flag(idx, m_nFlagArray))

  00049	75 07		 jne	 SHORT $LN30@newMemList

; 342  : 		{
; 343  : 			nLastLoopCnt++;

  0004b	47		 inc	 edi
  0004c	46		 inc	 esi

; 344  : 		}
; 345  : 		else break;
; 346  : 		idx++;

  0004d	43		 inc	 ebx
  0004e	3b fa		 cmp	 edi, edx
  00050	7c de		 jl	 SHORT $LL4@newMemList
$LN30@newMemList:
  00052	8b 45 f8	 mov	 eax, DWORD PTR _idx$2$[ebp]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN23@newMemList:

; 347  : 	}
; 348  : 
; 349  : 	if (nLastLoopCnt == nCount) {

  00058	3b f2		 cmp	 esi, edx
  0005a	75 0f		 jne	 SHORT $LN12@newMemList

; 350  : 		m_nUseCnt += nCount;

  0005c	5f		 pop	 edi
  0005d	03 c2		 add	 eax, edx
  0005f	5e		 pop	 esi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 351  : 		return true;

  00062	b0 01		 mov	 al, 1
  00064	5b		 pop	 ebx

; 361  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
$LN12@newMemList:

; 354  : 	for (idx = m_nUseCnt; idx < nLastLoopCnt; idx++) {

  0006b	3b c6		 cmp	 eax, esi
  0006d	7d 26		 jge	 SHORT $LN6@newMemList
  0006f	90		 npad	 1
$LL7@newMemList:
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00070	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  00073	8b d0		 mov	 edx, eax
  00075	c1 fa 03	 sar	 edx, 3
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 355  : 		if (isBitSet_flag(idx, m_nFlagArray))

  00078	0f be 0c 17	 movsx	 ecx, BYTE PTR [edi+edx]
  0007c	83 e1 07	 and	 ecx, 7
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  0007f	84 c8		 test	 cl, al
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 355  : 		if (isBitSet_flag(idx, m_nFlagArray))

  00081	74 0a		 je	 SHORT $LN5@newMemList
; File e:\infinia-library-3.0\com\include\comtypes.h

; 315  : inline void bitClear_flag(int n, char *p) {  p[n >> 3] &= ~(n & 7); }

  00083	8a c8		 mov	 cl, al
  00085	80 e1 07	 and	 cl, 7
  00088	f6 d1		 not	 cl
  0008a	20 0c 3a	 and	 BYTE PTR [edx+edi], cl
$LN5@newMemList:
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 354  : 	for (idx = m_nUseCnt; idx < nLastLoopCnt; idx++) {

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00090	40		 inc	 eax
  00091	3b c6		 cmp	 eax, esi
  00093	7c db		 jl	 SHORT $LL7@newMemList
$LN6@newMemList:
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi

; 356  : 		{
; 357  : 			bitClear_flag(idx, m_nFlagArray);
; 358  : 		}
; 359  : 	}
; 360  : 	return false;

  00097	32 c0		 xor	 al, al
  00099	5b		 pop	 ebx

; 361  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
?newMemList@CSBufPool@@QAE_NH@Z ENDP			; CSBufPool::newMemList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMemByIdx@CSBufPool@@QAE_NPADH@Z
_TEXT	SEGMENT
_pUsedMem$ = 8						; size = 4
_nIdx$ = 12						; size = 4
?delMemByIdx@CSBufPool@@QAE_NPADH@Z PROC		; CSBufPool::delMemByIdx, COMDAT
; _this$ = ecx

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File e:\infinia-library-3.0\com\include\comtypes.h

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00003	8b 55 0c	 mov	 edx, DWORD PTR _nIdx$[ebp]
  00006	56		 push	 esi
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 316  : {

  00007	8b f1		 mov	 esi, ecx
; File e:\infinia-library-3.0\com\include\comtypes.h

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00009	85 d2		 test	 edx, edx
  0000b	78 2d		 js	 SHORT $LN6@delMemById
  0000d	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  00010	7d 28		 jge	 SHORT $LN6@delMemById
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 322  : 	if (pUsedMem == &m_pChunk[nIdx << m_nShift]) {

  00012	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00015	8b c2		 mov	 eax, edx
  00017	d3 e0		 shl	 eax, cl
  00019	03 46 10	 add	 eax, DWORD PTR [esi+16]
  0001c	39 45 08	 cmp	 DWORD PTR _pUsedMem$[ebp], eax
  0001f	75 25		 jne	 SHORT $LN3@delMemById

; 323  : 		bitClear_flag(nIdx, m_nFlagArray);

  00021	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
; File e:\infinia-library-3.0\com\include\comtypes.h

; 315  : inline void bitClear_flag(int n, char *p) {  p[n >> 3] &= ~(n & 7); }

  00024	8b c2		 mov	 eax, edx
  00026	c1 f8 03	 sar	 eax, 3
  00029	80 e2 07	 and	 dl, 7
  0002c	f6 d2		 not	 dl
  0002e	20 14 08	 and	 BYTE PTR [eax+ecx], dl
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 325  : 		return true;

  00031	b0 01		 mov	 al, 1
  00033	ff 0e		 dec	 DWORD PTR [esi]
  00035	5e		 pop	 esi

; 326  : 	}
; 327  : 	return false;
; 328  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN6@delMemById:

; 317  : 	if (!ISINCLUDE(nIdx, m_nAllocCount)) {
; 318  : 		free(pUsedMem);

  0003a	ff 75 08	 push	 DWORD PTR _pUsedMem$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00043	83 c4 04	 add	 esp, 4
$LN3@delMemById:

; 319  : 		return false;

  00046	32 c0		 xor	 al, al
  00048	5e		 pop	 esi

; 326  : 	}
; 327  : 	return false;
; 328  : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?delMemByIdx@CSBufPool@@QAE_NPADH@Z ENDP		; CSBufPool::delMemByIdx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CSBufPool@@QAE_NPAD@Z
_TEXT	SEGMENT
_pUsedMem$ = 8						; size = 4
?delMem@CSBufPool@@QAE_NPAD@Z PROC			; CSBufPool::delMem, COMDAT
; _this$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File e:\infinia-library-3.0\com\include\combufpool.h

; 131  : 	inline bool ISINCLUDE_ADDRESS(char *p) { if (m_pChunk <= p && p <= m_pEnd) return true; return false; }

  00003	8b 55 08	 mov	 edx, DWORD PTR _pUsedMem$[ebp]
  00006	56		 push	 esi
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 299  : {

  00007	8b f1		 mov	 esi, ecx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 131  : 	inline bool ISINCLUDE_ADDRESS(char *p) { if (m_pChunk <= p && p <= m_pEnd) return true; return false; }

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	3b c2		 cmp	 eax, edx
  0000e	77 37		 ja	 SHORT $LN6@delMem
  00010	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  00013	77 32		 ja	 SHORT $LN6@delMem
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 304  : 	int nPos = (int)(pUsedMem - m_pChunk);

  00015	53		 push	 ebx
  00016	8b da		 mov	 ebx, edx
  00018	2b d8		 sub	 ebx, eax

; 305  : 
; 306  : 	if (pUsedMem == &m_pChunk[nPos]) {

  0001a	03 c3		 add	 eax, ebx
  0001c	3b d0		 cmp	 edx, eax
  0001e	75 1f		 jne	 SHORT $LN3@delMem

; 307  : 		bitClear_flag(nPos >> m_nShift, m_nFlagArray);

  00020	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00023	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00026	d3 fb		 sar	 ebx, cl
; File e:\infinia-library-3.0\com\include\comtypes.h

; 315  : inline void bitClear_flag(int n, char *p) {  p[n >> 3] &= ~(n & 7); }

  00028	8b c3		 mov	 eax, ebx
  0002a	80 e3 07	 and	 bl, 7
  0002d	c1 f8 03	 sar	 eax, 3
  00030	f6 d3		 not	 bl
  00032	20 1c 10	 and	 BYTE PTR [eax+edx], bl
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 309  : 		return true;

  00035	b0 01		 mov	 al, 1
  00037	ff 0e		 dec	 DWORD PTR [esi]
  00039	5b		 pop	 ebx
  0003a	5e		 pop	 esi

; 312  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
$LN3@delMem:
  0003f	5b		 pop	 ebx

; 310  : 	}
; 311  : 	return false;

  00040	32 c0		 xor	 al, al
  00042	5e		 pop	 esi

; 312  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN6@delMem:

; 300  : 	if (!ISINCLUDE_ADDRESS(pUsedMem)) {
; 301  : 		free(pUsedMem);

  00047	52		 push	 edx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0004e	83 c4 04	 add	 esp, 4

; 302  : 		return false;

  00051	32 c0		 xor	 al, al
  00053	5e		 pop	 esi

; 312  : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?delMem@CSBufPool@@QAE_NPAD@Z ENDP			; CSBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMem@CSBufPool@@QAEPADPAH@Z
_TEXT	SEGMENT
_pKey$ = 8						; size = 4
?newMem@CSBufPool@@QAEPADPAH@Z PROC			; CSBufPool::newMem, COMDAT
; _this$ = ecx

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 272  : 	int i = m_nUseCnt, j;

  00008	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 273  : 
; 274  : 	if (m_nUseCnt == m_nAllocCount) goto NEW_ALLOC;

  0000a	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000d	3b de		 cmp	 ebx, esi
  0000f	74 2b		 je	 SHORT $NEW_ALLOC$22

; 275  : 
; 276  : 	for (j = 0; j < m_nAllocCount; j++) {

  00011	33 d2		 xor	 edx, edx
  00013	85 f6		 test	 esi, esi
  00015	7e 25		 jle	 SHORT $NEW_ALLOC$22
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00017	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@newMem:
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 277  : 		if (i >= m_nAllocCount) { i = 0; }

  00020	33 c0		 xor	 eax, eax
  00022	3b de		 cmp	 ebx, esi
  00024	0f 4d d8	 cmovge	 ebx, eax
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00027	8b c3		 mov	 eax, ebx
  00029	c1 f8 03	 sar	 eax, 3
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 278  : 		if (!isBitSet_flag(i, m_nFlagArray)) {

  0002c	0f be 04 08	 movsx	 eax, BYTE PTR [eax+ecx]
  00030	83 e0 07	 and	 eax, 7
; File e:\infinia-library-3.0\com\include\comtypes.h

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00033	84 c3		 test	 al, bl
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 278  : 		if (!isBitSet_flag(i, m_nFlagArray)) {

  00035	74 2e		 je	 SHORT $LN17@newMem

; 275  : 
; 276  : 	for (j = 0; j < m_nAllocCount; j++) {

  00037	42		 inc	 edx
  00038	3b d6		 cmp	 edx, esi
  0003a	7c e4		 jl	 SHORT $LL4@newMem
$NEW_ALLOC$22:

; 286  : 		}
; 287  : 	}
; 288  : 
; 289  : NEW_ALLOC:
; 290  : 	if (pKey) {

  0003c	8b 45 08	 mov	 eax, DWORD PTR _pKey$[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	74 06		 je	 SHORT $LN10@newMem

; 291  : 		*pKey = -1;

  00043	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
$LN10@newMem:

; 292  : 	}
; 293  : 	return (char *)calloc(1, g_nSizeList[m_nShift]);

  00049	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0004c	ff 34 85 00 00
	00 00		 push	 DWORD PTR ?g_nSizeList@@3QBHB[eax*4]
  00053	6a 01		 push	 1
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0005b	83 c4 08	 add	 esp, 8
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 294  : }

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
$LN17@newMem:

; 279  : 			if (pKey) {

  00065	8b 45 08	 mov	 eax, DWORD PTR _pKey$[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 02		 je	 SHORT $LN9@newMem

; 280  : 				*pKey = i;

  0006c	89 18		 mov	 DWORD PTR [eax], ebx
$LN9@newMem:

; 283  : 			bitSet_flag(i, m_nFlagArray);

  0006e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
; File e:\infinia-library-3.0\com\include\comtypes.h

; 316  : inline void bitSet_flag(int n, char *p) {  p[n >> 3] |= (n & 7); }

  00071	8b c3		 mov	 eax, ebx
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 282  : 			m_nUseCnt++;

  00073	ff 07		 inc	 DWORD PTR [edi]
; File e:\infinia-library-3.0\com\include\comtypes.h

; 316  : inline void bitSet_flag(int n, char *p) {  p[n >> 3] |= (n & 7); }

  00075	c1 f8 03	 sar	 eax, 3
  00078	03 c8		 add	 ecx, eax
  0007a	8a c3		 mov	 al, bl
  0007c	24 07		 and	 al, 7
  0007e	08 01		 or	 BYTE PTR [ecx], al
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 284  : 			memset(&m_pChunk[i<<m_nShift], 0, g_nSizeList[m_nShift]);

  00080	8b c3		 mov	 eax, ebx
  00082	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00085	d3 e0		 shl	 eax, cl
  00087	03 47 10	 add	 eax, DWORD PTR [edi+16]
  0008a	ff 34 8d 00 00
	00 00		 push	 DWORD PTR ?g_nSizeList@@3QBHB[ecx*4]
  00091	6a 00		 push	 0
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _memset

; 285  : 			return &m_pChunk[i << m_nShift];

  00099	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	d3 e3		 shl	 ebx, cl
  000a1	03 5f 10	 add	 ebx, DWORD PTR [edi+16]
  000a4	8b c3		 mov	 eax, ebx
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx

; 294  : }

  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
?newMem@CSBufPool@@QAEPADPAH@Z ENDP			; CSBufPool::newMem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?destroy@CSBufPool@@QAEXXZ
_TEXT	SEGMENT
?destroy@CSBufPool@@QAEXXZ PROC				; CSBufPool::destroy, COMDAT
; _this$ = ecx

; 217  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 218  : 	if (m_pChunk) {

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	85 c0		 test	 eax, eax
  00008	74 11		 je	 SHORT $LN2@destroy

; 219  : 		free(m_pChunk);

  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00011	83 c4 04	 add	 esp, 4

; 220  : 		m_pChunk = NULL;

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN2@destroy:

; 221  : 	}
; 222  : 
; 223  : 	if (m_nFlagArray) {

  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	85 c0		 test	 eax, eax
  00020	74 11		 je	 SHORT $LN3@destroy

; 224  : 		free(m_nFlagArray);

  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00029	83 c4 04	 add	 esp, 4

; 225  : 		m_nFlagArray = NULL;

  0002c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@destroy:
  00033	5e		 pop	 esi

; 226  : 	}
; 227  : }

  00034	c3		 ret	 0
?destroy@CSBufPool@@QAEXXZ ENDP				; CSBufPool::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?alloc@CSBufPool@@QAE_NHH@Z
_TEXT	SEGMENT
_nShift$ = 8						; size = 4
_nMaxCount$ = 12					; size = 4
?alloc@CSBufPool@@QAE_NHH@Z PROC			; CSBufPool::alloc, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 233  : 	int nFCount = (nMaxCount >> 3) + 1;

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _nMaxCount$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b c7		 mov	 eax, edi
  0000c	c1 f8 03	 sar	 eax, 3
  0000f	40		 inc	 eax

; 234  : 	m_nFlagArray = (char *)calloc(nFCount, sizeof(char));

  00010	6a 01		 push	 1
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00019	83 c4 08	 add	 esp, 8
  0001c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 235  : 
; 236  : 	if (m_nFlagArray == NULL) {

  0001f	85 c0		 test	 eax, eax
  00021	75 26		 jne	 SHORT $LN2@alloc

; 237  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_nFlagArray alloc");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BKPJADOC@m_nFlagArray?5alloc?$AA@
  00028	68 ed 00 00 00	 push	 237			; 000000edH
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OFMJEEIE@CSBufPool?3?3alloc?$AA@
  00032	6a 05		 push	 5
  00034	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00039	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0003e	83 c4 14	 add	 esp, 20			; 00000014H

; 238  : 		return false;

  00041	32 c0		 xor	 al, al
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 255  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN2@alloc:

; 239  : 	} 
; 240  : 	m_nShift = nShift;

  00049	8b 45 08	 mov	 eax, DWORD PTR _nShift$[ebp]
  0004c	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 241  : 	m_pChunk = (char *)calloc(nMaxCount, getSizeByIndex(m_nShift));

  0004f	ff 34 85 00 00
	00 00		 push	 DWORD PTR ?g_nSizeList@@3QBHB[eax*4]
  00056	57		 push	 edi
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0005d	8b d0		 mov	 edx, eax
  0005f	83 c4 08	 add	 esp, 8
  00062	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 242  : 
; 243  : 	if (m_pChunk == NULL) {

  00065	85 d2		 test	 edx, edx
  00067	75 34		 jne	 SHORT $LN3@alloc

; 244  : 		free(m_pChunk);

  00069	50		 push	 eax
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 245  : 		m_pChunk = NULL;
; 246  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_pChunk alloc");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NFKBPBIP@m_pChunk?5alloc?$AA@
  00075	68 f6 00 00 00	 push	 246			; 000000f6H
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OFMJEEIE@CSBufPool?3?3alloc?$AA@
  0007f	6a 05		 push	 5
  00081	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0008d	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00092	83 c4 18	 add	 esp, 24			; 00000018H

; 247  : 		return false;

  00095	32 c0		 xor	 al, al
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi

; 255  : }

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN3@alloc:

; 248  : 	}
; 249  : 
; 250  : 	m_nAllocCount = nMaxCount;
; 251  : 	m_pEnd = &m_pChunk[(m_nAllocCount - 1)<< m_nShift];

  0009d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000a0	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]

; 252  : 	_stprintf(g_szMessage, _T("mem allock list m_nAllocCount[%d]"), m_nAllocCount);

  000a3	57		 push	 edi
  000a4	d3 e0		 shl	 eax, cl
  000a6	03 c2		 add	 eax, edx
  000a8	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@EPBODHGM@mem?5allock?5list?5m_nAllocCount?$FL?$CFd@
  000b0	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  000b5	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000b8	e8 00 00 00 00	 call	 _sprintf
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 253  : 
; 254  : 	return true;

  000c0	b0 01		 mov	 al, 1
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi

; 255  : }

  000c4	5d		 pop	 ebp
  000c5	c2 08 00	 ret	 8
?alloc@CSBufPool@@QAE_NHH@Z ENDP			; CSBufPool::alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?clear@CSBufPool@@QAEXXZ
_TEXT	SEGMENT
?clear@CSBufPool@@QAEXXZ PROC				; CSBufPool::clear, COMDAT
; _this$ = ecx

; 261  : 	memset(m_nFlagArray, 0, sizeof(m_nFlagArray));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File e:\infinia-library-3.0\com\include\combufpool.h

; 52   : inline int getSizeByIndex(int nIdx) { return g_nSizeList[nIdx]; }

  00009	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 262  : 	m_nUseCnt = 0;

  0000c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 263  : 	memset(m_pChunk, 0, getSizeByIndex(m_nShift)*m_nAllocCount);

  00012	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?g_nSizeList@@3QBHB[eax*4]
  00019	0f af 41 04	 imul	 eax, DWORD PTR [ecx+4]
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 71 10	 push	 DWORD PTR [ecx+16]
  00023	e8 00 00 00 00	 call	 _memset

; 264  : 	memset(g_szMessage, 0, sizeof(g_szMessage));

  00028	68 80 00 00 00	 push	 128			; 00000080H
  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00034	e8 00 00 00 00	 call	 _memset
  00039	83 c4 18	 add	 esp, 24			; 00000018H

; 265  : }

  0003c	c3		 ret	 0
?clear@CSBufPool@@QAEXXZ ENDP				; CSBufPool::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??1CSBufPool@@QAE@XZ
_TEXT	SEGMENT
??1CSBufPool@@QAE@XZ PROC				; CSBufPool::~CSBufPool, COMDAT
; _this$ = ecx

; 211  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 218  : 	if (m_pChunk) {

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	85 c0		 test	 eax, eax
  00008	74 11		 je	 SHORT $LN4@CSBufPool

; 219  : 		free(m_pChunk);

  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00011	83 c4 04	 add	 esp, 4

; 220  : 		m_pChunk = NULL;

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN4@CSBufPool:

; 221  : 	}
; 222  : 
; 223  : 	if (m_nFlagArray) {

  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	85 c0		 test	 eax, eax
  00020	74 11		 je	 SHORT $LN5@CSBufPool

; 224  : 		free(m_nFlagArray);

  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00029	83 c4 04	 add	 esp, 4

; 225  : 		m_nFlagArray = NULL;

  0002c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@CSBufPool:
  00033	5e		 pop	 esi

; 212  : 	destroy();
; 213  : }

  00034	c3		 ret	 0
??1CSBufPool@@QAE@XZ ENDP				; CSBufPool::~CSBufPool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??0CSBufPool@@QAE@XZ
_TEXT	SEGMENT
??0CSBufPool@@QAE@XZ PROC				; CSBufPool::CSBufPool, COMDAT
; _this$ = ecx

; 199  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 200  : 	m_nAllocCount = 0;
; 201  : 	memset(g_szMessage, 0, LEN_MEM_MESSAGE);

  00003	68 80 00 00 00	 push	 128			; 00000080H
  00008	6a 00		 push	 0
  0000a	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 	m_pChunk = NULL;

  0001e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 203  : 	m_nUseCnt = 0;

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 204  : 	m_nFlagArray = NULL;
; 205  : 	m_pEnd = NULL;
; 206  : 	m_nShift = 0;
; 207  : }

  0002b	8b c6		 mov	 eax, esi
  0002d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00034	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00042	5e		 pop	 esi
  00043	c3		 ret	 0
??0CSBufPool@@QAE@XZ ENDP				; CSBufPool::CSBufPool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?ISINCLUDE_ADDRESS@CBufPool@@QAE_NPAD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ISINCLUDE_ADDRESS@CBufPool@@QAE_NPAD@Z PROC		; CBufPool::ISINCLUDE_ADDRESS, COMDAT
; _this$ = ecx

; 81   : 	inline bool ISINCLUDE_ADDRESS(char *p) { if(m_pChunk <= p && p <= m_pEnd) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  00009	77 0b		 ja	 SHORT $LN2@ISINCLUDE_
  0000b	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  0000e	77 06		 ja	 SHORT $LN2@ISINCLUDE_
  00010	b0 01		 mov	 al, 1
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@ISINCLUDE_:
  00016	32 c0		 xor	 al, al
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?ISINCLUDE_ADDRESS@CBufPool@@QAE_NPAD@Z ENDP		; CBufPool::ISINCLUDE_ADDRESS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CBufPool@@QAEXPADH@Z
_TEXT	SEGMENT
_pUsedMem$ = 8						; size = 4
_nCount$ = 12						; size = 4
?delMem@CBufPool@@QAEXPADH@Z PROC			; CBufPool::delMem, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	int i;
; 96   : 	int nPos = (int)(pUsedMem - m_pChunk);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pUsedMem$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	2b 43 18	 sub	 eax, DWORD PTR [ebx+24]

; 97   : 	int nIdx = nPos >> m_nShift;

  0000e	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00011	8b f0		 mov	 esi, eax

; 98   : 
; 99   : 	if (pUsedMem != &m_pChunk[nPos]) return;

  00013	03 43 18	 add	 eax, DWORD PTR [ebx+24]
  00016	d3 fe		 sar	 esi, cl
  00018	39 45 08	 cmp	 DWORD PTR _pUsedMem$[ebp], eax
  0001b	75 37		 jne	 SHORT $LN1@delMem

; 100  : 	for (i = 0; i < nCount; i++)

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  00020	33 ff		 xor	 edi, edi
  00022	85 c0		 test	 eax, eax
  00024	7e 29		 jle	 SHORT $LN3@delMem
$LL4@delMem:

; 101  : 	{
; 102  : 		if (nIdx >= m_nAllocCount) return;

  00026	3b 73 10	 cmp	 esi, DWORD PTR [ebx+16]
  00029	7d 29		 jge	 SHORT $LN1@delMem
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 91   : 	inline int getCount() { return (int)m_count; }

  0002b	8b 03		 mov	 eax, DWORD PTR [ebx]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 104  : 		if (m_nFlagArray[nIdx].getCount())

  0002d	83 3c b0 00	 cmp	 DWORD PTR [eax+esi*4], 0
  00031	74 13		 je	 SHORT $LN7@delMem
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 94   : 	inline void init() { m_count = 0; }

  00033	8b 03		 mov	 eax, DWORD PTR [ebx]
  00035	c7 04 b0 00 00
	00 00		 mov	 DWORD PTR [eax+esi*4], 0

; 98   : 	inline long atomic_decrement() { return InterlockedDecrement(&m_count);}

  0003c	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
$LN7@delMem:
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 100  : 	for (i = 0; i < nCount; i++)

  00046	8b 45 0c	 mov	 eax, DWORD PTR _nCount$[ebp]
  00049	47		 inc	 edi

; 105  : 		{
; 106  : 			m_nFlagArray[nIdx].init();
; 107  : 			m_nUseCnt.atomic_decrement();
; 108  : 		}
; 109  : 		nIdx++;

  0004a	46		 inc	 esi
  0004b	3b f8		 cmp	 edi, eax
  0004d	7c d7		 jl	 SHORT $LL4@delMem
$LN3@delMem:

; 110  : 	}
; 111  : 	m_nLastCount = nIdx - nCount;

  0004f	2b f0		 sub	 esi, eax
  00051	89 73 0c	 mov	 DWORD PTR [ebx+12], esi
$LN1@delMem:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 112  : }

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?delMem@CBufPool@@QAEXPADH@Z ENDP			; CBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMemList@CBufPool@@QAE_NH@Z
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
_nCount$ = 8						; size = 4
?newMemList@CBufPool@@QAE_NH@Z PROC			; CBufPool::newMemList, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 155  : 	if (m_nUseCnt.getCount()+nCount > m_nAllocCount) return false;

  00004	8b 55 08	 mov	 edx, DWORD PTR _nCount$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	33 db		 xor	 ebx, ebx
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 91   : 	inline int getCount() { return (int)m_count; }

  0000e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00011	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 155  : 	if (m_nUseCnt.getCount()+nCount > m_nAllocCount) return false;

  00014	03 c2		 add	 eax, edx
  00016	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  00019	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  0001c	0f 8f 90 00 00
	00		 jg	 $LN6@newMemList

; 157  : 	for (i=0; i < nCount; i++) {

  00022	89 5d fc	 mov	 DWORD PTR _i$1$[ebp], ebx
  00025	85 d2		 test	 edx, edx
  00027	7e 50		 jle	 SHORT $LN33@newMemList
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@newMemList:

; 158  : 		if (idx >= m_nAllocCount) break;

  00030	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  00033	7d 41		 jge	 SHORT $LN40@newMemList
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 91   : 	inline int getCount() { return (int)m_count; }

  00035	8b 07		 mov	 eax, DWORD PTR [edi]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 157  : 	for (i=0; i < nCount; i++) {

  00037	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]

; 159  : 		if (!m_nFlagArray[idx].getCount())

  0003e	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00042	75 32		 jne	 SHORT $LN40@newMemList

; 157  : 	for (i=0; i < nCount; i++) {

  00044	8b 07		 mov	 eax, DWORD PTR [edi]
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 99   : 	inline int atomic_compare_exchange(int nExchange, int nComperand) {return (int)InterlockedCompareExchange(&m_count, nExchange, nComperand);} // return long

  00046	6a 00		 push	 0
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 157  : 	for (i=0; i < nCount; i++) {

  00048	03 c1		 add	 eax, ecx
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 99   : 	inline int atomic_compare_exchange(int nExchange, int nComperand) {return (int)InterlockedCompareExchange(&m_count, nExchange, nComperand);} // return long

  0004a	6a 01		 push	 1
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedCompareExchange@12
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 161  : 			if (!m_nFlagArray[idx].atomic_compare_exchange(1, 0)) {

  00053	85 c0		 test	 eax, eax
  00055	75 1c		 jne	 SHORT $LN41@newMemList
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 97   : 	inline long atomic_increment() { return InterlockedIncrement(&m_count);}

  00057	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedIncrement@4
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 157  : 	for (i=0; i < nCount; i++) {

  00061	8b 45 fc	 mov	 eax, DWORD PTR _i$1$[ebp]

; 162  : 				m_nUseCnt.atomic_increment();
; 163  : 				nLastLoopCnt++;

  00064	43		 inc	 ebx
  00065	8b 55 08	 mov	 edx, DWORD PTR _nCount$[ebp]
  00068	40		 inc	 eax

; 164  : 			}
; 165  : 			else break;
; 166  : 		}
; 167  : 		else break;
; 168  : 		idx++;

  00069	46		 inc	 esi
  0006a	89 45 fc	 mov	 DWORD PTR _i$1$[ebp], eax
  0006d	3b c2		 cmp	 eax, edx
  0006f	7c bf		 jl	 SHORT $LL4@newMemList

; 157  : 	for (i=0; i < nCount; i++) {

  00071	eb 03		 jmp	 SHORT $LN40@newMemList
$LN41@newMemList:
  00073	8b 55 08	 mov	 edx, DWORD PTR _nCount$[ebp]
$LN40@newMemList:
  00076	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
$LN33@newMemList:

; 169  : 	}
; 170  : 
; 171  : 	if (nLastLoopCnt== nCount) {

  00079	3b da		 cmp	 ebx, edx
  0007b	75 0e		 jne	 SHORT $LN14@newMemList

; 172  : 		m_nLastCount = idx;

  0007d	89 77 0c	 mov	 DWORD PTR [edi+12], esi

; 173  : 		return true;

  00080	b0 01		 mov	 al, 1
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 184  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
$LN14@newMemList:

; 176  : 	for (idx = m_nLastCount; idx < nLastLoopCnt; idx++) {

  0008b	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0008e	3b f3		 cmp	 esi, ebx
  00090	7d 20		 jge	 SHORT $LN6@newMemList
$LL7@newMemList:
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 91   : 	inline int getCount() { return (int)m_count; }

  00092	8b 07		 mov	 eax, DWORD PTR [edi]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 177  : 		if (m_nFlagArray[idx].getCount())

  00094	83 3c b0 00	 cmp	 DWORD PTR [eax+esi*4], 0
  00098	74 10		 je	 SHORT $LN5@newMemList
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 94   : 	inline void init() { m_count = 0; }

  0009a	8b 07		 mov	 eax, DWORD PTR [edi]

; 98   : 	inline long atomic_decrement() { return InterlockedDecrement(&m_count);}

  0009c	51		 push	 ecx

; 94   : 	inline void init() { m_count = 0; }

  0009d	c7 04 b0 00 00
	00 00		 mov	 DWORD PTR [eax+esi*4], 0

; 98   : 	inline long atomic_decrement() { return InterlockedDecrement(&m_count);}

  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
$LN5@newMemList:
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 176  : 	for (idx = m_nLastCount; idx < nLastLoopCnt; idx++) {

  000aa	46		 inc	 esi
  000ab	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000ae	3b f3		 cmp	 esi, ebx
  000b0	7c e0		 jl	 SHORT $LL7@newMemList
$LN6@newMemList:
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi

; 178  : 		{
; 179  : 			m_nFlagArray[idx].init();
; 180  : 			m_nUseCnt.atomic_decrement();
; 181  : 		}
; 182  : 	}
; 183  : 	return false;

  000b4	32 c0		 xor	 al, al
  000b6	5b		 pop	 ebx

; 184  : }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
?newMemList@CBufPool@@QAE_NH@Z ENDP			; CBufPool::newMemList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CBufPool@@QAEXPAD@Z
_TEXT	SEGMENT
_pUsedMem$ = 8						; size = 4
?delMem@CBufPool@@QAEXPAD@Z PROC			; CBufPool::delMem, COMDAT
; _this$ = ecx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File e:\infinia-library-3.0\com\include\combufpool.h

; 81   : 	inline bool ISINCLUDE_ADDRESS(char *p) { if(m_pChunk <= p && p <= m_pEnd) return true; return false; }

  00003	8b 55 08	 mov	 edx, DWORD PTR _pUsedMem$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 76   : {

  00008	8b f1		 mov	 esi, ecx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 81   : 	inline bool ISINCLUDE_ADDRESS(char *p) { if(m_pChunk <= p && p <= m_pEnd) return true; return false; }

  0000a	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]
  0000d	3b da		 cmp	 ebx, edx
  0000f	77 34		 ja	 SHORT $LN6@delMem
  00011	3b 56 1c	 cmp	 edx, DWORD PTR [esi+28]
  00014	77 2f		 ja	 SHORT $LN6@delMem
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 83   : 	int nPos = (int)(pUsedMem - m_pChunk);

  00016	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00019	8b c2		 mov	 eax, edx
  0001b	2b c3		 sub	 eax, ebx
  0001d	57		 push	 edi

; 84   : 	int nIdx = nPos >> m_nShift;

  0001e	8b f8		 mov	 edi, eax

; 85   : 
; 86   :     if(pUsedMem == &m_pChunk[nPos]) {

  00020	03 c3		 add	 eax, ebx
  00022	d3 ff		 sar	 edi, cl
  00024	3b d0		 cmp	 edx, eax
  00026	75 16		 jne	 SHORT $LN13@delMem
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 94   : 	inline void init() { m_count = 0; }

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	c7 04 b8 00 00
	00 00		 mov	 DWORD PTR [eax+edi*4], 0

; 98   : 	inline long atomic_decrement() { return InterlockedDecrement(&m_count);}

  00031	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 89   : 		m_nLastCount = nIdx;

  0003b	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
$LN13@delMem:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@delMem:

; 77   : 	if(!ISINCLUDE_ADDRESS(pUsedMem)) {
; 78   : 		free(pUsedMem);

  00045	52		 push	 edx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0004c	83 c4 04	 add	 esp, 4
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?delMem@CBufPool@@QAEXPAD@Z ENDP			; CBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMem@CBufPool@@QAEPADXZ
_TEXT	SEGMENT
?newMem@CBufPool@@QAEPADXZ PROC				; CBufPool::newMem, COMDAT
; _this$ = ecx

; 115  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 116  : 	int i= m_nLastCount,j;
; 117  : 	if(m_nUseCnt.getCount() == m_nAllocCount) goto NEW_ALLOC;

  00005	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00008	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000b	39 4e 04	 cmp	 DWORD PTR [esi+4], ecx
  0000e	74 39		 je	 SHORT $NEW_ALLOC$26

; 118  : 	
; 119  : 	for(j = 0; j < m_nAllocCount; j++)

  00010	33 db		 xor	 ebx, ebx
  00012	85 c9		 test	 ecx, ecx
  00014	7e 33		 jle	 SHORT $NEW_ALLOC$26
$LL4@newMem:
  00016	33 ff		 xor	 edi, edi
  00018	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  0001b	0f 4c f8	 cmovl	 edi, eax
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 91   : 	inline int getCount() { return (int)m_count; }

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 122  : 		if(!m_nFlagArray[i].getCount()) 

  00020	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00027	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  0002b	75 13		 jne	 SHORT $LN9@newMem

; 124  : 			if(!m_nFlagArray[i].atomic_compare_exchange(1,0)) 

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 99   : 	inline int atomic_compare_exchange(int nExchange, int nComperand) {return (int)InterlockedCompareExchange(&m_count, nExchange, nComperand);} // return long

  0002f	6a 00		 push	 0
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 124  : 			if(!m_nFlagArray[i].atomic_compare_exchange(1,0)) 

  00031	03 c1		 add	 eax, ecx
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 99   : 	inline int atomic_compare_exchange(int nExchange, int nComperand) {return (int)InterlockedCompareExchange(&m_count, nExchange, nComperand);} // return long

  00033	6a 01		 push	 1
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedCompareExchange@12
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 124  : 			if(!m_nFlagArray[i].atomic_compare_exchange(1,0)) 

  0003c	85 c0		 test	 eax, eax
  0003e	74 22		 je	 SHORT $LN20@newMem
$LN9@newMem:

; 118  : 	
; 119  : 	for(j = 0; j < m_nAllocCount; j++)

  00040	43		 inc	 ebx

; 130  : 			}
; 131  : 		}
; 132  : 		i++;

  00041	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00044	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00047	7c cd		 jl	 SHORT $LL4@newMem
$NEW_ALLOC$26:

; 133  :     }    
; 134  : NEW_ALLOC:
; 135  : 	//if (m_nOverMaxCnt.getCount() < m_nOverCnt.getCount()) {
; 136  : 	//	m_nOverMaxCnt.atomic_exchange(m_nOverCnt.getCount());
; 137  : 	//	gs_cLogger.DebugLog(LEVEL_WARN, "update m_nOverMaxCnt[%d]", m_nOverMaxCnt.getCount());
; 138  : 	//}
; 139  : 	char * p = (char *)calloc(1, g_nSizeList[m_nShift]);

  00049	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0004c	ff 34 85 00 00
	00 00		 push	 DWORD PTR ?g_nSizeList@@3QBHB[eax*4]
  00053	6a 01		 push	 1
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0005b	83 c4 08	 add	 esp, 8
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 140  : 	//if (p) {
; 141  : 	//	m_nOverCnt.atomic_increment();
; 142  : 	//	gs_cLogger.DebugLog(LEVEL_TRACE, "update m_nOverCnt[%d] m_nShift[%d] m_nAllocCount[%d]", m_nOverCnt.atomic_increment(), m_nShift, m_nAllocCount);
; 143  : 	//}
; 144  : 	//else {
; 145  : 	//	gs_cLogger.DebugLog(LEVEL_ERROR, "calloc has Failed");
; 146  : 	//}
; 147  : 	return p;
; 148  : }

  00061	c3		 ret	 0
$LN20@newMem:
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 97   : 	inline long atomic_increment() { return InterlockedIncrement(&m_count);}

  00062	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedIncrement@4
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 128  : 				memset(&m_pChunk[i << m_nShift], 0, g_nSizeList[m_nShift]);

  0006c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0006f	8b d7		 mov	 edx, edi
  00071	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00074	d3 e2		 shl	 edx, cl
  00076	03 56 18	 add	 edx, DWORD PTR [esi+24]
  00079	ff 34 8d 00 00
	00 00		 push	 DWORD PTR ?g_nSizeList@@3QBHB[ecx*4]
  00080	6a 00		 push	 0
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 _memset

; 129  : 				return &m_pChunk[i << m_nShift];

  00088	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	d3 e7		 shl	 edi, cl
  00090	03 7e 18	 add	 edi, DWORD PTR [esi+24]
  00093	8b c7		 mov	 eax, edi
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 140  : 	//if (p) {
; 141  : 	//	m_nOverCnt.atomic_increment();
; 142  : 	//	gs_cLogger.DebugLog(LEVEL_TRACE, "update m_nOverCnt[%d] m_nShift[%d] m_nAllocCount[%d]", m_nOverCnt.atomic_increment(), m_nShift, m_nAllocCount);
; 143  : 	//}
; 144  : 	//else {
; 145  : 	//	gs_cLogger.DebugLog(LEVEL_ERROR, "calloc has Failed");
; 146  : 	//}
; 147  : 	return p;
; 148  : }

  00098	c3		 ret	 0
?newMem@CBufPool@@QAEPADXZ ENDP				; CBufPool::newMem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?alloc@CBufPool@@QAE_NHH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_nShift$ = 8						; size = 4
$T2 = 12						; size = 4
_nMaxCount$ = 12					; size = 4
?alloc@CBufPool@@QAE_NHH@Z PROC				; CBufPool::alloc, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?alloc@CBufPool@@QAE_NHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 34   : 	m_nFlagArray = new (std::nothrow) atomic_nr[nMaxCount];

  00027	8b 75 0c	 mov	 esi, DWORD PTR _nMaxCount$[ebp]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	8b c6		 mov	 eax, esi
  0002e	ba 04 00 00 00	 mov	 edx, 4
  00033	f7 e2		 mul	 edx
  00035	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0003a	0f 90 c1	 seto	 cl
  0003d	f7 d9		 neg	 ecx
  0003f	0b c8		 or	 ecx, eax
  00041	33 c0		 xor	 eax, eax
  00043	83 c1 04	 add	 ecx, 4
  00046	0f 92 c0	 setb	 al
  00049	f7 d8		 neg	 eax
  0004b	0b c1		 or	 eax, ecx
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 0c	 mov	 DWORD PTR $T2[ebp], eax
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	85 c0		 test	 eax, eax
  00062	74 1a		 je	 SHORT $LN8@alloc
  00064	68 00 00 00 00	 push	 OFFSET ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
  00069	68 00 00 00 00	 push	 OFFSET ??0win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::win_atomic
  0006e	56		 push	 esi
  0006f	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  00072	89 30		 mov	 DWORD PTR [eax], esi
  00074	6a 04		 push	 4
  00076	53		 push	 ebx
  00077	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0007c	eb 02		 jmp	 SHORT $LN9@alloc
$LN8@alloc:
  0007e	33 db		 xor	 ebx, ebx
$LN9@alloc:
  00080	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00087	89 1f		 mov	 DWORD PTR [edi], ebx

; 35   : 	if(m_nFlagArray == NULL) {

  00089	85 db		 test	 ebx, ebx
  0008b	75 31		 jne	 SHORT $LN5@alloc

; 36   : 		gs_cLogger.DebugLog(LEVEL_ERROR, "new m_nFlagArray");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FIAJCIIG@new?5m_nFlagArray?$AA@
  00092	6a 24		 push	 36			; 00000024H
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CIGGPOIC@CBufPool?3?3alloc?$AA@
  00099	6a 05		 push	 5
  0009b	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  000a0	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  000a5	83 c4 14	 add	 esp, 20			; 00000014H

; 37   : 		return false;

  000a8	32 c0		 xor	 al, al

; 59   : }

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 08 00	 ret	 8
$LN5@alloc:

; 39   : 	for (m_nLastCount = 0; m_nLastCount < nMaxCount; m_nLastCount++)

  000be	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  000c5	85 f6		 test	 esi, esi
  000c7	7e 1b		 jle	 SHORT $LN3@alloc
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@alloc:

; 40   : 	{
; 41   : 		m_nFlagArray[m_nLastCount].init();

  000d0	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000d3	8b 07		 mov	 eax, DWORD PTR [edi]
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 94   : 	inline void init() { m_count = 0; }

  000d5	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 39   : 	for (m_nLastCount = 0; m_nLastCount < nMaxCount; m_nLastCount++)

  000dc	ff 47 0c	 inc	 DWORD PTR [edi+12]
  000df	39 77 0c	 cmp	 DWORD PTR [edi+12], esi
  000e2	7c ec		 jl	 SHORT $LL4@alloc
$LN3@alloc:
; File e:\infinia-library-3.0\com\include\combufpool.h

; 52   : inline int getSizeByIndex(int nIdx) { return g_nSizeList[nIdx]; }

  000e4	8b 5d 08	 mov	 ebx, DWORD PTR _nShift$[ebp]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 44   : 	m_pChunk = (char *)calloc(nMaxCount, getSizeByIndex(nShift));

  000e7	ff 34 9d 00 00
	00 00		 push	 DWORD PTR ?g_nSizeList@@3QBHB[ebx*4]
  000ee	56		 push	 esi
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000f5	83 c4 08	 add	 esp, 8
  000f8	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 45   : 
; 46   :     if(m_pChunk == NULL) {

  000fb	85 c0		 test	 eax, eax
  000fd	75 6a		 jne	 SHORT $LN6@alloc

; 47   : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_pChunk alloc");

  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NFKBPBIP@m_pChunk?5alloc?$AA@
  00104	6a 2f		 push	 47			; 0000002fH
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CIGGPOIC@CBufPool?3?3alloc?$AA@
  0010b	6a 05		 push	 5
  0010d	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00112	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog

; 48   : 		delete[] m_nFlagArray;

  00117	8b 07		 mov	 eax, DWORD PTR [edi]
  00119	83 c4 14	 add	 esp, 20			; 00000014H
  0011c	85 c0		 test	 eax, eax
  0011e	74 2d		 je	 SHORT $LN20@alloc
  00120	68 00 00 00 00	 push	 OFFSET ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
  00125	ff 70 fc	 push	 DWORD PTR [eax-4]
  00128	8d 70 fc	 lea	 esi, DWORD PTR [eax-4]
  0012b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00132	6a 04		 push	 4
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0013a	8b 06		 mov	 eax, DWORD PTR [esi]
  0013c	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [eax*4+4]
  00143	50		 push	 eax
  00144	56		 push	 esi
  00145	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0014a	83 c4 08	 add	 esp, 8
$LN20@alloc:

; 49   : 		m_nFlagArray = NULL;

  0014d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 50   : 		return false;

  00153	32 c0		 xor	 al, al

; 59   : }

  00155	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00158	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015f	59		 pop	 ecx
  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c2 08 00	 ret	 8
$LN6@alloc:

; 51   :     }
; 52   : 
; 53   :     m_nAllocCount   = nMaxCount;

  00169	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 57   : 	m_pEnd = &m_pChunk[(m_nAllocCount-1)<< m_nShift];

  0016c	8b cb		 mov	 ecx, ebx
  0016e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00171	48		 dec	 eax
  00172	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00179	d3 e0		 shl	 eax, cl
  0017b	03 47 18	 add	 eax, DWORD PTR [edi+24]
  0017e	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 58   : 	return true;

  00181	b0 01		 mov	 al, 1
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 94   : 	inline void init() { m_count = 0; }

  00183	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 56   : 	m_nShift = nShift;

  0018a	89 5f 14	 mov	 DWORD PTR [edi+20], ebx

; 59   : }

  0018d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00190	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00197	59		 pop	 ecx
  00198	5f		 pop	 edi
  00199	5e		 pop	 esi
  0019a	5b		 pop	 ebx
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?alloc@CBufPool@@QAE_NHH@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00005	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??_V@YAXPAXABUnothrow_t@std@@@Z ; operator delete[]
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?alloc@CBufPool@@QAE_NHH@Z$1:
  00012	e8 00 00 00 00	 call	 ___std_terminate
  00017	c3		 ret	 0
__ehhandler$?alloc@CBufPool@@QAE_NHH@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?alloc@CBufPool@@QAE_NHH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?alloc@CBufPool@@QAE_NHH@Z ENDP				; CBufPool::alloc
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?clear@CBufPool@@QAEXXZ
_TEXT	SEGMENT
?clear@CBufPool@@QAEXXZ PROC				; CBufPool::clear, COMDAT
; _this$ = ecx

; 63   : {

  00000	8b d1		 mov	 edx, ecx

; 67   : 	for(i = 0; i < m_nAllocCount; i++)

  00002	33 c0		 xor	 eax, eax
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 94   : 	inline void init() { m_count = 0; }

  00004	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 66   : 	m_nLastCount = 0;

  0000b	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 67   : 	for(i = 0; i < m_nAllocCount; i++)

  00012	39 42 10	 cmp	 DWORD PTR [edx+16], eax
  00015	7e 18		 jle	 SHORT $LN3@clear
  00017	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@clear:
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 94   : 	inline void init() { m_count = 0; }

  00020	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00022	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 67   : 	for(i = 0; i < m_nAllocCount; i++)

  00029	40		 inc	 eax
  0002a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002d	7c f1		 jl	 SHORT $LL4@clear
$LN3@clear:
; File e:\infinia-library-3.0\com\include\combufpool.h

; 52   : inline int getSizeByIndex(int nIdx) { return g_nSizeList[nIdx]; }

  0002f	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 71   : 	memset(m_pChunk, 0, getSizeByIndex(m_nShift)*m_nAllocCount);

  00032	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?g_nSizeList@@3QBHB[eax*4]
  00039	0f af 42 10	 imul	 eax, DWORD PTR [edx+16]
  0003d	50		 push	 eax
  0003e	6a 00		 push	 0
  00040	ff 72 18	 push	 DWORD PTR [edx+24]
  00043	e8 00 00 00 00	 call	 _memset
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 72   : }

  0004b	c3		 ret	 0
?clear@CBufPool@@QAEXXZ ENDP				; CBufPool::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??1CBufPool@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CBufPool@@QAE@XZ PROC				; CBufPool::~CBufPool, COMDAT
; _this$ = ecx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CBufPool@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 21   :     if(m_pChunk) {

  00026	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00029	85 c0		 test	 eax, eax
  0002b	74 11		 je	 SHORT $LN2@CBufPool

; 22   :         free(m_pChunk);

  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00034	83 c4 04	 add	 esp, 4

; 23   :         m_pChunk = NULL;

  00037	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN2@CBufPool:

; 24   :     }
; 25   : 
; 26   :     if(m_nFlagArray) {

  0003e	8b 07		 mov	 eax, DWORD PTR [edi]
  00040	85 c0		 test	 eax, eax
  00042	74 33		 je	 SHORT $LN3@CBufPool

; 27   :         delete [] m_nFlagArray;
; 28   :         m_nFlagArray = NULL;

  00044	68 00 00 00 00	 push	 OFFSET ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
  00049	ff 70 fc	 push	 DWORD PTR [eax-4]
  0004c	8d 70 fc	 lea	 esi, DWORD PTR [eax-4]
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	6a 04		 push	 4
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0005e	8b 06		 mov	 eax, DWORD PTR [esi]
  00060	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [eax*4+4]
  00067	50		 push	 eax
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0006e	83 c4 08	 add	 esp, 8
  00071	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@CBufPool:

; 29   :     }	
; 30   : }

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CBufPool@@QAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1CBufPool@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CBufPool@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CBufPool@@QAE@XZ ENDP				; CBufPool::~CBufPool
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??0CBufPool@@QAE@XZ
_TEXT	SEGMENT
??0CBufPool@@QAE@XZ PROC				; CBufPool::CBufPool, COMDAT
; _this$ = ecx

; 7    : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 10   : 	memset(g_szMessage, 0 ,LEN_MEM_MESSAGE); 

  00003	68 80 00 00 00	 push	 128			; 00000080H
  00008	6a 00		 push	 0
  0000a	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h

; 87   : 	win_atomic() {m_count = 0;}

  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File e:\infinia-library-3.0\com\src\combufpool.cpp

; 8    : 	m_nAllocCount = 0;

  0001d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 9    : 	m_nLastCount = 0;

  00024	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 10   : 	memset(g_szMessage, 0 ,LEN_MEM_MESSAGE); 

  0002b	e8 00 00 00 00	 call	 _memset
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11   : 	m_pChunk = NULL;

  00033	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 12   : 	m_nFlagArray = NULL;

  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 13   : 	m_nShift = 0;
; 14   : 	m_pEnd = NULL;
; 15   : 	//m_nOverCnt.init();
; 16   : 	//m_nOverMaxCnt.init();
; 17   : }

  00040	8b c6		 mov	 eax, esi
  00042	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00049	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00050	5e		 pop	 esi
  00051	c3		 ret	 0
??0CBufPool@@QAE@XZ ENDP				; CBufPool::CBufPool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getSizeByIndex@@YAHH@Z
_TEXT	SEGMENT
_nIdx$ = 8						; size = 4
?getSizeByIndex@@YAHH@Z PROC				; getSizeByIndex, COMDAT

; 52   : inline int getSizeByIndex(int nIdx) { return g_nSizeList[nIdx]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nIdx$[ebp]
  00006	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?g_nSizeList@@3QBHB[eax*4]
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?getSizeByIndex@@YAHH@Z ENDP				; getSizeByIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_max$ = 12						; size = 4
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 09		 js	 SHORT $LN2@ISINCLUDE
  0000a	3b 45 0c	 cmp	 eax, DWORD PTR _max$[ebp]
  0000d	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  0000f	b0 01		 mov	 al, 1
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN2@ISINCLUDE:
  00013	32 c0		 xor	 al, al
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?bitSet_flag@@YAXHPAD@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$ = 12						; size = 4
?bitSet_flag@@YAXHPAD@Z PROC				; bitSet_flag, COMDAT

; 316  : inline void bitSet_flag(int n, char *p) {  p[n >> 3] |= (n & 7); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  0000b	80 e2 07	 and	 dl, 7
  0000e	c1 f9 03	 sar	 ecx, 3
  00011	08 14 08	 or	 BYTE PTR [eax+ecx], dl
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?bitSet_flag@@YAXHPAD@Z ENDP				; bitSet_flag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?bitClear_flag@@YAXHPAD@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$ = 12						; size = 4
?bitClear_flag@@YAXHPAD@Z PROC				; bitClear_flag, COMDAT

; 315  : inline void bitClear_flag(int n, char *p) {  p[n >> 3] &= ~(n & 7); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  0000b	80 e2 07	 and	 dl, 7
  0000e	c1 f9 03	 sar	 ecx, 3
  00011	f6 d2		 not	 dl
  00013	20 14 08	 and	 BYTE PTR [eax+ecx], dl
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?bitClear_flag@@YAXHPAD@Z ENDP				; bitClear_flag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?isBitSet_flag@@YA_NHPAD@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$ = 12						; size = 4
?isBitSet_flag@@YA_NHPAD@Z PROC				; isBitSet_flag, COMDAT

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char 배열 연산을 위해.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  0000b	c1 f9 03	 sar	 ecx, 3
  0000e	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  00012	83 e0 07	 and	 eax, 7
  00015	84 c2		 test	 al, dl
  00017	0f 95 c0	 setne	 al
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?isBitSet_flag@@YA_NHPAD@Z ENDP				; isBitSet_flag
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Ewin_atomic@win32@common@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ewin_atomic@win32@common@@QAEPAXI@Z PROC		; common::win32::win_atomic::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Ewin_atomic@win32@common@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 41		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1win_atomic@win32@common@@QAE@XZ ; common::win32::win_atomic::~win_atomic
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	6a 04		 push	 4
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00042	f6 c3 01	 test	 bl, 1
  00045	74 13		 je	 SHORT $LN3@vector
  00047	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00049	8d 0c 8d 04 00
	00 00		 lea	 ecx, DWORD PTR [ecx*4+4]
  00050	51		 push	 ecx
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00057	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005a	8b c7		 mov	 eax, edi
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
$LN2@vector:
  00070	f6 c3 01	 test	 bl, 1
  00073	74 0b		 je	 SHORT $LN4@vector
  00075	6a 04		 push	 4
  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0007d	83 c4 08	 add	 esp, 8
$LN4@vector:
  00080	8b c6		 mov	 eax, esi
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ewin_atomic@win32@common@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Ewin_atomic@win32@common@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Ewin_atomic@win32@common@@QAEPAXI@Z ENDP		; common::win32::win_atomic::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z
_TEXT	SEGMENT
_nExchange$ = 8						; size = 4
_nComperand$ = 12					; size = 4
?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z PROC ; common::win32::win_atomic::atomic_compare_exchange, COMDAT
; _this$ = ecx

; 99   : 	inline int atomic_compare_exchange(int nExchange, int nComperand) {return (int)InterlockedCompareExchange(&m_count, nExchange, nComperand);} // return long

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 0c	 push	 DWORD PTR _nComperand$[ebp]
  00006	ff 75 08	 push	 DWORD PTR _nExchange$[ebp]
  00009	51		 push	 ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedCompareExchange@12
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?atomic_compare_exchange@win_atomic@win32@common@@QAEHHH@Z ENDP ; common::win32::win_atomic::atomic_compare_exchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_decrement@win_atomic@win32@common@@QAEJXZ
_TEXT	SEGMENT
?atomic_decrement@win_atomic@win32@common@@QAEJXZ PROC	; common::win32::win_atomic::atomic_decrement, COMDAT
; _this$ = ecx

; 98   : 	inline long atomic_decrement() { return InterlockedDecrement(&m_count);}

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
  00007	c3		 ret	 0
?atomic_decrement@win_atomic@win32@common@@QAEJXZ ENDP	; common::win32::win_atomic::atomic_decrement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_increment@win_atomic@win32@common@@QAEJXZ
_TEXT	SEGMENT
?atomic_increment@win_atomic@win32@common@@QAEJXZ PROC	; common::win32::win_atomic::atomic_increment, COMDAT
; _this$ = ecx

; 97   : 	inline long atomic_increment() { return InterlockedIncrement(&m_count);}

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedIncrement@4
  00007	c3		 ret	 0
?atomic_increment@win_atomic@win32@common@@QAEJXZ ENDP	; common::win32::win_atomic::atomic_increment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?init@win_atomic@win32@common@@QAEXXZ
_TEXT	SEGMENT
?init@win_atomic@win32@common@@QAEXXZ PROC		; common::win32::win_atomic::init, COMDAT
; _this$ = ecx

; 94   : 	inline void init() { m_count = 0; }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c3		 ret	 0
?init@win_atomic@win32@common@@QAEXXZ ENDP		; common::win32::win_atomic::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?getCount@win_atomic@win32@common@@QAEHXZ
_TEXT	SEGMENT
?getCount@win_atomic@win32@common@@QAEHXZ PROC		; common::win32::win_atomic::getCount, COMDAT
; _this$ = ecx

; 91   : 	inline int getCount() { return (int)m_count; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?getCount@win_atomic@win32@common@@QAEHXZ ENDP		; common::win32::win_atomic::getCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1win_atomic@win32@common@@QAE@XZ
_TEXT	SEGMENT
??1win_atomic@win32@common@@QAE@XZ PROC			; common::win32::win_atomic::~win_atomic, COMDAT
; _this$ = ecx

; 88   : 	~win_atomic() {}

  00000	c3		 ret	 0
??1win_atomic@win32@common@@QAE@XZ ENDP			; common::win32::win_atomic::~win_atomic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0win_atomic@win32@common@@QAE@XZ
_TEXT	SEGMENT
??0win_atomic@win32@common@@QAE@XZ PROC			; common::win32::win_atomic::win_atomic, COMDAT
; _this$ = ecx

; 87   : 	win_atomic() {m_count = 0;}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0win_atomic@win32@common@@QAE@XZ ENDP			; common::win32::win_atomic::win_atomic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00006	8d 4d 10	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000f	6a ff		 push	 -1
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
